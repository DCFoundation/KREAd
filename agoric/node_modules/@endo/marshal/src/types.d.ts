export type PrimitiveStyle = "undefined" | "null" | "boolean" | "number" | "bigint" | "string" | "symbol";
export type PassStyle = PrimitiveStyle | "copyRecord" | "copyArray" | "tagged" | "remotable" | "error" | "promise";
/**
 * A Passable value that may be marshalled. It is classified as one of
 * PassStyle. A Passable must be hardened.
 *
 * A Passable has a pass-by-copy superstructure. This includes
 *    * the atomic pass-by-copy primitives ("undefined" | "null" |
 *      "boolean" | "number" | "bigint" | "string" | "symbol"),
 *    * the pass-by-copy containers
 *      ("copyRecord" | "copyArray" | "tagged") that
 *      contain other Passables,
 *    * and the special cases ("error" | "promise").
 *
 * A Passable's pass-by-copy superstructure ends in
 * PassableCap leafs ("remotable" | "promise"). Since a
 * Passable is hardened, its structure and classification is stable --- its
 * structure and classification cannot change even if some of the objects are
 * proxies.
 */
export type Passable = any;
export type PassStyleOf = (passable: Passable) => PassStyle;
/**
 * A Passable is PureData when its pass-by-copy superstructure whose
 * nodes are pass-by-copy composites (CopyArray, CopyRecord, Tagged) leaves are
 * primitives or empty composites. No remotables, promises, or errors.
 *
 * This check assures purity *given* that none of these pass-by-copy composites
 * can be a Proxy. TODO SECURITY BUG we plan to enforce this, giving these
 * pass-by-copy composites much of the same security properties as the
 * proposed Records and Tuples (TODO need link).
 *
 * Given this (currently counter-factual) assumption, a PureData value cannot
 * be used as a communications channel,
 * and can therefore be safely shared with subgraphs that should not be able
 * to communicate with each other.
 */
export type PureData = Passable;
/**
 * Might be an object explicitly declared to be `Remotable` using the
 * `Far` or `Remotable` functions, or a remote presence of a Remotable.
 */
export type Remotable = Passable;
/**
 * The leaves of a Passable's pass-by-copy superstructure.
 */
export type PassableCap = Promise<any> | Remotable;
export type CopyArray<T> = T[];
export type CopyRecord<T> = Record<string, T>;
/**
 * The tag is the value of the `[String.toStringTag]` property.
 */
export type CopyTagged = {
    [PASS_STYLE]: 'tagged';
    [Symbol.toStringTag]: string;
    payload: Passable;
};
export type ConvertValToSlot<Slot> = (val: PassableCap) => Slot;
export type ConvertSlotToVal<Slot> = (slot: Slot, iface?: InterfaceSpec | undefined) => PassableCap;
export type EncodingClass<T> = {
    '@qclass': T;
};
export type EncodingUnion = EncodingClass<'NaN'> | EncodingClass<'undefined'> | EncodingClass<'Infinity'> | EncodingClass<'-Infinity'> | (EncodingClass<'bigint'> & {
    digits: string;
}) | EncodingClass<'@@asyncIterator'> | (EncodingClass<'symbol'> & {
    name: string;
}) | (EncodingClass<'error'> & {
    name: string;
    message: string;
    errorId?: string;
}) | (EncodingClass<'slot'> & {
    index: number;
    iface?: InterfaceSpec;
}) | (EncodingClass<'hilbert'> & {
    original: Encoding;
    rest?: Encoding;
}) | (EncodingClass<'tagged'> & {
    tag: string;
    payload: Encoding;
});
/**
 * We exclude '@qclass' as a property in encoding records.
 */
export type EncodingRecord = {
    [index: string]: Encoding;
    '@qclass'?: undefined;
};
export type EncodingElement = EncodingUnion | null | string | boolean | number | EncodingRecord;
/**
 * The JSON structure that the data portion of a Passable serializes to.
 *
 * The QCLASS 'hilbert' is a reference to the Hilbert Hotel
 * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel
 * If QCLASS appears as a property name in the data, we encode it instead
 * as a QCLASS record of type 'hilbert'. To do so, we must move the other
 * parts of the record into fields of the hilbert record.
 */
export type Encoding = EncodingElement | NestedArray<EncodingElement>;
export type CapData<Slot> = {
    /**
     * A JSON.stringify of an Encoding
     */
    body: string;
    slots: Slot[];
};
export type Serialize<Slot> = (val: Passable) => CapData<Slot>;
export type Unserialize<Slot> = (data: CapData<Slot>) => Passable;
export type Marshal<Slot> = {
    serialize: Serialize<Slot>;
    unserialize: Unserialize<Slot>;
};
export type MakeMarshalOptions = {
    /**
     * controls whether serialized errors
     * also carry tagging information, made from `marshalName` and numbers
     * generated (currently by counting) starting at `errorIdNum`. The
     * `errorTagging` option defaults to `'on'`. Serialized
     * errors are also logged to `marshalSaveError` only if tagging is `'on'`.
     */
    errorTagging?: ('on' | 'off') | undefined;
    /**
     * Used to identify sent errors.
     */
    marshalName?: string | undefined;
    /**
     * Ascending numbers staring from here
     * identify the sending of errors relative to this marshal instance.
     */
    errorIdNum?: number | undefined;
    /**
     * If `errorTagging` is
     * `'on'`, then errors serialized by this marshal instance are also
     * logged by calling `marshalSaveError` *after* `assert.note` associated
     * that error with its errorId. Thus, if `marshalSaveError` in turn logs
     * to the normal console, which is the default, then the console will
     * show that note showing the associated errorId.
     */
    marshalSaveError?: ((err: Error) => void) | undefined;
};
/**
 * This is an interface specification.
 * For now, it is just a string, but will eventually be `PureData`. Either
 * way, it must remain pure, so that it can be safely shared by subgraphs that
 * are not supposed to be able to communicate.
 */
export type InterfaceSpec = string;
/**
 * Simple semantics, just tell what interface (or undefined) a remotable has.
 */
export type MarshalGetInterfaceOf = (maybeRemotable: any) => InterfaceSpec | undefined;
/**
 * Internal to a useful pattern for writing checking logic
 * (a "checkFoo" function) that can be used to implement a predicate
 * (an "isFoo" function) or a validator (an "assertFoo" function).
 *
 *  * A predicate ideally only returns `true` or `false` and rarely throws.
 *  * A validator throws an informative diagnostic when the predicate
 *    would have returned `false`, and simply returns `undefined` normally
 *    when the predicate would have returned `true`.
 *  * The internal checking function that they share is parameterized by a
 *    `Checker` that determines how to proceed with a failure condition.
 *    Predicates pass in an identity function as checker. Validators
 *    pass in `assertChecker` which is a trivial wrapper around `assert`.
 *
 * See the various uses for good examples.
 */
export type Checker = (cond: boolean, details?: Details | undefined) => boolean;
//# sourceMappingURL=types.d.ts.map