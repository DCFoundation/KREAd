{"ast":null,"code":"// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// @ts-check\nimport { Set, String, TypeError, arrayForEach, defineProperty, getOwnPropertyDescriptor, getOwnPropertyDescriptors, getOwnPropertyNames, isObject, objectHasOwnProperty, ownKeys, setHas } from './commons.js';\nimport { minEnablements, moderateEnablements, severeEnablements } from './enablements.js';\n/**\n * For a special set of properties defined in the `enablement` whitelist,\n * `enablePropertyOverrides` ensures that the effect of freezing does not\n * suppress the ability to override these properties on derived objects by\n * simple assignment.\n *\n * Because of lack of sufficient foresight at the time, ES5 unfortunately\n * specified that a simple assignment to a non-existent property must fail if\n * it would override an non-writable data property of the same name in the\n * shadow of the prototype chain. In retrospect, this was a mistake, the\n * so-called \"override mistake\". But it is now too late and we must live with\n * the consequences.\n *\n * As a result, simply freezing an object to make it tamper proof has the\n * unfortunate side effect of breaking previously correct code that is\n * considered to have followed JS best practices, if this previous code used\n * assignment to override.\n *\n * For the enabled properties, `enablePropertyOverrides` effectively shims what\n * the assignment behavior would have been in the absence of the override\n * mistake. However, the shim produces an imperfect emulation. It shims the\n * behavior by turning these data properties into accessor properties, where\n * the accessor's getter and setter provide the desired behavior. For\n * non-reflective operations, the illusion is perfect. However, reflective\n * operations like `getOwnPropertyDescriptor` see the descriptor of an accessor\n * property rather than the descriptor of a data property. At the time of this\n * writing, this is the best we know how to do.\n *\n * To the getter of the accessor we add a property named\n * `'originalValue'` whose value is, as it says, the value that the\n * data property had before being converted to an accessor property. We add\n * this extra property to the getter for two reason:\n *\n * The harden algorithm walks the own properties reflectively, i.e., with\n * `getOwnPropertyDescriptor` semantics, rather than `[[Get]]` semantics. When\n * it sees an accessor property, it does not invoke the getter. Rather, it\n * proceeds to walk both the getter and setter as part of its transitive\n * traversal. Without this extra property, `enablePropertyOverrides` would have\n * hidden the original data property value from `harden`, which would be bad.\n * Instead, by exposing that value in an own data property on the getter,\n * `harden` finds and walks it anyway.\n *\n * We enable a form of cooperative emulation, giving reflective code an\n * opportunity to cooperate in upholding the illusion. When such cooperative\n * reflective code sees an accessor property, where the accessor's getter\n * has an `originalValue` property, it knows that the getter is\n * alleging that it is the result of the `enablePropertyOverrides` conversion\n * pattern, so it can decide to cooperatively \"pretend\" that it sees a data\n * property with that value.\n *\n * @param {Record<string, any>} intrinsics\n * @param {'min' | 'moderate' | 'severe'} overrideTaming\n * @param {Iterable<string | symbol>} [overrideDebug]\n */\n\nexport default function enablePropertyOverrides(intrinsics, overrideTaming) {\n  let overrideDebug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const debugProperties = new Set(overrideDebug);\n\n  function enable(path, obj, prop, desc) {\n    if ('value' in desc && desc.configurable) {\n      const {\n        value\n      } = desc;\n\n      function getter() {\n        return value;\n      }\n\n      defineProperty(getter, 'originalValue', {\n        value,\n        writable: false,\n        enumerable: false,\n        configurable: false\n      });\n      const isDebug = setHas(debugProperties, prop);\n\n      function setter(newValue) {\n        if (obj === this) {\n          throw new TypeError(`Cannot assign to read only property '${String(prop)}' of '${path}'`);\n        }\n\n        if (objectHasOwnProperty(this, prop)) {\n          this[prop] = newValue;\n        } else {\n          if (isDebug) {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(new TypeError(`Override property ${prop}`));\n          }\n\n          defineProperty(this, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        }\n      }\n\n      defineProperty(obj, prop, {\n        get: getter,\n        set: setter,\n        enumerable: desc.enumerable,\n        configurable: desc.configurable\n      });\n    }\n  }\n\n  function enableProperty(path, obj, prop) {\n    const desc = getOwnPropertyDescriptor(obj, prop);\n\n    if (!desc) {\n      return;\n    }\n\n    enable(path, obj, prop, desc);\n  }\n\n  function enableAllProperties(path, obj) {\n    const descs = getOwnPropertyDescriptors(obj);\n\n    if (!descs) {\n      return;\n    } // TypeScript does not allow symbols to be used as indexes because it\n    // cannot recokon types of symbolized properties.\n    // @ts-ignore\n\n\n    arrayForEach(ownKeys(descs), prop => enable(path, obj, prop, descs[prop]));\n  }\n\n  function enableProperties(path, obj, plan) {\n    for (const prop of getOwnPropertyNames(plan)) {\n      const desc = getOwnPropertyDescriptor(obj, prop);\n\n      if (!desc || desc.get || desc.set) {\n        // No not a value property, nothing to do.\n        // eslint-disable-next-line no-continue\n        continue;\n      } // Plan has no symbol keys and we use getOwnPropertyNames()\n      // so `prop` cannot only be a string, not a symbol. We coerce it in place\n      // with `String(..)` anyway just as good hygiene, since these paths are just\n      // for diagnostic purposes.\n\n\n      const subPath = `${path}.${String(prop)}`;\n      const subPlan = plan[prop];\n\n      if (subPlan === true) {\n        enableProperty(subPath, obj, prop);\n      } else if (subPlan === '*') {\n        enableAllProperties(subPath, desc.value);\n      } else if (isObject(subPlan)) {\n        enableProperties(subPath, desc.value, subPlan);\n      } else {\n        throw new TypeError(`Unexpected override enablement plan ${subPath}`);\n      }\n    }\n  }\n\n  let plan;\n\n  switch (overrideTaming) {\n    case 'min':\n      {\n        plan = minEnablements;\n        break;\n      }\n\n    case 'moderate':\n      {\n        plan = moderateEnablements;\n        break;\n      }\n\n    case 'severe':\n      {\n        plan = severeEnablements;\n        break;\n      }\n\n    default:\n      {\n        throw new TypeError(`unrecognized overrideTaming ${overrideTaming}`);\n      }\n  } // Do the repair.\n\n\n  enableProperties('root', intrinsics, plan);\n}","map":{"version":3,"names":["Set","String","TypeError","arrayForEach","defineProperty","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getOwnPropertyNames","isObject","objectHasOwnProperty","ownKeys","setHas","minEnablements","moderateEnablements","severeEnablements","enablePropertyOverrides","intrinsics","overrideTaming","overrideDebug","debugProperties","enable","path","obj","prop","desc","configurable","value","getter","writable","enumerable","isDebug","setter","newValue","console","error","get","set","enableProperty","enableAllProperties","descs","enableProperties","plan","subPath","subPlan"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/enable-property-overrides.js"],"sourcesContent":["// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n\n// @ts-check\n\nimport {\n  Set,\n  String,\n  TypeError,\n  arrayForEach,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getOwnPropertyNames,\n  isObject,\n  objectHasOwnProperty,\n  ownKeys,\n  setHas,\n} from './commons.js';\n\nimport {\n  minEnablements,\n  moderateEnablements,\n  severeEnablements,\n} from './enablements.js';\n\n/**\n * For a special set of properties defined in the `enablement` whitelist,\n * `enablePropertyOverrides` ensures that the effect of freezing does not\n * suppress the ability to override these properties on derived objects by\n * simple assignment.\n *\n * Because of lack of sufficient foresight at the time, ES5 unfortunately\n * specified that a simple assignment to a non-existent property must fail if\n * it would override an non-writable data property of the same name in the\n * shadow of the prototype chain. In retrospect, this was a mistake, the\n * so-called \"override mistake\". But it is now too late and we must live with\n * the consequences.\n *\n * As a result, simply freezing an object to make it tamper proof has the\n * unfortunate side effect of breaking previously correct code that is\n * considered to have followed JS best practices, if this previous code used\n * assignment to override.\n *\n * For the enabled properties, `enablePropertyOverrides` effectively shims what\n * the assignment behavior would have been in the absence of the override\n * mistake. However, the shim produces an imperfect emulation. It shims the\n * behavior by turning these data properties into accessor properties, where\n * the accessor's getter and setter provide the desired behavior. For\n * non-reflective operations, the illusion is perfect. However, reflective\n * operations like `getOwnPropertyDescriptor` see the descriptor of an accessor\n * property rather than the descriptor of a data property. At the time of this\n * writing, this is the best we know how to do.\n *\n * To the getter of the accessor we add a property named\n * `'originalValue'` whose value is, as it says, the value that the\n * data property had before being converted to an accessor property. We add\n * this extra property to the getter for two reason:\n *\n * The harden algorithm walks the own properties reflectively, i.e., with\n * `getOwnPropertyDescriptor` semantics, rather than `[[Get]]` semantics. When\n * it sees an accessor property, it does not invoke the getter. Rather, it\n * proceeds to walk both the getter and setter as part of its transitive\n * traversal. Without this extra property, `enablePropertyOverrides` would have\n * hidden the original data property value from `harden`, which would be bad.\n * Instead, by exposing that value in an own data property on the getter,\n * `harden` finds and walks it anyway.\n *\n * We enable a form of cooperative emulation, giving reflective code an\n * opportunity to cooperate in upholding the illusion. When such cooperative\n * reflective code sees an accessor property, where the accessor's getter\n * has an `originalValue` property, it knows that the getter is\n * alleging that it is the result of the `enablePropertyOverrides` conversion\n * pattern, so it can decide to cooperatively \"pretend\" that it sees a data\n * property with that value.\n *\n * @param {Record<string, any>} intrinsics\n * @param {'min' | 'moderate' | 'severe'} overrideTaming\n * @param {Iterable<string | symbol>} [overrideDebug]\n */\nexport default function enablePropertyOverrides(\n  intrinsics,\n  overrideTaming,\n  overrideDebug = [],\n) {\n  const debugProperties = new Set(overrideDebug);\n  function enable(path, obj, prop, desc) {\n    if ('value' in desc && desc.configurable) {\n      const { value } = desc;\n\n      function getter() {\n        return value;\n      }\n      defineProperty(getter, 'originalValue', {\n        value,\n        writable: false,\n        enumerable: false,\n        configurable: false,\n      });\n\n      const isDebug = setHas(debugProperties, prop);\n\n      function setter(newValue) {\n        if (obj === this) {\n          throw new TypeError(\n            `Cannot assign to read only property '${String(\n              prop,\n            )}' of '${path}'`,\n          );\n        }\n        if (objectHasOwnProperty(this, prop)) {\n          this[prop] = newValue;\n        } else {\n          if (isDebug) {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(new TypeError(`Override property ${prop}`));\n          }\n          defineProperty(this, prop, {\n            value: newValue,\n            writable: true,\n            enumerable: true,\n            configurable: true,\n          });\n        }\n      }\n\n      defineProperty(obj, prop, {\n        get: getter,\n        set: setter,\n        enumerable: desc.enumerable,\n        configurable: desc.configurable,\n      });\n    }\n  }\n\n  function enableProperty(path, obj, prop) {\n    const desc = getOwnPropertyDescriptor(obj, prop);\n    if (!desc) {\n      return;\n    }\n    enable(path, obj, prop, desc);\n  }\n\n  function enableAllProperties(path, obj) {\n    const descs = getOwnPropertyDescriptors(obj);\n    if (!descs) {\n      return;\n    }\n    // TypeScript does not allow symbols to be used as indexes because it\n    // cannot recokon types of symbolized properties.\n    // @ts-ignore\n    arrayForEach(ownKeys(descs), prop => enable(path, obj, prop, descs[prop]));\n  }\n\n  function enableProperties(path, obj, plan) {\n    for (const prop of getOwnPropertyNames(plan)) {\n      const desc = getOwnPropertyDescriptor(obj, prop);\n      if (!desc || desc.get || desc.set) {\n        // No not a value property, nothing to do.\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      // Plan has no symbol keys and we use getOwnPropertyNames()\n      // so `prop` cannot only be a string, not a symbol. We coerce it in place\n      // with `String(..)` anyway just as good hygiene, since these paths are just\n      // for diagnostic purposes.\n      const subPath = `${path}.${String(prop)}`;\n      const subPlan = plan[prop];\n\n      if (subPlan === true) {\n        enableProperty(subPath, obj, prop);\n      } else if (subPlan === '*') {\n        enableAllProperties(subPath, desc.value);\n      } else if (isObject(subPlan)) {\n        enableProperties(subPath, desc.value, subPlan);\n      } else {\n        throw new TypeError(`Unexpected override enablement plan ${subPath}`);\n      }\n    }\n  }\n\n  let plan;\n  switch (overrideTaming) {\n    case 'min': {\n      plan = minEnablements;\n      break;\n    }\n    case 'moderate': {\n      plan = moderateEnablements;\n      break;\n    }\n    case 'severe': {\n      plan = severeEnablements;\n      break;\n    }\n    default: {\n      throw new TypeError(`unrecognized overrideTaming ${overrideTaming}`);\n    }\n  }\n\n  // Do the repair.\n  enableProperties('root', intrinsics, plan);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}