{"ast":null,"code":"import { FERAL_EVAL, Proxy, String, TypeError, create, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, globalThis, immutableObject, objectHasOwnProperty, reflectGet, reflectSet, seal } from './commons.js';\nimport { assert } from './error/assert.js';\nconst {\n  details: d,\n  quote: q\n} = assert;\n/**\n * alwaysThrowHandler\n * This is an object that throws if any property is called. It's used as\n * a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. It's safe to\n * create one and share it between all scopeHandlers.\n */\n\nconst alwaysThrowHandler = new Proxy(immutableObject, freeze({\n  get(_shadow, prop) {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.fail(d`Please report unexpected scope handler trap: ${q(String(prop))}`);\n  }\n\n}));\n/*\n * createScopeHandler()\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluate operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n * the real (unsafe) eval function, so it acts as a 'direct eval' and can\n * access its lexical scope (which maps to the 'with' binding, which the\n * ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n * which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\n\nexport const createScopeHandler = function (globalObject) {\n  let globalLexicals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let {\n    sloppyGlobalsMode = false\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // This flag allow us to determine if the eval() call is an done by the\n  // compartment's code or if it is user-land invocation, so we can react\n  // differently.\n  // Using a flag on an object with a single mutable property allows a safe\n  // evaluator to signal to the scope proxy without consuming a stack frame.\n  // Consuming a stack frame could possibly allow an attacker to control the\n  // stack depth before calling `evaluate` to cause a RangeError before this\n  // flag can be reset, leaving the unsafe evaluator available.\n  const scopeController = {\n    allowNextEvalToBeUnsafe: false\n  };\n  seal(scopeController);\n  const scopeProxyHandlerProperties = {\n    get(_shadow, prop) {\n      if (typeof prop === 'symbol') {\n        return undefined;\n      } // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n\n\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (scopeController.allowNextEvalToBeUnsafe === true) {\n          // revoke before use\n          scopeController.allowNextEvalToBeUnsafe = false;\n          return FERAL_EVAL;\n        } // fall through\n\n      } // Properties of the globalLexicals.\n\n\n      if (prop in globalLexicals) {\n        // Use reflect to defeat accessors that could be present on the\n        // globalLexicals object itself as `this`.\n        // This is done out of an overabundance of caution, as the SES shim\n        // only use the globalLexicals carry globalLexicals and live binding\n        // traps.\n        // The globalLexicals are captured as a snapshot of what's passed to\n        // the Compartment constructor, wherein all accessors and setters are\n        // eliminated and the result frozen.\n        // The live binding traps do use accessors, and none of those accessors\n        // make use of their receiver.\n        // Live binding traps provide no avenue for user code to observe the\n        // receiver.\n        return reflectGet(globalLexicals, prop, globalObject);\n      } // Properties of the global.\n\n\n      return reflectGet(globalObject, prop);\n    },\n\n    set(_shadow, prop, value) {\n      // Properties of the globalLexicals.\n      if (prop in globalLexicals) {\n        const desc = getOwnPropertyDescriptor(globalLexicals, prop);\n\n        if (objectHasOwnProperty(desc, 'value')) {\n          // Work around a peculiar behavior in the specs, where\n          // value properties are defined on the receiver.\n          return reflectSet(globalLexicals, prop, value);\n        } // Ensure that the 'this' value on setters resolves\n        // to the safeGlobal, not to the globalLexicals object.\n\n\n        return reflectSet(globalLexicals, prop, value, globalObject);\n      } // Properties of the global.\n\n\n      return reflectSet(globalObject, prop, value);\n    },\n\n    // we need has() to return false for some names to prevent the lookup from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object (globalThis), which is bad.\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n    has(_shadow, prop) {\n      // unsafeGlobal: hide all properties of the current global\n      // at the expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to globalObject instead of throwing a ReferenceError.\n      // !!!!!      WARNING: DANGER ZONE      !!!!!!\n      // The order of the conditions in the `||` expression below is of the\n      // utmost importance. Under no circumstances should `eval` be checked\n      // after `globalObject`. The prototype of the global object is under\n      // full control of user code and may be replaced by a proxy with a\n      // `has` trap. If we allow that trap to trigger while the\n      // `allowNextEvalToBeUnsafe` flag is down, it could allow user code\n      // to get a hold of `FERAL_EVAL`, resulting in a complete escape of\n      // the compartment.\n      // !!!!!      WARNING: DANGER ZONE      !!!!!!\n      return sloppyGlobalsMode || scopeController.allowNextEvalToBeUnsafe && prop === 'eval' || prop in globalLexicals || prop in globalObject || prop in globalThis;\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n    getPrototypeOf() {\n      return null;\n    },\n\n    // Chip has seen this happen single stepping under the Chrome/v8 debugger.\n    // TODO record how to reliably reproduce, and to test if this fix helps.\n    // TODO report as bug to v8 or Chrome, and record issue link here.\n    getOwnPropertyDescriptor(_target, prop) {\n      // Coerce with `String` in case prop is a symbol.\n      const quotedProp = q(String(prop)); // eslint-disable-next-line @endo/no-polymorphic-call\n\n      console.warn(`getOwnPropertyDescriptor trap on scopeHandler for ${quotedProp}`, new TypeError().stack);\n      return undefined;\n    }\n\n  }; // The scope handler's prototype is a proxy that throws if any trap other\n  // than get/set/has are run (like getOwnPropertyDescriptors, apply,\n  // getPrototypeOf).\n\n  const scopeHandler = freeze(create(alwaysThrowHandler, getOwnPropertyDescriptors(scopeProxyHandlerProperties)));\n  return {\n    scopeController,\n    scopeHandler\n  };\n};","map":{"version":3,"names":["FERAL_EVAL","Proxy","String","TypeError","create","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","globalThis","immutableObject","objectHasOwnProperty","reflectGet","reflectSet","seal","assert","details","d","quote","q","alwaysThrowHandler","get","_shadow","prop","fail","createScopeHandler","globalObject","globalLexicals","sloppyGlobalsMode","scopeController","allowNextEvalToBeUnsafe","scopeProxyHandlerProperties","undefined","set","value","desc","has","getPrototypeOf","_target","quotedProp","console","warn","stack","scopeHandler"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/scope-handler.js"],"sourcesContent":["import {\n  FERAL_EVAL,\n  Proxy,\n  String,\n  TypeError,\n  create,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  globalThis,\n  immutableObject,\n  objectHasOwnProperty,\n  reflectGet,\n  reflectSet,\n  seal,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\nconst { details: d, quote: q } = assert;\n\n/**\n * alwaysThrowHandler\n * This is an object that throws if any property is called. It's used as\n * a proxy handler which throws on any trap called.\n * It's made from a proxy with a get trap that throws. It's safe to\n * create one and share it between all scopeHandlers.\n */\nconst alwaysThrowHandler = new Proxy(\n  immutableObject,\n  freeze({\n    get(_shadow, prop) {\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      assert.fail(\n        d`Please report unexpected scope handler trap: ${q(String(prop))}`,\n      );\n    },\n  }),\n);\n\n/*\n * createScopeHandler()\n * ScopeHandler manages a Proxy which serves as the global scope for the\n * safeEvaluate operation (the Proxy is the argument of a 'with' binding).\n * As described in createSafeEvaluator(), it has several functions:\n * - allow the very first (and only the very first) use of 'eval' to map to\n * the real (unsafe) eval function, so it acts as a 'direct eval' and can\n * access its lexical scope (which maps to the 'with' binding, which the\n * ScopeHandler also controls).\n * - ensure that all subsequent uses of 'eval' map to the safeEvaluator,\n * which lives as the 'eval' property of the safeGlobal.\n * - route all other property lookups at the safeGlobal.\n * - hide the unsafeGlobal which lives on the scope chain above the 'with'.\n * - ensure the Proxy invariants despite some global properties being frozen.\n */\nexport const createScopeHandler = (\n  globalObject,\n  globalLexicals = {},\n  { sloppyGlobalsMode = false } = {},\n) => {\n  // This flag allow us to determine if the eval() call is an done by the\n  // compartment's code or if it is user-land invocation, so we can react\n  // differently.\n  // Using a flag on an object with a single mutable property allows a safe\n  // evaluator to signal to the scope proxy without consuming a stack frame.\n  // Consuming a stack frame could possibly allow an attacker to control the\n  // stack depth before calling `evaluate` to cause a RangeError before this\n  // flag can be reset, leaving the unsafe evaluator available.\n  const scopeController = {\n    allowNextEvalToBeUnsafe: false,\n  };\n  seal(scopeController);\n\n  const scopeProxyHandlerProperties = {\n    get(_shadow, prop) {\n      if (typeof prop === 'symbol') {\n        return undefined;\n      }\n\n      // Special treatment for eval. The very first lookup of 'eval' gets the\n      // unsafe (real direct) eval, so it will get the lexical scope that uses\n      // the 'with' context.\n      if (prop === 'eval') {\n        // test that it is true rather than merely truthy\n        if (scopeController.allowNextEvalToBeUnsafe === true) {\n          // revoke before use\n          scopeController.allowNextEvalToBeUnsafe = false;\n          return FERAL_EVAL;\n        }\n        // fall through\n      }\n\n      // Properties of the globalLexicals.\n      if (prop in globalLexicals) {\n        // Use reflect to defeat accessors that could be present on the\n        // globalLexicals object itself as `this`.\n        // This is done out of an overabundance of caution, as the SES shim\n        // only use the globalLexicals carry globalLexicals and live binding\n        // traps.\n        // The globalLexicals are captured as a snapshot of what's passed to\n        // the Compartment constructor, wherein all accessors and setters are\n        // eliminated and the result frozen.\n        // The live binding traps do use accessors, and none of those accessors\n        // make use of their receiver.\n        // Live binding traps provide no avenue for user code to observe the\n        // receiver.\n        return reflectGet(globalLexicals, prop, globalObject);\n      }\n\n      // Properties of the global.\n      return reflectGet(globalObject, prop);\n    },\n\n    set(_shadow, prop, value) {\n      // Properties of the globalLexicals.\n      if (prop in globalLexicals) {\n        const desc = getOwnPropertyDescriptor(globalLexicals, prop);\n        if (objectHasOwnProperty(desc, 'value')) {\n          // Work around a peculiar behavior in the specs, where\n          // value properties are defined on the receiver.\n          return reflectSet(globalLexicals, prop, value);\n        }\n        // Ensure that the 'this' value on setters resolves\n        // to the safeGlobal, not to the globalLexicals object.\n        return reflectSet(globalLexicals, prop, value, globalObject);\n      }\n\n      // Properties of the global.\n      return reflectSet(globalObject, prop, value);\n    },\n\n    // we need has() to return false for some names to prevent the lookup from\n    // climbing the scope chain and eventually reaching the unsafeGlobal\n    // object (globalThis), which is bad.\n\n    // todo: we'd like to just have has() return true for everything, and then\n    // use get() to raise a ReferenceError for anything not on the safe global.\n    // But we want to be compatible with ReferenceError in the normal case and\n    // the lack of ReferenceError in the 'typeof' case. Must either reliably\n    // distinguish these two cases (the trap behavior might be different), or\n    // we rely on a mandatory source-to-source transform to change 'typeof abc'\n    // to XXX. We already need a mandatory parse to prevent the 'import',\n    // since it's a special form instead of merely being a global variable/\n\n    // note: if we make has() return true always, then we must implement a\n    // set() trap to avoid subverting the protection of strict mode (it would\n    // accept assignments to undefined globals, when it ought to throw\n    // ReferenceError for such assignments)\n\n    has(_shadow, prop) {\n      // unsafeGlobal: hide all properties of the current global\n      // at the expense of 'typeof' being wrong for those properties. For\n      // example, in the browser, evaluating 'document = 3', will add\n      // a property to globalObject instead of throwing a ReferenceError.\n\n      // !!!!!      WARNING: DANGER ZONE      !!!!!!\n      // The order of the conditions in the `||` expression below is of the\n      // utmost importance. Under no circumstances should `eval` be checked\n      // after `globalObject`. The prototype of the global object is under\n      // full control of user code and may be replaced by a proxy with a\n      // `has` trap. If we allow that trap to trigger while the\n      // `allowNextEvalToBeUnsafe` flag is down, it could allow user code\n      // to get a hold of `FERAL_EVAL`, resulting in a complete escape of\n      // the compartment.\n      // !!!!!      WARNING: DANGER ZONE      !!!!!!\n      return (\n        sloppyGlobalsMode ||\n        (scopeController.allowNextEvalToBeUnsafe && prop === 'eval') ||\n        prop in globalLexicals ||\n        prop in globalObject ||\n        prop in globalThis\n      );\n    },\n\n    // note: this is likely a bug of safari\n    // https://bugs.webkit.org/show_bug.cgi?id=195534\n\n    getPrototypeOf() {\n      return null;\n    },\n\n    // Chip has seen this happen single stepping under the Chrome/v8 debugger.\n    // TODO record how to reliably reproduce, and to test if this fix helps.\n    // TODO report as bug to v8 or Chrome, and record issue link here.\n\n    getOwnPropertyDescriptor(_target, prop) {\n      // Coerce with `String` in case prop is a symbol.\n      const quotedProp = q(String(prop));\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      console.warn(\n        `getOwnPropertyDescriptor trap on scopeHandler for ${quotedProp}`,\n        new TypeError().stack,\n      );\n      return undefined;\n    },\n  };\n\n  // The scope handler's prototype is a proxy that throws if any trap other\n  // than get/set/has are run (like getOwnPropertyDescriptors, apply,\n  // getPrototypeOf).\n  const scopeHandler = freeze(\n    create(\n      alwaysThrowHandler,\n      getOwnPropertyDescriptors(scopeProxyHandlerProperties),\n    ),\n  );\n\n  return {\n    scopeController,\n    scopeHandler,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}