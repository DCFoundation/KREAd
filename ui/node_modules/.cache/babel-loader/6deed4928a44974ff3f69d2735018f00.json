{"ast":null,"code":"// @ts-check\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  getOwnPropertyDescriptors\n} = Object;\nconst {\n  apply,\n  ownKeys\n} = Reflect;\n\nconst ntypeof = specimen => specimen === null ? 'null' : typeof specimen;\n/**\n * @template T\n * @typedef {[boolean, T]} PriorityValue\n */\n\n/**\n * Compare two pairs of priority + string.\n *\n * @template T\n * @param {PriorityValue<T>} param0\n * @param {PriorityValue<T>} param1\n * @returns {-1 | 0 | 1}\n */\n\n\nexport const priorityValueCompare = (_ref, _ref2) => {\n  let [aIsPriority, aValue] = _ref;\n  let [bIsPriority, bValue] = _ref2;\n\n  if (aIsPriority && !bIsPriority) {\n    return -1;\n  }\n\n  if (!aIsPriority && bIsPriority) {\n    return 1;\n  } // Same priority, so compare by value.\n\n\n  if (aValue < bValue) {\n    return -1;\n  }\n\n  if (aValue > bValue) {\n    return 1;\n  }\n\n  return 0;\n};\n/**\n * Return an ordered array of own keys of a value.\n *\n * @todo This is only useful as a diagnostic if we don't have prototype\n * inheritance.\n * @param {any} specimen value to get ownKeys of\n */\n\nexport const sortedOwnKeys = specimen => {\n  /**\n   * Get the own keys of the specimen, no matter what type it is.  We don't want\n   * `ownKeys` to fail on non-objects.\n   *\n   * @type {(string | number | symbol)[]}\n   */\n  const keys = ownKeys(getOwnPropertyDescriptors(specimen));\n  /**\n   * Symbols are higher priority than strings, regardless of stringification.\n   *\n   * @type {PriorityValue<string>[]}\n   */\n\n  const priorityValues = keys.map(key => [typeof key === 'symbol', String(key)]);\n  /**\n   * Get the sorted-by-priorityValue indices into the keys array.\n   *\n   * @type {number[]}\n   */\n\n  const sortedIndices = new Array(priorityValues.length);\n\n  for (let i = 0; i < priorityValues.length; i += 1) {\n    sortedIndices[i] = i;\n  }\n\n  sortedIndices.sort((ai, bi) => priorityValueCompare(priorityValues[ai], priorityValues[bi]));\n  /**\n   * Return the sorted keys.\n   *\n   * @type {(string | symbol)[]}\n   */\n\n  return sortedIndices.map(i => keys[i]);\n};\nexport const localApplyFunction = (t, args) => {\n  assert.typeof(t, 'function', X`Cannot invoke target as a function; typeof target is ${q(ntypeof(t))}`);\n  return apply(t, undefined, args);\n};\nexport const localApplyMethod = (t, method, args) => {\n  if (method === undefined || method === null) {\n    // Base case; bottom out to apply functions.\n    return localApplyFunction(t, args);\n  }\n\n  if (t === undefined || t === null) {\n    assert.fail(X`Cannot deliver ${q(method)} to target; typeof target is ${q(ntypeof(t))}`, TypeError);\n  }\n\n  const fn = t[method];\n\n  if (fn === undefined) {\n    assert.fail(X`target has no method ${q(method)}, has ${q(sortedOwnKeys(t))}`, TypeError);\n  }\n\n  const ftype = ntypeof(fn);\n  assert.typeof(fn, 'function', X`invoked method ${q(method)} is not a function; it is a ${q(ftype)}`);\n  return apply(fn, t, args);\n};\nexport const localGet = (t, key) => t[key];","map":{"version":3,"names":["details","X","quote","q","assert","getOwnPropertyDescriptors","Object","apply","ownKeys","Reflect","ntypeof","specimen","priorityValueCompare","aIsPriority","aValue","bIsPriority","bValue","sortedOwnKeys","keys","priorityValues","map","key","String","sortedIndices","Array","length","i","sort","ai","bi","localApplyFunction","t","args","typeof","undefined","localApplyMethod","method","fail","TypeError","fn","ftype","localGet"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/eventual-send/src/local.js"],"sourcesContent":["// @ts-check\nconst { details: X, quote: q } = assert;\n\nconst { getOwnPropertyDescriptors } = Object;\nconst { apply, ownKeys } = Reflect;\n\nconst ntypeof = specimen => (specimen === null ? 'null' : typeof specimen);\n\n/**\n * @template T\n * @typedef {[boolean, T]} PriorityValue\n */\n\n/**\n * Compare two pairs of priority + string.\n *\n * @template T\n * @param {PriorityValue<T>} param0\n * @param {PriorityValue<T>} param1\n * @returns {-1 | 0 | 1}\n */\nexport const priorityValueCompare = (\n  [aIsPriority, aValue],\n  [bIsPriority, bValue],\n) => {\n  if (aIsPriority && !bIsPriority) {\n    return -1;\n  }\n  if (!aIsPriority && bIsPriority) {\n    return 1;\n  }\n\n  // Same priority, so compare by value.\n  if (aValue < bValue) {\n    return -1;\n  }\n  if (aValue > bValue) {\n    return 1;\n  }\n  return 0;\n};\n\n/**\n * Return an ordered array of own keys of a value.\n *\n * @todo This is only useful as a diagnostic if we don't have prototype\n * inheritance.\n * @param {any} specimen value to get ownKeys of\n */\nexport const sortedOwnKeys = specimen => {\n  /**\n   * Get the own keys of the specimen, no matter what type it is.  We don't want\n   * `ownKeys` to fail on non-objects.\n   *\n   * @type {(string | number | symbol)[]}\n   */\n  const keys = ownKeys(getOwnPropertyDescriptors(specimen));\n\n  /**\n   * Symbols are higher priority than strings, regardless of stringification.\n   *\n   * @type {PriorityValue<string>[]}\n   */\n  const priorityValues = keys.map(key => [\n    typeof key === 'symbol',\n    String(key),\n  ]);\n\n  /**\n   * Get the sorted-by-priorityValue indices into the keys array.\n   *\n   * @type {number[]}\n   */\n  const sortedIndices = new Array(priorityValues.length);\n  for (let i = 0; i < priorityValues.length; i += 1) {\n    sortedIndices[i] = i;\n  }\n  sortedIndices.sort((ai, bi) =>\n    priorityValueCompare(priorityValues[ai], priorityValues[bi]),\n  );\n\n  /**\n   * Return the sorted keys.\n   *\n   * @type {(string | symbol)[]}\n   */\n  return sortedIndices.map(i => keys[i]);\n};\n\nexport const localApplyFunction = (t, args) => {\n  assert.typeof(\n    t,\n    'function',\n    X`Cannot invoke target as a function; typeof target is ${q(ntypeof(t))}`,\n  );\n  return apply(t, undefined, args);\n};\n\nexport const localApplyMethod = (t, method, args) => {\n  if (method === undefined || method === null) {\n    // Base case; bottom out to apply functions.\n    return localApplyFunction(t, args);\n  }\n  if (t === undefined || t === null) {\n    assert.fail(\n      X`Cannot deliver ${q(method)} to target; typeof target is ${q(\n        ntypeof(t),\n      )}`,\n      TypeError,\n    );\n  }\n  const fn = t[method];\n  if (fn === undefined) {\n    assert.fail(\n      X`target has no method ${q(method)}, has ${q(sortedOwnKeys(t))}`,\n      TypeError,\n    );\n  }\n  const ftype = ntypeof(fn);\n  assert.typeof(\n    fn,\n    'function',\n    X`invoked method ${q(method)} is not a function; it is a ${q(ftype)}`,\n  );\n  return apply(fn, t, args);\n};\n\nexport const localGet = (t, key) => t[key];\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}