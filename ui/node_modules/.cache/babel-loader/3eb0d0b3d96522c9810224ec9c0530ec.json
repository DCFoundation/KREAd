{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { Nat } from '@endo/nat';\nimport { assertPassable, passStyleOf } from './passStyleOf.js';\nimport { getInterfaceOf } from './helpers/remotable.js';\nimport { ErrorHelper, getErrorConstructor } from './helpers/error.js';\nimport { makeTagged } from './makeTagged.js';\nimport { isObject, getTag } from './helpers/passStyle-helpers.js';\nimport { assertPassableSymbol, nameForPassableSymbol, passableSymbolForName } from './helpers/symbol.js';\n/** @typedef {import('./types.js').MakeMarshalOptions} MakeMarshalOptions */\n\n/** @template Slot @typedef {import('./types.js').ConvertSlotToVal<Slot>} ConvertSlotToVal */\n\n/** @template Slot @typedef {import('./types.js').ConvertValToSlot<Slot>} ConvertValToSlot */\n\n/** @template Slot @typedef {import('./types.js').Serialize<Slot>} Serialize */\n\n/** @template Slot @typedef {import('./types.js').Unserialize<Slot>} Unserialize */\n\n/** @typedef {import('./types.js').Passable} Passable */\n\n/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */\n\n/** @typedef {import('./types.js').Encoding} Encoding */\n\nconst {\n  ownKeys\n} = Reflect;\nconst {\n  isArray\n} = Array;\nconst {\n  getOwnPropertyDescriptors,\n  defineProperties,\n  is,\n  fromEntries,\n  freeze\n} = Object;\nconst {\n  details: X,\n  quote: q\n} = assert;\n/**\n * Special property name that indicates an encoding that needs special\n * decoding.\n */\n\nconst QCLASS = '@qclass';\nexport { QCLASS };\n/** @type {ConvertValToSlot<any>} */\n\nconst defaultValToSlotFn = x => x;\n/** @type {ConvertSlotToVal<any>} */\n\n\nconst defaultSlotToValFn = (x, _) => x;\n/**\n * @template Slot\n * @param {ConvertValToSlot<Slot>} [convertValToSlot]\n * @param {ConvertSlotToVal<Slot>} [convertSlotToVal]\n * @param {MakeMarshalOptions} [options]\n */\n\n\nexport const makeMarshal = function () {\n  let convertValToSlot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultValToSlotFn;\n  let convertSlotToVal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultSlotToValFn;\n  let {\n    errorTagging = 'on',\n    marshalName = 'anon-marshal',\n    // TODO Temporary hack.\n    // See https://github.com/Agoric/agoric-sdk/issues/2780\n    errorIdNum = 10000,\n    // We prefer that the caller instead log to somewhere hidden\n    // to be revealed when correlating with the received error.\n    marshalSaveError = err => console.log('Temporary logging of sent error', err)\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  assert.typeof(marshalName, 'string');\n  assert(errorTagging === 'on' || errorTagging === 'off', X`The errorTagging option can only be \"on\" or \"off\" ${errorTagging}`);\n\n  const nextErrorId = () => {\n    errorIdNum += 1;\n    return `error:${marshalName}#${errorIdNum}`;\n  };\n  /**\n   * @type {Serialize<Slot>}\n   */\n\n\n  const serialize = root => {\n    const slots = []; // maps val (promise or remotable) to index of slots[]\n\n    const slotMap = new Map();\n    /**\n     * @param {Passable} val\n     * @param {InterfaceSpec=} iface\n     * @returns {Encoding}\n     */\n\n    function serializeSlot(val) {\n      let iface = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n      let slotIndex;\n\n      if (slotMap.has(val)) {\n        // TODO assert that it's the same iface as before\n        slotIndex = slotMap.get(val);\n        assert.typeof(slotIndex, 'number');\n        iface = undefined;\n      } else {\n        const slot = convertValToSlot(val);\n        slotIndex = slots.length;\n        slots.push(slot);\n        slotMap.set(val, slotIndex);\n      } // TODO explore removing this special case\n\n\n      if (iface === undefined) {\n        return harden({\n          [QCLASS]: 'slot',\n          index: slotIndex\n        });\n      }\n\n      return harden({\n        [QCLASS]: 'slot',\n        iface,\n        index: slotIndex\n      });\n    }\n    /**\n     * Even if an Error is not actually passable, we'd rather send\n     * it anyway because the diagnostic info carried by the error\n     * is more valuable than diagnosing why the error isn't\n     * passable. See comments in ErrorHelper.\n     *\n     * @param {Error} err\n     * @returns {Encoding}\n     */\n\n\n    const encodeError = err => {\n      // Must encode `cause`, `errors`.\n      // nested non-passable errors must be ok from here.\n      if (errorTagging === 'on') {\n        // We deliberately do not share the stack, but it would\n        // be useful to log the stack locally so someone who has\n        // privileged access to the throwing Vat can correlate\n        // the problem with the remote Vat that gets this\n        // summary. If we do that, we could allocate some random\n        // identifier and include it in the message, to help\n        // with the correlation.\n        const errorId = nextErrorId();\n        assert.note(err, X`Sent as ${errorId}`);\n        marshalSaveError(err);\n        return harden({\n          [QCLASS]: 'error',\n          errorId,\n          message: `${err.message}`,\n          name: `${err.name}`\n        });\n      } else {\n        return harden({\n          [QCLASS]: 'error',\n          message: `${err.message}`,\n          name: `${err.name}`\n        });\n      }\n    };\n    /**\n     * Must encode `val` into plain JSON data *canonically*, such that\n     * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v1))`\n     * For each copyRecord, we only accept string property names,\n     * not symbols. The encoded form the sort\n     * order of these names must be the same as their enumeration\n     * order, so a `JSON.stringify` of the encoded form agrees with\n     * a canonical-json stringify of the encoded form.\n     *\n     * @param {Passable} val\n     * @returns {Encoding}\n     */\n\n\n    const encode = val => {\n      if (ErrorHelper.canBeValid(val)) {\n        return encodeError(val);\n      } // First we handle all primitives. Some can be represented directly as\n      // JSON, and some must be encoded as [QCLASS] composites.\n\n\n      const passStyle = passStyleOf(val);\n\n      switch (passStyle) {\n        case 'null':\n          {\n            return null;\n          }\n\n        case 'undefined':\n          {\n            return harden({\n              [QCLASS]: 'undefined'\n            });\n          }\n\n        case 'string':\n        case 'boolean':\n          {\n            return val;\n          }\n\n        case 'number':\n          {\n            if (Number.isNaN(val)) {\n              return harden({\n                [QCLASS]: 'NaN'\n              });\n            }\n\n            if (is(val, -0)) {\n              return 0;\n            }\n\n            if (val === Infinity) {\n              return harden({\n                [QCLASS]: 'Infinity'\n              });\n            }\n\n            if (val === -Infinity) {\n              return harden({\n                [QCLASS]: '-Infinity'\n              });\n            }\n\n            return val;\n          }\n\n        case 'bigint':\n          {\n            return harden({\n              [QCLASS]: 'bigint',\n              digits: String(val)\n            });\n          }\n\n        case 'symbol':\n          {\n            assertPassableSymbol(val);\n            const name =\n            /** @type {string} */\n            nameForPassableSymbol(val);\n\n            if (name === '@@asyncIterator') {\n              // Deprectated qclass. TODO make conditional\n              // on environment variable. Eventually remove, but only after\n              // confident that all supported receivers understand\n              // `[QCLASS]: 'symbol'`.\n              return harden({\n                [QCLASS]: '@@asyncIterator'\n              });\n            }\n\n            return harden({\n              [QCLASS]: 'symbol',\n              name\n            });\n          }\n\n        case 'copyRecord':\n          {\n            if (QCLASS in val) {\n              // Hilbert hotel\n              const {\n                [QCLASS]: qclassValue,\n                ...rest\n              } = val;\n\n              if (ownKeys(rest).length === 0) {\n                /** @type {Encoding} */\n                const result = harden({\n                  [QCLASS]: 'hilbert',\n                  original: encode(qclassValue)\n                });\n                return result;\n              } else {\n                /** @type {Encoding} */\n                const result = harden({\n                  [QCLASS]: 'hilbert',\n                  original: encode(qclassValue),\n                  // See https://github.com/Agoric/agoric-sdk/issues/4313\n                  rest: encode(freeze(rest))\n                });\n                return result;\n              }\n            } // Currently copyRecord allows only string keys so this will\n            // work. If we allow sortable symbol keys, this will need to\n            // become more interesting.\n\n\n            const names = ownKeys(val).sort();\n            return fromEntries(names.map(name => [name, encode(val[name])]));\n          }\n\n        case 'copyArray':\n          {\n            return val.map(encode);\n          }\n\n        case 'tagged':\n          {\n            /** @type {Encoding} */\n            const result = harden({\n              [QCLASS]: 'tagged',\n              tag: getTag(val),\n              payload: encode(val.payload)\n            });\n            return result;\n          }\n\n        case 'remotable':\n          {\n            const iface = getInterfaceOf(val); // console.log(`serializeSlot: ${val}`);\n\n            return serializeSlot(val, iface);\n          }\n\n        case 'error':\n          {\n            return encodeError(val);\n          }\n\n        case 'promise':\n          {\n            // console.log(`serializeSlot: ${val}`);\n            return serializeSlot(val);\n          }\n\n        default:\n          {\n            assert.fail(X`unrecognized passStyle ${q(passStyle)}`, TypeError);\n          }\n      }\n    };\n\n    const encoded = encode(root);\n    return harden({\n      body: JSON.stringify(encoded),\n      slots\n    });\n  };\n\n  const makeFullRevive = slots => {\n    /** @type {Map<number, Passable>} */\n    const valMap = new Map();\n\n    function unserializeSlot(index, iface) {\n      if (valMap.has(index)) {\n        return valMap.get(index);\n      } // TODO SECURITY HAZARD: must enfoce that remotable vs promise\n      // is according to the encoded string.\n\n\n      const slot = slots[Number(Nat(index))];\n      const val = convertSlotToVal(slot, iface);\n      valMap.set(index, val);\n      return val;\n    }\n    /**\n     * We stay close to the algorithm at\n     * https://tc39.github.io/ecma262/#sec-json.parse , where\n     * fullRevive(harden(JSON.parse(str))) is like JSON.parse(str, revive))\n     * for a similar reviver. But with the following differences:\n     *\n     * Rather than pass a reviver to JSON.parse, we first call a plain\n     * (one argument) JSON.parse to get rawTree, and then post-process\n     * the rawTree with fullRevive. The kind of revive function\n     * handled by JSON.parse only does one step in post-order, with\n     * JSON.parse doing the recursion. By contrast, fullParse does its\n     * own recursion in the same pre-order in which the replacer visited them.\n     *\n     * In order to break cycles, the potentially cyclic objects are\n     * not frozen during the recursion. Rather, the whole graph is\n     * hardened before being returned. Error objects are not\n     * potentially recursive, and so may be harmlessly hardened when\n     * they are produced.\n     *\n     * fullRevive can produce properties whose value is undefined,\n     * which a JSON.parse on a reviver cannot do. If a reviver returns\n     * undefined to JSON.parse, JSON.parse will delete the property\n     * instead.\n     *\n     * fullRevive creates and returns a new graph, rather than\n     * modifying the original tree in place.\n     *\n     * fullRevive may rely on rawTree being the result of a plain call\n     * to JSON.parse. However, it *cannot* rely on it having been\n     * produced by JSON.stringify on the replacer above, i.e., it\n     * cannot rely on it being a valid marshalled\n     * representation. Rather, fullRevive must validate that.\n     *\n     * @param {Encoding} rawTree must be hardened\n     */\n\n\n    function fullRevive(rawTree) {\n      if (!isObject(rawTree)) {\n        // primitives pass through\n        return rawTree;\n      } // Assertions of the above to narrow the type.\n\n\n      assert.typeof(rawTree, 'object');\n      assert(rawTree !== null);\n\n      if (QCLASS in rawTree) {\n        const qclass = rawTree[QCLASS];\n        assert.typeof(qclass, 'string', X`invalid qclass typeof ${q(typeof qclass)}`);\n        assert(!isArray(rawTree)); // Switching on `rawTree[QCLASS]` (or anything less direct, like\n        // `qclass`) does not discriminate rawTree in typescript@4.2.3 and\n        // earlier.\n\n        switch (rawTree['@qclass']) {\n          // Encoding of primitives not handled by JSON\n          case 'undefined':\n            {\n              return undefined;\n            }\n\n          case 'NaN':\n            {\n              return NaN;\n            }\n\n          case 'Infinity':\n            {\n              return Infinity;\n            }\n\n          case '-Infinity':\n            {\n              return -Infinity;\n            }\n\n          case 'bigint':\n            {\n              const {\n                digits\n              } = rawTree;\n              assert.typeof(digits, 'string', X`invalid digits typeof ${q(typeof digits)}`);\n              return BigInt(digits);\n            }\n\n          case '@@asyncIterator':\n            {\n              // Deprectated qclass. TODO make conditional\n              // on environment variable. Eventually remove, but after confident\n              // that there are no more supported senders.\n              return Symbol.asyncIterator;\n            }\n\n          case 'symbol':\n            {\n              const {\n                name\n              } = rawTree;\n              return passableSymbolForName(name);\n            }\n\n          case 'tagged':\n            {\n              const {\n                tag,\n                payload\n              } = rawTree;\n              return makeTagged(tag, fullRevive(payload));\n            }\n\n          case 'error':\n            {\n              // Must decode `cause` and `errors` properties\n              const {\n                name,\n                message,\n                errorId\n              } = rawTree;\n              assert.typeof(name, 'string', X`invalid error name typeof ${q(typeof name)}`);\n              assert.typeof(message, 'string', X`invalid error message typeof ${q(typeof message)}`);\n              const EC = getErrorConstructor(`${name}`) || Error; // errorId is a late addition so be tolerant of its absence.\n\n              const errorName = errorId === undefined ? `Remote${EC.name}` : `Remote${EC.name}(${errorId})`; // Due to a defect in the SES type definition, the next line is\n              // fails a type check.\n              // Pending https://github.com/endojs/endo/issues/977\n              // @ts-ignore-next-line\n\n              const error = assert.error(`${message}`, EC, {\n                errorName\n              });\n              return error;\n            }\n\n          case 'slot':\n            {\n              const {\n                index,\n                iface\n              } = rawTree;\n              const val = unserializeSlot(index, iface);\n              return val;\n            }\n\n          case 'hilbert':\n            {\n              const {\n                original,\n                rest\n              } = rawTree;\n              assert('original' in rawTree, X`Invalid Hilbert Hotel encoding ${rawTree}`); // Don't harden since we're not done mutating it\n\n              const result = {\n                [QCLASS]: fullRevive(original)\n              };\n\n              if ('rest' in rawTree) {\n                assert(rest !== undefined, X`Rest encoding must not be undefined`);\n                const restObj = fullRevive(rest); // TODO really should assert that `passStyleOf(rest)` is\n                // `'copyRecord'` but we'd have to harden it and it is too\n                // early to do that.\n\n                assert(!(QCLASS in restObj), X`Rest must not contain its own definition of ${q(QCLASS)}`);\n                defineProperties(result, getOwnPropertyDescriptors(restObj));\n              }\n\n              return result;\n            }\n\n          default:\n            {\n              assert( // @ts-expect-error exhaustive check should make condition true\n              qclass !== 'ibid', X`The protocol no longer supports ibid encoding: ${rawTree}.`);\n              assert.fail(X`unrecognized ${q(QCLASS)} ${q(qclass)}`, TypeError);\n            }\n        }\n      } else if (isArray(rawTree)) {\n        const result = [];\n        const {\n          length\n        } = rawTree;\n\n        for (let i = 0; i < length; i += 1) {\n          result[i] = fullRevive(rawTree[i]);\n        }\n\n        return result;\n      } else {\n        const result = {};\n\n        for (const name of ownKeys(rawTree)) {\n          assert.typeof(name, 'string', X`Property ${name} of ${rawTree} must be a string`);\n          result[name] = fullRevive(rawTree[name]);\n        }\n\n        return result;\n      }\n    }\n\n    return fullRevive;\n  };\n  /**\n   * @type {Unserialize<Slot>}\n   */\n\n\n  const unserialize = data => {\n    assert.typeof(data.body, 'string', X`unserialize() given non-capdata (.body is ${data.body}, not string)`);\n    assert(isArray(data.slots), X`unserialize() given non-capdata (.slots are not Array)`);\n    const rawTree = harden(JSON.parse(data.body));\n    const fullRevive = makeFullRevive(data.slots);\n    const result = harden(fullRevive(rawTree)); // See https://github.com/Agoric/agoric-sdk/issues/4337\n\n    assertPassable(result);\n    return result;\n  };\n\n  return harden({\n    serialize,\n    unserialize\n  });\n};","map":{"version":3,"names":["Nat","assertPassable","passStyleOf","getInterfaceOf","ErrorHelper","getErrorConstructor","makeTagged","isObject","getTag","assertPassableSymbol","nameForPassableSymbol","passableSymbolForName","ownKeys","Reflect","isArray","Array","getOwnPropertyDescriptors","defineProperties","is","fromEntries","freeze","Object","details","X","quote","q","assert","QCLASS","defaultValToSlotFn","x","defaultSlotToValFn","_","makeMarshal","convertValToSlot","convertSlotToVal","errorTagging","marshalName","errorIdNum","marshalSaveError","err","console","log","typeof","nextErrorId","serialize","root","slots","slotMap","Map","serializeSlot","val","iface","undefined","slotIndex","has","get","slot","length","push","set","harden","index","encodeError","errorId","note","message","name","encode","canBeValid","passStyle","Number","isNaN","Infinity","digits","String","qclassValue","rest","result","original","names","sort","map","tag","payload","fail","TypeError","encoded","body","JSON","stringify","makeFullRevive","valMap","unserializeSlot","fullRevive","rawTree","qclass","NaN","BigInt","Symbol","asyncIterator","EC","Error","errorName","error","restObj","i","unserialize","data","parse"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/marshal.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport { Nat } from '@endo/nat';\nimport { assertPassable, passStyleOf } from './passStyleOf.js';\n\nimport { getInterfaceOf } from './helpers/remotable.js';\nimport { ErrorHelper, getErrorConstructor } from './helpers/error.js';\nimport { makeTagged } from './makeTagged.js';\nimport { isObject, getTag } from './helpers/passStyle-helpers.js';\nimport {\n  assertPassableSymbol,\n  nameForPassableSymbol,\n  passableSymbolForName,\n} from './helpers/symbol.js';\n\n/** @typedef {import('./types.js').MakeMarshalOptions} MakeMarshalOptions */\n/** @template Slot @typedef {import('./types.js').ConvertSlotToVal<Slot>} ConvertSlotToVal */\n/** @template Slot @typedef {import('./types.js').ConvertValToSlot<Slot>} ConvertValToSlot */\n/** @template Slot @typedef {import('./types.js').Serialize<Slot>} Serialize */\n/** @template Slot @typedef {import('./types.js').Unserialize<Slot>} Unserialize */\n/** @typedef {import('./types.js').Passable} Passable */\n/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */\n/** @typedef {import('./types.js').Encoding} Encoding */\n\nconst { ownKeys } = Reflect;\nconst { isArray } = Array;\nconst {\n  getOwnPropertyDescriptors,\n  defineProperties,\n  is,\n  fromEntries,\n  freeze,\n} = Object;\nconst { details: X, quote: q } = assert;\n\n/**\n * Special property name that indicates an encoding that needs special\n * decoding.\n */\nconst QCLASS = '@qclass';\nexport { QCLASS };\n\n/** @type {ConvertValToSlot<any>} */\nconst defaultValToSlotFn = x => x;\n/** @type {ConvertSlotToVal<any>} */\nconst defaultSlotToValFn = (x, _) => x;\n\n/**\n * @template Slot\n * @param {ConvertValToSlot<Slot>} [convertValToSlot]\n * @param {ConvertSlotToVal<Slot>} [convertSlotToVal]\n * @param {MakeMarshalOptions} [options]\n */\nexport const makeMarshal = (\n  convertValToSlot = defaultValToSlotFn,\n  convertSlotToVal = defaultSlotToValFn,\n  {\n    errorTagging = 'on',\n    marshalName = 'anon-marshal',\n    // TODO Temporary hack.\n    // See https://github.com/Agoric/agoric-sdk/issues/2780\n    errorIdNum = 10000,\n    // We prefer that the caller instead log to somewhere hidden\n    // to be revealed when correlating with the received error.\n    marshalSaveError = err =>\n      console.log('Temporary logging of sent error', err),\n  } = {},\n) => {\n  assert.typeof(marshalName, 'string');\n  assert(\n    errorTagging === 'on' || errorTagging === 'off',\n    X`The errorTagging option can only be \"on\" or \"off\" ${errorTagging}`,\n  );\n  const nextErrorId = () => {\n    errorIdNum += 1;\n    return `error:${marshalName}#${errorIdNum}`;\n  };\n\n  /**\n   * @type {Serialize<Slot>}\n   */\n  const serialize = root => {\n    const slots = [];\n    // maps val (promise or remotable) to index of slots[]\n    const slotMap = new Map();\n\n    /**\n     * @param {Passable} val\n     * @param {InterfaceSpec=} iface\n     * @returns {Encoding}\n     */\n    function serializeSlot(val, iface = undefined) {\n      let slotIndex;\n      if (slotMap.has(val)) {\n        // TODO assert that it's the same iface as before\n        slotIndex = slotMap.get(val);\n        assert.typeof(slotIndex, 'number');\n        iface = undefined;\n      } else {\n        const slot = convertValToSlot(val);\n\n        slotIndex = slots.length;\n        slots.push(slot);\n        slotMap.set(val, slotIndex);\n      }\n\n      // TODO explore removing this special case\n      if (iface === undefined) {\n        return harden({\n          [QCLASS]: 'slot',\n          index: slotIndex,\n        });\n      }\n      return harden({\n        [QCLASS]: 'slot',\n        iface,\n        index: slotIndex,\n      });\n    }\n\n    /**\n     * Even if an Error is not actually passable, we'd rather send\n     * it anyway because the diagnostic info carried by the error\n     * is more valuable than diagnosing why the error isn't\n     * passable. See comments in ErrorHelper.\n     *\n     * @param {Error} err\n     * @returns {Encoding}\n     */\n    const encodeError = err => {\n      // Must encode `cause`, `errors`.\n      // nested non-passable errors must be ok from here.\n      if (errorTagging === 'on') {\n        // We deliberately do not share the stack, but it would\n        // be useful to log the stack locally so someone who has\n        // privileged access to the throwing Vat can correlate\n        // the problem with the remote Vat that gets this\n        // summary. If we do that, we could allocate some random\n        // identifier and include it in the message, to help\n        // with the correlation.\n        const errorId = nextErrorId();\n        assert.note(err, X`Sent as ${errorId}`);\n        marshalSaveError(err);\n        return harden({\n          [QCLASS]: 'error',\n          errorId,\n          message: `${err.message}`,\n          name: `${err.name}`,\n        });\n      } else {\n        return harden({\n          [QCLASS]: 'error',\n          message: `${err.message}`,\n          name: `${err.name}`,\n        });\n      }\n    };\n\n    /**\n     * Must encode `val` into plain JSON data *canonically*, such that\n     * `JSON.stringify(encode(v1)) === JSON.stringify(encode(v1))`\n     * For each copyRecord, we only accept string property names,\n     * not symbols. The encoded form the sort\n     * order of these names must be the same as their enumeration\n     * order, so a `JSON.stringify` of the encoded form agrees with\n     * a canonical-json stringify of the encoded form.\n     *\n     * @param {Passable} val\n     * @returns {Encoding}\n     */\n    const encode = val => {\n      if (ErrorHelper.canBeValid(val)) {\n        return encodeError(val);\n      }\n      // First we handle all primitives. Some can be represented directly as\n      // JSON, and some must be encoded as [QCLASS] composites.\n      const passStyle = passStyleOf(val);\n      switch (passStyle) {\n        case 'null': {\n          return null;\n        }\n        case 'undefined': {\n          return harden({ [QCLASS]: 'undefined' });\n        }\n        case 'string':\n        case 'boolean': {\n          return val;\n        }\n        case 'number': {\n          if (Number.isNaN(val)) {\n            return harden({ [QCLASS]: 'NaN' });\n          }\n          if (is(val, -0)) {\n            return 0;\n          }\n          if (val === Infinity) {\n            return harden({ [QCLASS]: 'Infinity' });\n          }\n          if (val === -Infinity) {\n            return harden({ [QCLASS]: '-Infinity' });\n          }\n          return val;\n        }\n        case 'bigint': {\n          return harden({\n            [QCLASS]: 'bigint',\n            digits: String(val),\n          });\n        }\n        case 'symbol': {\n          assertPassableSymbol(val);\n          const name = /** @type {string} */ (nameForPassableSymbol(val));\n          if (name === '@@asyncIterator') {\n            // Deprectated qclass. TODO make conditional\n            // on environment variable. Eventually remove, but only after\n            // confident that all supported receivers understand\n            // `[QCLASS]: 'symbol'`.\n            return harden({\n              [QCLASS]: '@@asyncIterator',\n            });\n          }\n          return harden({\n            [QCLASS]: 'symbol',\n            name,\n          });\n        }\n        case 'copyRecord': {\n          if (QCLASS in val) {\n            // Hilbert hotel\n            const { [QCLASS]: qclassValue, ...rest } = val;\n            if (ownKeys(rest).length === 0) {\n              /** @type {Encoding} */\n              const result = harden({\n                [QCLASS]: 'hilbert',\n                original: encode(qclassValue),\n              });\n              return result;\n            } else {\n              /** @type {Encoding} */\n              const result = harden({\n                [QCLASS]: 'hilbert',\n                original: encode(qclassValue),\n                // See https://github.com/Agoric/agoric-sdk/issues/4313\n                rest: encode(freeze(rest)),\n              });\n              return result;\n            }\n          }\n          // Currently copyRecord allows only string keys so this will\n          // work. If we allow sortable symbol keys, this will need to\n          // become more interesting.\n          const names = ownKeys(val).sort();\n          return fromEntries(names.map(name => [name, encode(val[name])]));\n        }\n        case 'copyArray': {\n          return val.map(encode);\n        }\n        case 'tagged': {\n          /** @type {Encoding} */\n          const result = harden({\n            [QCLASS]: 'tagged',\n            tag: getTag(val),\n            payload: encode(val.payload),\n          });\n          return result;\n        }\n        case 'remotable': {\n          const iface = getInterfaceOf(val);\n          // console.log(`serializeSlot: ${val}`);\n          return serializeSlot(val, iface);\n        }\n        case 'error': {\n          return encodeError(val);\n        }\n        case 'promise': {\n          // console.log(`serializeSlot: ${val}`);\n          return serializeSlot(val);\n        }\n        default: {\n          assert.fail(X`unrecognized passStyle ${q(passStyle)}`, TypeError);\n        }\n      }\n    };\n\n    const encoded = encode(root);\n\n    return harden({\n      body: JSON.stringify(encoded),\n      slots,\n    });\n  };\n\n  const makeFullRevive = slots => {\n    /** @type {Map<number, Passable>} */\n    const valMap = new Map();\n\n    function unserializeSlot(index, iface) {\n      if (valMap.has(index)) {\n        return valMap.get(index);\n      }\n      // TODO SECURITY HAZARD: must enfoce that remotable vs promise\n      // is according to the encoded string.\n      const slot = slots[Number(Nat(index))];\n      const val = convertSlotToVal(slot, iface);\n      valMap.set(index, val);\n      return val;\n    }\n\n    /**\n     * We stay close to the algorithm at\n     * https://tc39.github.io/ecma262/#sec-json.parse , where\n     * fullRevive(harden(JSON.parse(str))) is like JSON.parse(str, revive))\n     * for a similar reviver. But with the following differences:\n     *\n     * Rather than pass a reviver to JSON.parse, we first call a plain\n     * (one argument) JSON.parse to get rawTree, and then post-process\n     * the rawTree with fullRevive. The kind of revive function\n     * handled by JSON.parse only does one step in post-order, with\n     * JSON.parse doing the recursion. By contrast, fullParse does its\n     * own recursion in the same pre-order in which the replacer visited them.\n     *\n     * In order to break cycles, the potentially cyclic objects are\n     * not frozen during the recursion. Rather, the whole graph is\n     * hardened before being returned. Error objects are not\n     * potentially recursive, and so may be harmlessly hardened when\n     * they are produced.\n     *\n     * fullRevive can produce properties whose value is undefined,\n     * which a JSON.parse on a reviver cannot do. If a reviver returns\n     * undefined to JSON.parse, JSON.parse will delete the property\n     * instead.\n     *\n     * fullRevive creates and returns a new graph, rather than\n     * modifying the original tree in place.\n     *\n     * fullRevive may rely on rawTree being the result of a plain call\n     * to JSON.parse. However, it *cannot* rely on it having been\n     * produced by JSON.stringify on the replacer above, i.e., it\n     * cannot rely on it being a valid marshalled\n     * representation. Rather, fullRevive must validate that.\n     *\n     * @param {Encoding} rawTree must be hardened\n     */\n    function fullRevive(rawTree) {\n      if (!isObject(rawTree)) {\n        // primitives pass through\n        return rawTree;\n      }\n      // Assertions of the above to narrow the type.\n      assert.typeof(rawTree, 'object');\n      assert(rawTree !== null);\n      if (QCLASS in rawTree) {\n        const qclass = rawTree[QCLASS];\n        assert.typeof(\n          qclass,\n          'string',\n          X`invalid qclass typeof ${q(typeof qclass)}`,\n        );\n        assert(!isArray(rawTree));\n        // Switching on `rawTree[QCLASS]` (or anything less direct, like\n        // `qclass`) does not discriminate rawTree in typescript@4.2.3 and\n        // earlier.\n        switch (rawTree['@qclass']) {\n          // Encoding of primitives not handled by JSON\n          case 'undefined': {\n            return undefined;\n          }\n          case 'NaN': {\n            return NaN;\n          }\n          case 'Infinity': {\n            return Infinity;\n          }\n          case '-Infinity': {\n            return -Infinity;\n          }\n          case 'bigint': {\n            const { digits } = rawTree;\n            assert.typeof(\n              digits,\n              'string',\n              X`invalid digits typeof ${q(typeof digits)}`,\n            );\n            return BigInt(digits);\n          }\n          case '@@asyncIterator': {\n            // Deprectated qclass. TODO make conditional\n            // on environment variable. Eventually remove, but after confident\n            // that there are no more supported senders.\n            return Symbol.asyncIterator;\n          }\n          case 'symbol': {\n            const { name } = rawTree;\n            return passableSymbolForName(name);\n          }\n\n          case 'tagged': {\n            const { tag, payload } = rawTree;\n            return makeTagged(tag, fullRevive(payload));\n          }\n\n          case 'error': {\n            // Must decode `cause` and `errors` properties\n            const { name, message, errorId } = rawTree;\n            assert.typeof(\n              name,\n              'string',\n              X`invalid error name typeof ${q(typeof name)}`,\n            );\n            assert.typeof(\n              message,\n              'string',\n              X`invalid error message typeof ${q(typeof message)}`,\n            );\n            const EC = getErrorConstructor(`${name}`) || Error;\n            // errorId is a late addition so be tolerant of its absence.\n            const errorName =\n              errorId === undefined\n                ? `Remote${EC.name}`\n                : `Remote${EC.name}(${errorId})`;\n            // Due to a defect in the SES type definition, the next line is\n            // fails a type check.\n            // Pending https://github.com/endojs/endo/issues/977\n            // @ts-ignore-next-line\n            const error = assert.error(`${message}`, EC, { errorName });\n            return error;\n          }\n\n          case 'slot': {\n            const { index, iface } = rawTree;\n            const val = unserializeSlot(index, iface);\n            return val;\n          }\n\n          case 'hilbert': {\n            const { original, rest } = rawTree;\n            assert(\n              'original' in rawTree,\n              X`Invalid Hilbert Hotel encoding ${rawTree}`,\n            );\n            // Don't harden since we're not done mutating it\n            const result = { [QCLASS]: fullRevive(original) };\n            if ('rest' in rawTree) {\n              assert(\n                rest !== undefined,\n                X`Rest encoding must not be undefined`,\n              );\n              const restObj = fullRevive(rest);\n              // TODO really should assert that `passStyleOf(rest)` is\n              // `'copyRecord'` but we'd have to harden it and it is too\n              // early to do that.\n              assert(\n                !(QCLASS in restObj),\n                X`Rest must not contain its own definition of ${q(QCLASS)}`,\n              );\n              defineProperties(result, getOwnPropertyDescriptors(restObj));\n            }\n            return result;\n          }\n\n          default: {\n            assert(\n              // @ts-expect-error exhaustive check should make condition true\n              qclass !== 'ibid',\n              X`The protocol no longer supports ibid encoding: ${rawTree}.`,\n            );\n            assert.fail(X`unrecognized ${q(QCLASS)} ${q(qclass)}`, TypeError);\n          }\n        }\n      } else if (isArray(rawTree)) {\n        const result = [];\n        const { length } = rawTree;\n        for (let i = 0; i < length; i += 1) {\n          result[i] = fullRevive(rawTree[i]);\n        }\n        return result;\n      } else {\n        const result = {};\n        for (const name of ownKeys(rawTree)) {\n          assert.typeof(\n            name,\n            'string',\n            X`Property ${name} of ${rawTree} must be a string`,\n          );\n          result[name] = fullRevive(rawTree[name]);\n        }\n        return result;\n      }\n    }\n    return fullRevive;\n  };\n\n  /**\n   * @type {Unserialize<Slot>}\n   */\n  const unserialize = data => {\n    assert.typeof(\n      data.body,\n      'string',\n      X`unserialize() given non-capdata (.body is ${data.body}, not string)`,\n    );\n    assert(\n      isArray(data.slots),\n      X`unserialize() given non-capdata (.slots are not Array)`,\n    );\n    const rawTree = harden(JSON.parse(data.body));\n    const fullRevive = makeFullRevive(data.slots);\n    const result = harden(fullRevive(rawTree));\n    // See https://github.com/Agoric/agoric-sdk/issues/4337\n    assertPassable(result);\n    return result;\n  };\n\n  return harden({\n    serialize,\n    unserialize,\n  });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}