{"ast":null,"code":"import { assert } from './error/assert.js';\nimport { getDeferredExports } from './module-proxy.js';\nimport { ReferenceError, SyntaxError, TypeError, arrayForEach, arrayIncludes, arrayPush, arraySome, arraySort, create, defineProperty, entries, freeze, isArray, keys, mapGet, weakmapGet, reflectHas } from './commons.js';\nimport { compartmentEvaluate } from './compartment-evaluate.js';\nconst {\n  quote: q\n} = assert;\nexport const makeThirdPartyModuleInstance = (compartmentPrivateFields, staticModuleRecord, compartment, moduleAliases, moduleSpecifier, resolvedImports) => {\n  const {\n    exportsProxy,\n    proxiedExports,\n    activate\n  } = getDeferredExports(compartment, weakmapGet(compartmentPrivateFields, compartment), moduleAliases, moduleSpecifier);\n  const notifiers = create(null);\n\n  if (staticModuleRecord.exports) {\n    if (!isArray(staticModuleRecord.exports) || arraySome(staticModuleRecord.exports, name => typeof name !== 'string')) {\n      throw new TypeError(`SES third-party static module record \"exports\" property must be an array of strings for module ${moduleSpecifier}`);\n    }\n\n    arrayForEach(staticModuleRecord.exports, name => {\n      let value = proxiedExports[name];\n      const updaters = [];\n\n      const get = () => value;\n\n      const set = newValue => {\n        value = newValue;\n\n        for (const updater of updaters) {\n          updater(newValue);\n        }\n      };\n\n      defineProperty(proxiedExports, name, {\n        get,\n        set,\n        enumerable: true,\n        configurable: false\n      });\n\n      notifiers[name] = update => {\n        arrayPush(updaters, update);\n        update(value);\n      };\n    }); // This is enough to support import * from cjs - the '*' field doesn't need to be in exports nor proxiedExports because import will only ever access it via notifiers\n\n    notifiers['*'] = update => {\n      update(proxiedExports);\n    };\n  }\n\n  const localState = {\n    activated: false\n  };\n  return freeze({\n    notifiers,\n    exportsProxy,\n\n    execute() {\n      if (reflectHas(localState, 'errorFromExecute')) {\n        throw localState.errorFromExecute;\n      }\n\n      if (!localState.activated) {\n        activate();\n        localState.activated = true;\n\n        try {\n          // eslint-disable-next-line @endo/no-polymorphic-call\n          staticModuleRecord.execute(proxiedExports, compartment, resolvedImports);\n        } catch (err) {\n          localState.errorFromExecute = err;\n          throw err;\n        }\n      }\n    }\n\n  });\n}; // `makeModuleInstance` takes a module's compartment record, the live import\n// namespace, and a global object; and produces a module instance.\n// The module instance carries the proxied module exports namespace (the\n// \"exports\"), notifiers to update the module's internal import namespace, and\n// an idempotent execute function.\n// The module exports namespace is a proxy to the proxied exports namespace\n// that the execution of the module instance populates.\n\nexport const makeModuleInstance = (privateFields, moduleAliases, moduleRecord, importedInstances) => {\n  const {\n    compartment,\n    moduleSpecifier,\n    staticModuleRecord\n  } = moduleRecord;\n  const {\n    reexports: exportAlls = [],\n    __syncModuleProgram__: functorSource,\n    __fixedExportMap__: fixedExportMap = {},\n    __liveExportMap__: liveExportMap = {}\n  } = staticModuleRecord;\n  const compartmentFields = weakmapGet(privateFields, compartment);\n  const {\n    __shimTransforms__\n  } = compartmentFields;\n  const {\n    exportsProxy,\n    proxiedExports,\n    activate\n  } = getDeferredExports(compartment, compartmentFields, moduleAliases, moduleSpecifier); // {_exportName_: getter} module exports namespace\n  // object (eventually proxied).\n\n  const exportsProps = create(null); // {_localName_: accessor} proxy traps for globalLexicals and live bindings.\n  // The globalLexicals object is frozen and the corresponding properties of\n  // localLexicals must be immutable, so we copy the descriptors.\n\n  const localLexicals = create(null); // {_localName_: init(initValue) -> initValue} used by the\n  // rewritten code to initialize exported fixed bindings.\n\n  const onceVar = create(null); // {_localName_: update(newValue)} used by the rewritten code to\n  // both initialize and update live bindings.\n\n  const liveVar = create(null); // {_localName_: [{get, set, notify}]} used to merge all the export updaters.\n\n  const localGetNotify = create(null); // {[importName: string]: notify(update(newValue))} Used by code that imports\n  // one of this module's exports, so that their update function will\n  // be notified when this binding is initialized or updated.\n\n  const notifiers = create(null);\n  arrayForEach(entries(fixedExportMap), _ref => {\n    let [fixedExportName, [localName]] = _ref;\n    let fixedGetNotify = localGetNotify[localName];\n\n    if (!fixedGetNotify) {\n      // fixed binding state\n      let value;\n      let tdz = true;\n      let optUpdaters = []; // tdz sensitive getter\n\n      const get = () => {\n        if (tdz) {\n          throw new ReferenceError(`binding ${q(localName)} not yet initialized`);\n        }\n\n        return value;\n      }; // leave tdz once\n\n\n      const init = freeze(initValue => {\n        // init with initValue of a declared const binding, and return\n        // it.\n        if (!tdz) {\n          throw new TypeError(`Internal: binding ${q(localName)} already initialized`);\n        }\n\n        value = initValue;\n        const updaters = optUpdaters;\n        optUpdaters = null;\n        tdz = false;\n\n        for (const updater of updaters) {\n          updater(initValue);\n        }\n\n        return initValue;\n      }); // If still tdz, register update for notification later.\n      // Otherwise, update now.\n\n      const notify = updater => {\n        if (updater === init) {\n          // Prevent recursion.\n          return;\n        }\n\n        if (tdz) {\n          arrayPush(optUpdaters, updater);\n        } else {\n          updater(value);\n        }\n      }; // Need these for additional exports of the local variable.\n\n\n      fixedGetNotify = {\n        get,\n        notify\n      };\n      localGetNotify[localName] = fixedGetNotify;\n      onceVar[localName] = init;\n    }\n\n    exportsProps[fixedExportName] = {\n      get: fixedGetNotify.get,\n      set: undefined,\n      enumerable: true,\n      configurable: false\n    };\n    notifiers[fixedExportName] = fixedGetNotify.notify;\n  });\n  arrayForEach(entries(liveExportMap), _ref2 => {\n    let [liveExportName, [localName, setProxyTrap]] = _ref2;\n    let liveGetNotify = localGetNotify[localName];\n\n    if (!liveGetNotify) {\n      // live binding state\n      let value;\n      let tdz = true;\n      const updaters = []; // tdz sensitive getter\n\n      const get = () => {\n        if (tdz) {\n          throw new ReferenceError(`binding ${q(liveExportName)} not yet initialized`);\n        }\n\n        return value;\n      }; // This must be usable locally for the translation of initializing\n      // a declared local live binding variable.\n      //\n      // For reexported variable, this is also an update function to\n      // register for notification with the downstream import, which we\n      // must assume to be live. Thus, it can be called independent of\n      // tdz but always leaves tdz. Such reexporting creates a tree of\n      // bindings. This lets the tree be hooked up even if the imported\n      // module instance isn't initialized yet, as may happen in cycles.\n\n\n      const update = freeze(newValue => {\n        value = newValue;\n        tdz = false;\n\n        for (const updater of updaters) {\n          updater(newValue);\n        }\n      }); // tdz sensitive setter\n\n      const set = newValue => {\n        if (tdz) {\n          throw new ReferenceError(`binding ${q(localName)} not yet initialized`);\n        }\n\n        value = newValue;\n\n        for (const updater of updaters) {\n          updater(newValue);\n        }\n      }; // Always register the updater function.\n      // If not in tdz, also update now.\n\n\n      const notify = updater => {\n        if (updater === update) {\n          // Prevent recursion.\n          return;\n        }\n\n        arrayPush(updaters, updater);\n\n        if (!tdz) {\n          updater(value);\n        }\n      };\n\n      liveGetNotify = {\n        get,\n        notify\n      };\n      localGetNotify[localName] = liveGetNotify;\n\n      if (setProxyTrap) {\n        defineProperty(localLexicals, localName, {\n          get,\n          set,\n          enumerable: true,\n          configurable: false\n        });\n      }\n\n      liveVar[localName] = update;\n    }\n\n    exportsProps[liveExportName] = {\n      get: liveGetNotify.get,\n      set: undefined,\n      enumerable: true,\n      configurable: false\n    };\n    notifiers[liveExportName] = liveGetNotify.notify;\n  });\n\n  const notifyStar = update => {\n    update(proxiedExports);\n  };\n\n  notifiers['*'] = notifyStar; // Per the calling convention for the moduleFunctor generated from\n  // an ESM, the `imports` function gets called once up front\n  // to populate or arrange the population of imports and reexports.\n  // The generated code produces an `updateRecord`: the means for\n  // the linker to update the imports and exports of the module.\n  // The updateRecord must conform to moduleAnalysis.imports\n  // updateRecord = Map<specifier, importUpdaters>\n  // importUpdaters = Map<importName, [update(newValue)*]>\n\n  function imports(updateRecord) {\n    // By the time imports is called, the importedInstances should already be\n    // initialized with module instances that satisfy\n    // imports.\n    // importedInstances = Map[_specifier_, { notifiers, module, execute }]\n    // notifiers = { [importName: string]: notify(update(newValue))}\n    // export * cannot export default.\n    const candidateAll = create(null);\n    candidateAll.default = false;\n\n    for (const [specifier, importUpdaters] of updateRecord) {\n      const instance = mapGet(importedInstances, specifier); // The module instance object is an internal literal, does not bind this,\n      // and never revealed outside the SES shim.\n      // There are two instantiation sites for instances and they are both in\n      // this module.\n      // eslint-disable-next-line @endo/no-polymorphic-call\n\n      instance.execute(); // bottom up cycle tolerant\n\n      const {\n        notifiers: importNotifiers\n      } = instance;\n\n      for (const [importName, updaters] of importUpdaters) {\n        const importNotify = importNotifiers[importName];\n\n        if (!importNotify) {\n          throw SyntaxError(`The requested module '${specifier}' does not provide an export named '${importName}'`);\n        }\n\n        for (const updater of updaters) {\n          importNotify(updater);\n        }\n      }\n\n      if (arrayIncludes(exportAlls, specifier)) {\n        // Make all these imports candidates.\n        for (const [importName, importNotify] of entries(importNotifiers)) {\n          if (candidateAll[importName] === undefined) {\n            candidateAll[importName] = importNotify;\n          } else {\n            // Already a candidate: remove ambiguity.\n            candidateAll[importName] = false;\n          }\n        }\n      }\n    }\n\n    for (const [importName, notify] of entries(candidateAll)) {\n      if (!notifiers[importName] && notify !== false) {\n        notifiers[importName] = notify; // exported live binding state\n\n        let value;\n\n        const update = newValue => value = newValue;\n\n        notify(update);\n        exportsProps[importName] = {\n          get() {\n            return value;\n          },\n\n          set: undefined,\n          enumerable: true,\n          configurable: false\n        };\n      }\n    } // Sort the module exports namespace as per spec.\n    // The module exports namespace will be wrapped in a module namespace\n    // exports proxy which will serve as a \"module exports namespace exotic\n    // object\".\n    // Sorting properties is not generally reliable because some properties may\n    // be symbols, and symbols do not have an inherent relative order, but\n    // since all properties of the exports namespace must be keyed by a string\n    // and the string must correspond to a valid identifier, sorting these\n    // properties works for this specific case.\n\n\n    arrayForEach(arraySort(keys(exportsProps)), k => defineProperty(proxiedExports, k, exportsProps[k]));\n    freeze(proxiedExports);\n    activate();\n  }\n\n  let optFunctor = compartmentEvaluate(compartmentFields, functorSource, {\n    globalObject: compartment.globalThis,\n    transforms: __shimTransforms__,\n    __moduleShimLexicals__: localLexicals\n  });\n  let didThrow = false;\n  let thrownError;\n\n  function execute() {\n    if (optFunctor) {\n      // uninitialized\n      const functor = optFunctor;\n      optFunctor = null; // initializing - call with `this` of `undefined`.\n\n      try {\n        functor(freeze({\n          imports: freeze(imports),\n          onceVar: freeze(onceVar),\n          liveVar: freeze(liveVar)\n        }));\n      } catch (e) {\n        didThrow = true;\n        thrownError = e;\n      } // initialized\n\n    }\n\n    if (didThrow) {\n      throw thrownError;\n    }\n  }\n\n  return freeze({\n    notifiers,\n    exportsProxy,\n    execute\n  });\n};","map":{"version":3,"names":["assert","getDeferredExports","ReferenceError","SyntaxError","TypeError","arrayForEach","arrayIncludes","arrayPush","arraySome","arraySort","create","defineProperty","entries","freeze","isArray","keys","mapGet","weakmapGet","reflectHas","compartmentEvaluate","quote","q","makeThirdPartyModuleInstance","compartmentPrivateFields","staticModuleRecord","compartment","moduleAliases","moduleSpecifier","resolvedImports","exportsProxy","proxiedExports","activate","notifiers","exports","name","value","updaters","get","set","newValue","updater","enumerable","configurable","update","localState","activated","execute","errorFromExecute","err","makeModuleInstance","privateFields","moduleRecord","importedInstances","reexports","exportAlls","__syncModuleProgram__","functorSource","__fixedExportMap__","fixedExportMap","__liveExportMap__","liveExportMap","compartmentFields","__shimTransforms__","exportsProps","localLexicals","onceVar","liveVar","localGetNotify","fixedExportName","localName","fixedGetNotify","tdz","optUpdaters","init","initValue","notify","undefined","liveExportName","setProxyTrap","liveGetNotify","notifyStar","imports","updateRecord","candidateAll","default","specifier","importUpdaters","instance","importNotifiers","importName","importNotify","k","optFunctor","globalObject","globalThis","transforms","__moduleShimLexicals__","didThrow","thrownError","functor","e"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/module-instance.js"],"sourcesContent":["import { assert } from './error/assert.js';\nimport { getDeferredExports } from './module-proxy.js';\nimport {\n  ReferenceError,\n  SyntaxError,\n  TypeError,\n  arrayForEach,\n  arrayIncludes,\n  arrayPush,\n  arraySome,\n  arraySort,\n  create,\n  defineProperty,\n  entries,\n  freeze,\n  isArray,\n  keys,\n  mapGet,\n  weakmapGet,\n  reflectHas,\n} from './commons.js';\nimport { compartmentEvaluate } from './compartment-evaluate.js';\n\nconst { quote: q } = assert;\n\nexport const makeThirdPartyModuleInstance = (\n  compartmentPrivateFields,\n  staticModuleRecord,\n  compartment,\n  moduleAliases,\n  moduleSpecifier,\n  resolvedImports,\n) => {\n  const { exportsProxy, proxiedExports, activate } = getDeferredExports(\n    compartment,\n    weakmapGet(compartmentPrivateFields, compartment),\n    moduleAliases,\n    moduleSpecifier,\n  );\n\n  const notifiers = create(null);\n\n  if (staticModuleRecord.exports) {\n    if (\n      !isArray(staticModuleRecord.exports) ||\n      arraySome(staticModuleRecord.exports, name => typeof name !== 'string')\n    ) {\n      throw new TypeError(\n        `SES third-party static module record \"exports\" property must be an array of strings for module ${moduleSpecifier}`,\n      );\n    }\n    arrayForEach(staticModuleRecord.exports, name => {\n      let value = proxiedExports[name];\n      const updaters = [];\n\n      const get = () => value;\n\n      const set = newValue => {\n        value = newValue;\n        for (const updater of updaters) {\n          updater(newValue);\n        }\n      };\n\n      defineProperty(proxiedExports, name, {\n        get,\n        set,\n        enumerable: true,\n        configurable: false,\n      });\n\n      notifiers[name] = update => {\n        arrayPush(updaters, update);\n        update(value);\n      };\n    });\n    // This is enough to support import * from cjs - the '*' field doesn't need to be in exports nor proxiedExports because import will only ever access it via notifiers\n    notifiers['*'] = update => {\n      update(proxiedExports);\n    };\n  }\n\n  const localState = {\n    activated: false,\n  };\n  return freeze({\n    notifiers,\n    exportsProxy,\n    execute() {\n      if (reflectHas(localState, 'errorFromExecute')) {\n        throw localState.errorFromExecute;\n      }\n      if (!localState.activated) {\n        activate();\n        localState.activated = true;\n        try {\n          // eslint-disable-next-line @endo/no-polymorphic-call\n          staticModuleRecord.execute(\n            proxiedExports,\n            compartment,\n            resolvedImports,\n          );\n        } catch (err) {\n          localState.errorFromExecute = err;\n          throw err;\n        }\n      }\n    },\n  });\n};\n\n// `makeModuleInstance` takes a module's compartment record, the live import\n// namespace, and a global object; and produces a module instance.\n// The module instance carries the proxied module exports namespace (the\n// \"exports\"), notifiers to update the module's internal import namespace, and\n// an idempotent execute function.\n// The module exports namespace is a proxy to the proxied exports namespace\n// that the execution of the module instance populates.\nexport const makeModuleInstance = (\n  privateFields,\n  moduleAliases,\n  moduleRecord,\n  importedInstances,\n) => {\n  const { compartment, moduleSpecifier, staticModuleRecord } = moduleRecord;\n  const {\n    reexports: exportAlls = [],\n    __syncModuleProgram__: functorSource,\n    __fixedExportMap__: fixedExportMap = {},\n    __liveExportMap__: liveExportMap = {},\n  } = staticModuleRecord;\n\n  const compartmentFields = weakmapGet(privateFields, compartment);\n\n  const { __shimTransforms__ } = compartmentFields;\n\n  const { exportsProxy, proxiedExports, activate } = getDeferredExports(\n    compartment,\n    compartmentFields,\n    moduleAliases,\n    moduleSpecifier,\n  );\n\n  // {_exportName_: getter} module exports namespace\n  // object (eventually proxied).\n  const exportsProps = create(null);\n\n  // {_localName_: accessor} proxy traps for globalLexicals and live bindings.\n  // The globalLexicals object is frozen and the corresponding properties of\n  // localLexicals must be immutable, so we copy the descriptors.\n  const localLexicals = create(null);\n\n  // {_localName_: init(initValue) -> initValue} used by the\n  // rewritten code to initialize exported fixed bindings.\n  const onceVar = create(null);\n\n  // {_localName_: update(newValue)} used by the rewritten code to\n  // both initialize and update live bindings.\n  const liveVar = create(null);\n\n  // {_localName_: [{get, set, notify}]} used to merge all the export updaters.\n  const localGetNotify = create(null);\n\n  // {[importName: string]: notify(update(newValue))} Used by code that imports\n  // one of this module's exports, so that their update function will\n  // be notified when this binding is initialized or updated.\n  const notifiers = create(null);\n\n  arrayForEach(entries(fixedExportMap), ([fixedExportName, [localName]]) => {\n    let fixedGetNotify = localGetNotify[localName];\n    if (!fixedGetNotify) {\n      // fixed binding state\n      let value;\n      let tdz = true;\n      let optUpdaters = [];\n\n      // tdz sensitive getter\n      const get = () => {\n        if (tdz) {\n          throw new ReferenceError(\n            `binding ${q(localName)} not yet initialized`,\n          );\n        }\n        return value;\n      };\n\n      // leave tdz once\n      const init = freeze(initValue => {\n        // init with initValue of a declared const binding, and return\n        // it.\n        if (!tdz) {\n          throw new TypeError(\n            `Internal: binding ${q(localName)} already initialized`,\n          );\n        }\n        value = initValue;\n        const updaters = optUpdaters;\n        optUpdaters = null;\n        tdz = false;\n        for (const updater of updaters) {\n          updater(initValue);\n        }\n        return initValue;\n      });\n\n      // If still tdz, register update for notification later.\n      // Otherwise, update now.\n      const notify = updater => {\n        if (updater === init) {\n          // Prevent recursion.\n          return;\n        }\n        if (tdz) {\n          arrayPush(optUpdaters, updater);\n        } else {\n          updater(value);\n        }\n      };\n\n      // Need these for additional exports of the local variable.\n      fixedGetNotify = {\n        get,\n        notify,\n      };\n      localGetNotify[localName] = fixedGetNotify;\n      onceVar[localName] = init;\n    }\n\n    exportsProps[fixedExportName] = {\n      get: fixedGetNotify.get,\n      set: undefined,\n      enumerable: true,\n      configurable: false,\n    };\n\n    notifiers[fixedExportName] = fixedGetNotify.notify;\n  });\n\n  arrayForEach(\n    entries(liveExportMap),\n    ([liveExportName, [localName, setProxyTrap]]) => {\n      let liveGetNotify = localGetNotify[localName];\n      if (!liveGetNotify) {\n        // live binding state\n        let value;\n        let tdz = true;\n        const updaters = [];\n\n        // tdz sensitive getter\n        const get = () => {\n          if (tdz) {\n            throw new ReferenceError(\n              `binding ${q(liveExportName)} not yet initialized`,\n            );\n          }\n          return value;\n        };\n\n        // This must be usable locally for the translation of initializing\n        // a declared local live binding variable.\n        //\n        // For reexported variable, this is also an update function to\n        // register for notification with the downstream import, which we\n        // must assume to be live. Thus, it can be called independent of\n        // tdz but always leaves tdz. Such reexporting creates a tree of\n        // bindings. This lets the tree be hooked up even if the imported\n        // module instance isn't initialized yet, as may happen in cycles.\n        const update = freeze(newValue => {\n          value = newValue;\n          tdz = false;\n          for (const updater of updaters) {\n            updater(newValue);\n          }\n        });\n\n        // tdz sensitive setter\n        const set = newValue => {\n          if (tdz) {\n            throw new ReferenceError(\n              `binding ${q(localName)} not yet initialized`,\n            );\n          }\n          value = newValue;\n          for (const updater of updaters) {\n            updater(newValue);\n          }\n        };\n\n        // Always register the updater function.\n        // If not in tdz, also update now.\n        const notify = updater => {\n          if (updater === update) {\n            // Prevent recursion.\n            return;\n          }\n          arrayPush(updaters, updater);\n          if (!tdz) {\n            updater(value);\n          }\n        };\n\n        liveGetNotify = {\n          get,\n          notify,\n        };\n\n        localGetNotify[localName] = liveGetNotify;\n        if (setProxyTrap) {\n          defineProperty(localLexicals, localName, {\n            get,\n            set,\n            enumerable: true,\n            configurable: false,\n          });\n        }\n        liveVar[localName] = update;\n      }\n\n      exportsProps[liveExportName] = {\n        get: liveGetNotify.get,\n        set: undefined,\n        enumerable: true,\n        configurable: false,\n      };\n\n      notifiers[liveExportName] = liveGetNotify.notify;\n    },\n  );\n\n  const notifyStar = update => {\n    update(proxiedExports);\n  };\n  notifiers['*'] = notifyStar;\n\n  // Per the calling convention for the moduleFunctor generated from\n  // an ESM, the `imports` function gets called once up front\n  // to populate or arrange the population of imports and reexports.\n  // The generated code produces an `updateRecord`: the means for\n  // the linker to update the imports and exports of the module.\n  // The updateRecord must conform to moduleAnalysis.imports\n  // updateRecord = Map<specifier, importUpdaters>\n  // importUpdaters = Map<importName, [update(newValue)*]>\n  function imports(updateRecord) {\n    // By the time imports is called, the importedInstances should already be\n    // initialized with module instances that satisfy\n    // imports.\n    // importedInstances = Map[_specifier_, { notifiers, module, execute }]\n    // notifiers = { [importName: string]: notify(update(newValue))}\n\n    // export * cannot export default.\n    const candidateAll = create(null);\n    candidateAll.default = false;\n    for (const [specifier, importUpdaters] of updateRecord) {\n      const instance = mapGet(importedInstances, specifier);\n      // The module instance object is an internal literal, does not bind this,\n      // and never revealed outside the SES shim.\n      // There are two instantiation sites for instances and they are both in\n      // this module.\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      instance.execute(); // bottom up cycle tolerant\n      const { notifiers: importNotifiers } = instance;\n      for (const [importName, updaters] of importUpdaters) {\n        const importNotify = importNotifiers[importName];\n        if (!importNotify) {\n          throw SyntaxError(\n            `The requested module '${specifier}' does not provide an export named '${importName}'`,\n          );\n        }\n        for (const updater of updaters) {\n          importNotify(updater);\n        }\n      }\n      if (arrayIncludes(exportAlls, specifier)) {\n        // Make all these imports candidates.\n        for (const [importName, importNotify] of entries(importNotifiers)) {\n          if (candidateAll[importName] === undefined) {\n            candidateAll[importName] = importNotify;\n          } else {\n            // Already a candidate: remove ambiguity.\n            candidateAll[importName] = false;\n          }\n        }\n      }\n    }\n\n    for (const [importName, notify] of entries(candidateAll)) {\n      if (!notifiers[importName] && notify !== false) {\n        notifiers[importName] = notify;\n\n        // exported live binding state\n        let value;\n        const update = newValue => (value = newValue);\n        notify(update);\n        exportsProps[importName] = {\n          get() {\n            return value;\n          },\n          set: undefined,\n          enumerable: true,\n          configurable: false,\n        };\n      }\n    }\n\n    // Sort the module exports namespace as per spec.\n    // The module exports namespace will be wrapped in a module namespace\n    // exports proxy which will serve as a \"module exports namespace exotic\n    // object\".\n    // Sorting properties is not generally reliable because some properties may\n    // be symbols, and symbols do not have an inherent relative order, but\n    // since all properties of the exports namespace must be keyed by a string\n    // and the string must correspond to a valid identifier, sorting these\n    // properties works for this specific case.\n    arrayForEach(arraySort(keys(exportsProps)), k =>\n      defineProperty(proxiedExports, k, exportsProps[k]),\n    );\n\n    freeze(proxiedExports);\n    activate();\n  }\n\n  let optFunctor = compartmentEvaluate(compartmentFields, functorSource, {\n    globalObject: compartment.globalThis,\n    transforms: __shimTransforms__,\n    __moduleShimLexicals__: localLexicals,\n  });\n  let didThrow = false;\n  let thrownError;\n  function execute() {\n    if (optFunctor) {\n      // uninitialized\n      const functor = optFunctor;\n      optFunctor = null;\n      // initializing - call with `this` of `undefined`.\n      try {\n        functor(\n          freeze({\n            imports: freeze(imports),\n            onceVar: freeze(onceVar),\n            liveVar: freeze(liveVar),\n          }),\n        );\n      } catch (e) {\n        didThrow = true;\n        thrownError = e;\n      }\n      // initialized\n    }\n    if (didThrow) {\n      throw thrownError;\n    }\n  }\n\n  return freeze({\n    notifiers,\n    exportsProxy,\n    execute,\n  });\n};\n"],"mappings":"AAAA,SAASA,MAAT,QAAuB,mBAAvB;AACA,SAASC,kBAAT,QAAmC,mBAAnC;AACA,SACEC,cADF,EAEEC,WAFF,EAGEC,SAHF,EAIEC,YAJF,EAKEC,aALF,EAMEC,SANF,EAOEC,SAPF,EAQEC,SARF,EASEC,MATF,EAUEC,cAVF,EAWEC,OAXF,EAYEC,MAZF,EAaEC,OAbF,EAcEC,IAdF,EAeEC,MAfF,EAgBEC,UAhBF,EAiBEC,UAjBF,QAkBO,cAlBP;AAmBA,SAASC,mBAAT,QAAoC,2BAApC;AAEA,MAAM;EAAEC,KAAK,EAAEC;AAAT,IAAerB,MAArB;AAEA,OAAO,MAAMsB,4BAA4B,GAAG,CAC1CC,wBAD0C,EAE1CC,kBAF0C,EAG1CC,WAH0C,EAI1CC,aAJ0C,EAK1CC,eAL0C,EAM1CC,eAN0C,KAOvC;EACH,MAAM;IAAEC,YAAF;IAAgBC,cAAhB;IAAgCC;EAAhC,IAA6C9B,kBAAkB,CACnEwB,WADmE,EAEnER,UAAU,CAACM,wBAAD,EAA2BE,WAA3B,CAFyD,EAGnEC,aAHmE,EAInEC,eAJmE,CAArE;EAOA,MAAMK,SAAS,GAAGtB,MAAM,CAAC,IAAD,CAAxB;;EAEA,IAAIc,kBAAkB,CAACS,OAAvB,EAAgC;IAC9B,IACE,CAACnB,OAAO,CAACU,kBAAkB,CAACS,OAApB,CAAR,IACAzB,SAAS,CAACgB,kBAAkB,CAACS,OAApB,EAA6BC,IAAI,IAAI,OAAOA,IAAP,KAAgB,QAArD,CAFX,EAGE;MACA,MAAM,IAAI9B,SAAJ,CACH,kGAAiGuB,eAAgB,EAD9G,CAAN;IAGD;;IACDtB,YAAY,CAACmB,kBAAkB,CAACS,OAApB,EAA6BC,IAAI,IAAI;MAC/C,IAAIC,KAAK,GAAGL,cAAc,CAACI,IAAD,CAA1B;MACA,MAAME,QAAQ,GAAG,EAAjB;;MAEA,MAAMC,GAAG,GAAG,MAAMF,KAAlB;;MAEA,MAAMG,GAAG,GAAGC,QAAQ,IAAI;QACtBJ,KAAK,GAAGI,QAAR;;QACA,KAAK,MAAMC,OAAX,IAAsBJ,QAAtB,EAAgC;UAC9BI,OAAO,CAACD,QAAD,CAAP;QACD;MACF,CALD;;MAOA5B,cAAc,CAACmB,cAAD,EAAiBI,IAAjB,EAAuB;QACnCG,GADmC;QAEnCC,GAFmC;QAGnCG,UAAU,EAAE,IAHuB;QAInCC,YAAY,EAAE;MAJqB,CAAvB,CAAd;;MAOAV,SAAS,CAACE,IAAD,CAAT,GAAkBS,MAAM,IAAI;QAC1BpC,SAAS,CAAC6B,QAAD,EAAWO,MAAX,CAAT;QACAA,MAAM,CAACR,KAAD,CAAN;MACD,CAHD;IAID,CAxBW,CAAZ,CAT8B,CAkC9B;;IACAH,SAAS,CAAC,GAAD,CAAT,GAAiBW,MAAM,IAAI;MACzBA,MAAM,CAACb,cAAD,CAAN;IACD,CAFD;EAGD;;EAED,MAAMc,UAAU,GAAG;IACjBC,SAAS,EAAE;EADM,CAAnB;EAGA,OAAOhC,MAAM,CAAC;IACZmB,SADY;IAEZH,YAFY;;IAGZiB,OAAO,GAAG;MACR,IAAI5B,UAAU,CAAC0B,UAAD,EAAa,kBAAb,CAAd,EAAgD;QAC9C,MAAMA,UAAU,CAACG,gBAAjB;MACD;;MACD,IAAI,CAACH,UAAU,CAACC,SAAhB,EAA2B;QACzBd,QAAQ;QACRa,UAAU,CAACC,SAAX,GAAuB,IAAvB;;QACA,IAAI;UACF;UACArB,kBAAkB,CAACsB,OAAnB,CACEhB,cADF,EAEEL,WAFF,EAGEG,eAHF;QAKD,CAPD,CAOE,OAAOoB,GAAP,EAAY;UACZJ,UAAU,CAACG,gBAAX,GAA8BC,GAA9B;UACA,MAAMA,GAAN;QACD;MACF;IACF;;EAtBW,CAAD,CAAb;AAwBD,CApFM,C,CAsFP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,kBAAkB,GAAG,CAChCC,aADgC,EAEhCxB,aAFgC,EAGhCyB,YAHgC,EAIhCC,iBAJgC,KAK7B;EACH,MAAM;IAAE3B,WAAF;IAAeE,eAAf;IAAgCH;EAAhC,IAAuD2B,YAA7D;EACA,MAAM;IACJE,SAAS,EAAEC,UAAU,GAAG,EADpB;IAEJC,qBAAqB,EAAEC,aAFnB;IAGJC,kBAAkB,EAAEC,cAAc,GAAG,EAHjC;IAIJC,iBAAiB,EAAEC,aAAa,GAAG;EAJ/B,IAKFpC,kBALJ;EAOA,MAAMqC,iBAAiB,GAAG5C,UAAU,CAACiC,aAAD,EAAgBzB,WAAhB,CAApC;EAEA,MAAM;IAAEqC;EAAF,IAAyBD,iBAA/B;EAEA,MAAM;IAAEhC,YAAF;IAAgBC,cAAhB;IAAgCC;EAAhC,IAA6C9B,kBAAkB,CACnEwB,WADmE,EAEnEoC,iBAFmE,EAGnEnC,aAHmE,EAInEC,eAJmE,CAArE,CAbG,CAoBH;EACA;;EACA,MAAMoC,YAAY,GAAGrD,MAAM,CAAC,IAAD,CAA3B,CAtBG,CAwBH;EACA;EACA;;EACA,MAAMsD,aAAa,GAAGtD,MAAM,CAAC,IAAD,CAA5B,CA3BG,CA6BH;EACA;;EACA,MAAMuD,OAAO,GAAGvD,MAAM,CAAC,IAAD,CAAtB,CA/BG,CAiCH;EACA;;EACA,MAAMwD,OAAO,GAAGxD,MAAM,CAAC,IAAD,CAAtB,CAnCG,CAqCH;;EACA,MAAMyD,cAAc,GAAGzD,MAAM,CAAC,IAAD,CAA7B,CAtCG,CAwCH;EACA;EACA;;EACA,MAAMsB,SAAS,GAAGtB,MAAM,CAAC,IAAD,CAAxB;EAEAL,YAAY,CAACO,OAAO,CAAC8C,cAAD,CAAR,EAA0B,QAAoC;IAAA,IAAnC,CAACU,eAAD,EAAkB,CAACC,SAAD,CAAlB,CAAmC;IACxE,IAAIC,cAAc,GAAGH,cAAc,CAACE,SAAD,CAAnC;;IACA,IAAI,CAACC,cAAL,EAAqB;MACnB;MACA,IAAInC,KAAJ;MACA,IAAIoC,GAAG,GAAG,IAAV;MACA,IAAIC,WAAW,GAAG,EAAlB,CAJmB,CAMnB;;MACA,MAAMnC,GAAG,GAAG,MAAM;QAChB,IAAIkC,GAAJ,EAAS;UACP,MAAM,IAAIrE,cAAJ,CACH,WAAUmB,CAAC,CAACgD,SAAD,CAAY,sBADpB,CAAN;QAGD;;QACD,OAAOlC,KAAP;MACD,CAPD,CAPmB,CAgBnB;;;MACA,MAAMsC,IAAI,GAAG5D,MAAM,CAAC6D,SAAS,IAAI;QAC/B;QACA;QACA,IAAI,CAACH,GAAL,EAAU;UACR,MAAM,IAAInE,SAAJ,CACH,qBAAoBiB,CAAC,CAACgD,SAAD,CAAY,sBAD9B,CAAN;QAGD;;QACDlC,KAAK,GAAGuC,SAAR;QACA,MAAMtC,QAAQ,GAAGoC,WAAjB;QACAA,WAAW,GAAG,IAAd;QACAD,GAAG,GAAG,KAAN;;QACA,KAAK,MAAM/B,OAAX,IAAsBJ,QAAtB,EAAgC;UAC9BI,OAAO,CAACkC,SAAD,CAAP;QACD;;QACD,OAAOA,SAAP;MACD,CAhBkB,CAAnB,CAjBmB,CAmCnB;MACA;;MACA,MAAMC,MAAM,GAAGnC,OAAO,IAAI;QACxB,IAAIA,OAAO,KAAKiC,IAAhB,EAAsB;UACpB;UACA;QACD;;QACD,IAAIF,GAAJ,EAAS;UACPhE,SAAS,CAACiE,WAAD,EAAchC,OAAd,CAAT;QACD,CAFD,MAEO;UACLA,OAAO,CAACL,KAAD,CAAP;QACD;MACF,CAVD,CArCmB,CAiDnB;;;MACAmC,cAAc,GAAG;QACfjC,GADe;QAEfsC;MAFe,CAAjB;MAIAR,cAAc,CAACE,SAAD,CAAd,GAA4BC,cAA5B;MACAL,OAAO,CAACI,SAAD,CAAP,GAAqBI,IAArB;IACD;;IAEDV,YAAY,CAACK,eAAD,CAAZ,GAAgC;MAC9B/B,GAAG,EAAEiC,cAAc,CAACjC,GADU;MAE9BC,GAAG,EAAEsC,SAFyB;MAG9BnC,UAAU,EAAE,IAHkB;MAI9BC,YAAY,EAAE;IAJgB,CAAhC;IAOAV,SAAS,CAACoC,eAAD,CAAT,GAA6BE,cAAc,CAACK,MAA5C;EACD,CApEW,CAAZ;EAsEAtE,YAAY,CACVO,OAAO,CAACgD,aAAD,CADG,EAEV,SAAiD;IAAA,IAAhD,CAACiB,cAAD,EAAiB,CAACR,SAAD,EAAYS,YAAZ,CAAjB,CAAgD;IAC/C,IAAIC,aAAa,GAAGZ,cAAc,CAACE,SAAD,CAAlC;;IACA,IAAI,CAACU,aAAL,EAAoB;MAClB;MACA,IAAI5C,KAAJ;MACA,IAAIoC,GAAG,GAAG,IAAV;MACA,MAAMnC,QAAQ,GAAG,EAAjB,CAJkB,CAMlB;;MACA,MAAMC,GAAG,GAAG,MAAM;QAChB,IAAIkC,GAAJ,EAAS;UACP,MAAM,IAAIrE,cAAJ,CACH,WAAUmB,CAAC,CAACwD,cAAD,CAAiB,sBADzB,CAAN;QAGD;;QACD,OAAO1C,KAAP;MACD,CAPD,CAPkB,CAgBlB;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;;MACA,MAAMQ,MAAM,GAAG9B,MAAM,CAAC0B,QAAQ,IAAI;QAChCJ,KAAK,GAAGI,QAAR;QACAgC,GAAG,GAAG,KAAN;;QACA,KAAK,MAAM/B,OAAX,IAAsBJ,QAAtB,EAAgC;UAC9BI,OAAO,CAACD,QAAD,CAAP;QACD;MACF,CANoB,CAArB,CAzBkB,CAiClB;;MACA,MAAMD,GAAG,GAAGC,QAAQ,IAAI;QACtB,IAAIgC,GAAJ,EAAS;UACP,MAAM,IAAIrE,cAAJ,CACH,WAAUmB,CAAC,CAACgD,SAAD,CAAY,sBADpB,CAAN;QAGD;;QACDlC,KAAK,GAAGI,QAAR;;QACA,KAAK,MAAMC,OAAX,IAAsBJ,QAAtB,EAAgC;UAC9BI,OAAO,CAACD,QAAD,CAAP;QACD;MACF,CAVD,CAlCkB,CA8ClB;MACA;;;MACA,MAAMoC,MAAM,GAAGnC,OAAO,IAAI;QACxB,IAAIA,OAAO,KAAKG,MAAhB,EAAwB;UACtB;UACA;QACD;;QACDpC,SAAS,CAAC6B,QAAD,EAAWI,OAAX,CAAT;;QACA,IAAI,CAAC+B,GAAL,EAAU;UACR/B,OAAO,CAACL,KAAD,CAAP;QACD;MACF,CATD;;MAWA4C,aAAa,GAAG;QACd1C,GADc;QAEdsC;MAFc,CAAhB;MAKAR,cAAc,CAACE,SAAD,CAAd,GAA4BU,aAA5B;;MACA,IAAID,YAAJ,EAAkB;QAChBnE,cAAc,CAACqD,aAAD,EAAgBK,SAAhB,EAA2B;UACvChC,GADuC;UAEvCC,GAFuC;UAGvCG,UAAU,EAAE,IAH2B;UAIvCC,YAAY,EAAE;QAJyB,CAA3B,CAAd;MAMD;;MACDwB,OAAO,CAACG,SAAD,CAAP,GAAqB1B,MAArB;IACD;;IAEDoB,YAAY,CAACc,cAAD,CAAZ,GAA+B;MAC7BxC,GAAG,EAAE0C,aAAa,CAAC1C,GADU;MAE7BC,GAAG,EAAEsC,SAFwB;MAG7BnC,UAAU,EAAE,IAHiB;MAI7BC,YAAY,EAAE;IAJe,CAA/B;IAOAV,SAAS,CAAC6C,cAAD,CAAT,GAA4BE,aAAa,CAACJ,MAA1C;EACD,CAxFS,CAAZ;;EA2FA,MAAMK,UAAU,GAAGrC,MAAM,IAAI;IAC3BA,MAAM,CAACb,cAAD,CAAN;EACD,CAFD;;EAGAE,SAAS,CAAC,GAAD,CAAT,GAAiBgD,UAAjB,CAjNG,CAmNH;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,SAASC,OAAT,CAAiBC,YAAjB,EAA+B;IAC7B;IACA;IACA;IACA;IACA;IAEA;IACA,MAAMC,YAAY,GAAGzE,MAAM,CAAC,IAAD,CAA3B;IACAyE,YAAY,CAACC,OAAb,GAAuB,KAAvB;;IACA,KAAK,MAAM,CAACC,SAAD,EAAYC,cAAZ,CAAX,IAA0CJ,YAA1C,EAAwD;MACtD,MAAMK,QAAQ,GAAGvE,MAAM,CAACoC,iBAAD,EAAoBiC,SAApB,CAAvB,CADsD,CAEtD;MACA;MACA;MACA;MACA;;MACAE,QAAQ,CAACzC,OAAT,GAPsD,CAOlC;;MACpB,MAAM;QAAEd,SAAS,EAAEwD;MAAb,IAAiCD,QAAvC;;MACA,KAAK,MAAM,CAACE,UAAD,EAAarD,QAAb,CAAX,IAAqCkD,cAArC,EAAqD;QACnD,MAAMI,YAAY,GAAGF,eAAe,CAACC,UAAD,CAApC;;QACA,IAAI,CAACC,YAAL,EAAmB;UACjB,MAAMvF,WAAW,CACd,yBAAwBkF,SAAU,uCAAsCI,UAAW,GADrE,CAAjB;QAGD;;QACD,KAAK,MAAMjD,OAAX,IAAsBJ,QAAtB,EAAgC;UAC9BsD,YAAY,CAAClD,OAAD,CAAZ;QACD;MACF;;MACD,IAAIlC,aAAa,CAACgD,UAAD,EAAa+B,SAAb,CAAjB,EAA0C;QACxC;QACA,KAAK,MAAM,CAACI,UAAD,EAAaC,YAAb,CAAX,IAAyC9E,OAAO,CAAC4E,eAAD,CAAhD,EAAmE;UACjE,IAAIL,YAAY,CAACM,UAAD,CAAZ,KAA6Bb,SAAjC,EAA4C;YAC1CO,YAAY,CAACM,UAAD,CAAZ,GAA2BC,YAA3B;UACD,CAFD,MAEO;YACL;YACAP,YAAY,CAACM,UAAD,CAAZ,GAA2B,KAA3B;UACD;QACF;MACF;IACF;;IAED,KAAK,MAAM,CAACA,UAAD,EAAad,MAAb,CAAX,IAAmC/D,OAAO,CAACuE,YAAD,CAA1C,EAA0D;MACxD,IAAI,CAACnD,SAAS,CAACyD,UAAD,CAAV,IAA0Bd,MAAM,KAAK,KAAzC,EAAgD;QAC9C3C,SAAS,CAACyD,UAAD,CAAT,GAAwBd,MAAxB,CAD8C,CAG9C;;QACA,IAAIxC,KAAJ;;QACA,MAAMQ,MAAM,GAAGJ,QAAQ,IAAKJ,KAAK,GAAGI,QAApC;;QACAoC,MAAM,CAAChC,MAAD,CAAN;QACAoB,YAAY,CAAC0B,UAAD,CAAZ,GAA2B;UACzBpD,GAAG,GAAG;YACJ,OAAOF,KAAP;UACD,CAHwB;;UAIzBG,GAAG,EAAEsC,SAJoB;UAKzBnC,UAAU,EAAE,IALa;UAMzBC,YAAY,EAAE;QANW,CAA3B;MAQD;IACF,CA5D4B,CA8D7B;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IACArC,YAAY,CAACI,SAAS,CAACM,IAAI,CAACgD,YAAD,CAAL,CAAV,EAAgC4B,CAAC,IAC3ChF,cAAc,CAACmB,cAAD,EAAiB6D,CAAjB,EAAoB5B,YAAY,CAAC4B,CAAD,CAAhC,CADJ,CAAZ;IAIA9E,MAAM,CAACiB,cAAD,CAAN;IACAC,QAAQ;EACT;;EAED,IAAI6D,UAAU,GAAGzE,mBAAmB,CAAC0C,iBAAD,EAAoBL,aAApB,EAAmC;IACrEqC,YAAY,EAAEpE,WAAW,CAACqE,UAD2C;IAErEC,UAAU,EAAEjC,kBAFyD;IAGrEkC,sBAAsB,EAAEhC;EAH6C,CAAnC,CAApC;EAKA,IAAIiC,QAAQ,GAAG,KAAf;EACA,IAAIC,WAAJ;;EACA,SAASpD,OAAT,GAAmB;IACjB,IAAI8C,UAAJ,EAAgB;MACd;MACA,MAAMO,OAAO,GAAGP,UAAhB;MACAA,UAAU,GAAG,IAAb,CAHc,CAId;;MACA,IAAI;QACFO,OAAO,CACLtF,MAAM,CAAC;UACLoE,OAAO,EAAEpE,MAAM,CAACoE,OAAD,CADV;UAELhB,OAAO,EAAEpD,MAAM,CAACoD,OAAD,CAFV;UAGLC,OAAO,EAAErD,MAAM,CAACqD,OAAD;QAHV,CAAD,CADD,CAAP;MAOD,CARD,CAQE,OAAOkC,CAAP,EAAU;QACVH,QAAQ,GAAG,IAAX;QACAC,WAAW,GAAGE,CAAd;MACD,CAhBa,CAiBd;;IACD;;IACD,IAAIH,QAAJ,EAAc;MACZ,MAAMC,WAAN;IACD;EACF;;EAED,OAAOrF,MAAM,CAAC;IACZmB,SADY;IAEZH,YAFY;IAGZiB;EAHY,CAAD,CAAb;AAKD,CApVM"},"metadata":{},"sourceType":"module"}