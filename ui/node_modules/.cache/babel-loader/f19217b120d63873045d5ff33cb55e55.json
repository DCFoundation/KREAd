{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nconst {\n  details: X\n} = assert; // This is a pathological minimum, but exercised by the unit test.\n\nexport const MIN_DATA_BUFFER_LENGTH = 1; // Calculate how big the transfer buffer needs to be.\n\nexport const TRANSFER_OVERHEAD_LENGTH = BigUint64Array.BYTES_PER_ELEMENT + Int32Array.BYTES_PER_ELEMENT;\nexport const MIN_TRANSFER_BUFFER_LENGTH = MIN_DATA_BUFFER_LENGTH + TRANSFER_OVERHEAD_LENGTH; // These are bit flags for the status element of the transfer buffer.\n\nconst STATUS_WAITING = 1;\nconst STATUS_FLAG_DONE = 2;\nconst STATUS_FLAG_REJECT = 4;\n/**\n * Return a status buffer, length buffer, and data buffer backed by transferBuffer.\n *\n * @param {SharedArrayBuffer} transferBuffer the backing buffer\n */\n\nconst splitTransferBuffer = transferBuffer => {\n  assert(transferBuffer.byteLength >= MIN_TRANSFER_BUFFER_LENGTH, X`Transfer buffer of ${transferBuffer.byteLength} bytes is smaller than MIN_TRANSFER_BUFFER_LENGTH ${MIN_TRANSFER_BUFFER_LENGTH}`);\n  const lenbuf = new BigUint64Array(transferBuffer, 0, 1); // The documentation says that this needs to be an Int32Array for use with\n  // Atomics.notify:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/notify#syntax\n\n  const statusbuf = new Int32Array(transferBuffer, lenbuf.byteLength, 1);\n  const overheadLength = lenbuf.byteLength + statusbuf.byteLength;\n  assert.equal(overheadLength, TRANSFER_OVERHEAD_LENGTH, X`Internal error; actual overhead ${overheadLength} of bytes is not TRANSFER_OVERHEAD_LENGTH ${TRANSFER_OVERHEAD_LENGTH}`);\n  const databuf = new Uint8Array(transferBuffer, overheadLength);\n  assert(databuf.byteLength >= MIN_DATA_BUFFER_LENGTH, X`Transfer buffer of size ${transferBuffer.byteLength} only supports ${databuf.byteLength} data bytes; need at least ${MIN_DATA_BUFFER_LENGTH}`);\n  return {\n    statusbuf,\n    lenbuf,\n    databuf\n  };\n};\n/**\n * Create a trapHost that can be paired with makeAtomicsTrapGuest.\n *\n * This host encodes the transfer buffer and returns it in consecutive slices\n * when the guest iterates over it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapHost}\n */\n\n\nexport const makeAtomicsTrapHost = transferBuffer => {\n  const {\n    statusbuf,\n    lenbuf,\n    databuf\n  } = splitTransferBuffer(transferBuffer);\n  const te = new TextEncoder();\n  return async function* trapHost(_ref) {\n    let [isReject, serialized] = _ref;\n    // Get the complete encoded message buffer.\n    const json = JSON.stringify(serialized);\n    const encoded = te.encode(json); // Send chunks in the data transfer buffer.\n\n    let i = 0;\n    let done = false;\n\n    while (!done) {\n      // Copy the next slice of the encoded arry to the data buffer.\n      const subenc = encoded.subarray(i, i + databuf.length);\n      databuf.set(subenc); // Save the length of the remaining data.\n\n      const remaining = BigInt(encoded.length - i);\n      lenbuf[0] = remaining; // Calculate the next slice, and whether this is the last one.\n\n      i += subenc.length;\n      done = i >= encoded.length; // Find bitflags to represent the rejected and finished state.\n\n      const rejectFlag = isReject ? STATUS_FLAG_REJECT : 0;\n      const doneFlag = done ? STATUS_FLAG_DONE : 0; // Notify our guest for this data buffer.\n      // eslint-disable-next-line no-bitwise\n\n      statusbuf[0] = rejectFlag | doneFlag;\n      Atomics.notify(statusbuf, 0, +Infinity);\n\n      if (!done) {\n        // Wait until the next call to `it.next()`.  If the guest calls\n        // `it.return()` or `it.throw()`, then this yield will return or throw,\n        // terminating the generator function early.\n        yield;\n      }\n    }\n  };\n};\n/**\n * Create a trapGuest that can be paired with makeAtomicsTrapHost.\n *\n * This guest iterates through the consecutive slices of the JSON-encoded data,\n * then returns it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapGuest}\n */\n\nexport const makeAtomicsTrapGuest = transferBuffer => {\n  const {\n    statusbuf,\n    lenbuf,\n    databuf\n  } = splitTransferBuffer(transferBuffer);\n  return _ref2 => {\n    let {\n      startTrap\n    } = _ref2;\n    // Start by sending the trap call to the host.\n    const it = startTrap();\n    /** @type {Uint8Array | undefined} */\n\n    let encoded;\n    let i = 0;\n    let done = false;\n\n    while (!done) {\n      // Tell that we are ready for another buffer.\n      statusbuf[0] = STATUS_WAITING;\n      const {\n        done: itDone\n      } = it.next();\n      assert(!itDone, X`Internal error; it.next() returned done=${itDone}`); // Wait for the host to wake us.\n\n      Atomics.wait(statusbuf, 0, STATUS_WAITING); // Determine whether this is the last buffer.\n      // eslint-disable-next-line no-bitwise\n\n      done = (statusbuf[0] & STATUS_FLAG_DONE) !== 0; // Accumulate the encoded buffer.\n\n      const remaining = Number(lenbuf[0]);\n      const datalen = Math.min(remaining, databuf.byteLength);\n\n      if (!encoded) {\n        if (done) {\n          // Special case: we are done on first try, so we don't need to copy\n          // anything.\n          encoded = databuf.subarray(0, datalen);\n          break;\n        } // Allocate our buffer for the remaining data.\n\n\n        encoded = new Uint8Array(remaining);\n      } // Copy the next buffer.\n\n\n      encoded.set(databuf.subarray(0, datalen), i);\n      i += datalen;\n    } // This throw is harmless if the host iterator has already finished, and\n    // if not finished, captp will correctly raise an error.\n    //\n    // TODO: It would be nice to use an error type, but captp is just too\n    // noisy with spurious \"Temporary logging of sent error\" messages.\n    // it.throw(assert.error(X`Trap host has not finished`));\n\n\n    it.throw(null); // eslint-disable-next-line no-bitwise\n\n    const isReject = !!(statusbuf[0] & STATUS_FLAG_REJECT); // Decode the accumulated encoded buffer.\n\n    const td = new TextDecoder('utf-8');\n    const json = td.decode(encoded); // Parse the JSON data into marshalled form.\n\n    const serialized = JSON.parse(json);\n    return [isReject, serialized];\n  };\n};","map":{"version":3,"names":["details","X","assert","MIN_DATA_BUFFER_LENGTH","TRANSFER_OVERHEAD_LENGTH","BigUint64Array","BYTES_PER_ELEMENT","Int32Array","MIN_TRANSFER_BUFFER_LENGTH","STATUS_WAITING","STATUS_FLAG_DONE","STATUS_FLAG_REJECT","splitTransferBuffer","transferBuffer","byteLength","lenbuf","statusbuf","overheadLength","equal","databuf","Uint8Array","makeAtomicsTrapHost","te","TextEncoder","trapHost","isReject","serialized","json","JSON","stringify","encoded","encode","i","done","subenc","subarray","length","set","remaining","BigInt","rejectFlag","doneFlag","Atomics","notify","Infinity","makeAtomicsTrapGuest","startTrap","it","itDone","next","wait","Number","datalen","Math","min","throw","td","TextDecoder","decode","parse"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/captp/src/atomics.js"],"sourcesContent":["// @ts-check\n/// <reference types=\"ses\"/>\n\nconst { details: X } = assert;\n\n// This is a pathological minimum, but exercised by the unit test.\nexport const MIN_DATA_BUFFER_LENGTH = 1;\n\n// Calculate how big the transfer buffer needs to be.\nexport const TRANSFER_OVERHEAD_LENGTH =\n  BigUint64Array.BYTES_PER_ELEMENT + Int32Array.BYTES_PER_ELEMENT;\nexport const MIN_TRANSFER_BUFFER_LENGTH =\n  MIN_DATA_BUFFER_LENGTH + TRANSFER_OVERHEAD_LENGTH;\n\n// These are bit flags for the status element of the transfer buffer.\nconst STATUS_WAITING = 1;\nconst STATUS_FLAG_DONE = 2;\nconst STATUS_FLAG_REJECT = 4;\n\n/**\n * Return a status buffer, length buffer, and data buffer backed by transferBuffer.\n *\n * @param {SharedArrayBuffer} transferBuffer the backing buffer\n */\nconst splitTransferBuffer = transferBuffer => {\n  assert(\n    transferBuffer.byteLength >= MIN_TRANSFER_BUFFER_LENGTH,\n    X`Transfer buffer of ${transferBuffer.byteLength} bytes is smaller than MIN_TRANSFER_BUFFER_LENGTH ${MIN_TRANSFER_BUFFER_LENGTH}`,\n  );\n  const lenbuf = new BigUint64Array(transferBuffer, 0, 1);\n\n  // The documentation says that this needs to be an Int32Array for use with\n  // Atomics.notify:\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Atomics/notify#syntax\n  const statusbuf = new Int32Array(transferBuffer, lenbuf.byteLength, 1);\n  const overheadLength = lenbuf.byteLength + statusbuf.byteLength;\n  assert.equal(\n    overheadLength,\n    TRANSFER_OVERHEAD_LENGTH,\n    X`Internal error; actual overhead ${overheadLength} of bytes is not TRANSFER_OVERHEAD_LENGTH ${TRANSFER_OVERHEAD_LENGTH}`,\n  );\n  const databuf = new Uint8Array(transferBuffer, overheadLength);\n  assert(\n    databuf.byteLength >= MIN_DATA_BUFFER_LENGTH,\n    X`Transfer buffer of size ${transferBuffer.byteLength} only supports ${databuf.byteLength} data bytes; need at least ${MIN_DATA_BUFFER_LENGTH}`,\n  );\n  return { statusbuf, lenbuf, databuf };\n};\n\n/**\n * Create a trapHost that can be paired with makeAtomicsTrapGuest.\n *\n * This host encodes the transfer buffer and returns it in consecutive slices\n * when the guest iterates over it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapHost}\n */\nexport const makeAtomicsTrapHost = transferBuffer => {\n  const { statusbuf, lenbuf, databuf } = splitTransferBuffer(transferBuffer);\n\n  const te = new TextEncoder();\n\n  return async function* trapHost([isReject, serialized]) {\n    // Get the complete encoded message buffer.\n    const json = JSON.stringify(serialized);\n    const encoded = te.encode(json);\n\n    // Send chunks in the data transfer buffer.\n    let i = 0;\n    let done = false;\n    while (!done) {\n      // Copy the next slice of the encoded arry to the data buffer.\n      const subenc = encoded.subarray(i, i + databuf.length);\n      databuf.set(subenc);\n\n      // Save the length of the remaining data.\n      const remaining = BigInt(encoded.length - i);\n      lenbuf[0] = remaining;\n\n      // Calculate the next slice, and whether this is the last one.\n      i += subenc.length;\n      done = i >= encoded.length;\n\n      // Find bitflags to represent the rejected and finished state.\n      const rejectFlag = isReject ? STATUS_FLAG_REJECT : 0;\n      const doneFlag = done ? STATUS_FLAG_DONE : 0;\n\n      // Notify our guest for this data buffer.\n\n      // eslint-disable-next-line no-bitwise\n      statusbuf[0] = rejectFlag | doneFlag;\n      Atomics.notify(statusbuf, 0, +Infinity);\n\n      if (!done) {\n        // Wait until the next call to `it.next()`.  If the guest calls\n        // `it.return()` or `it.throw()`, then this yield will return or throw,\n        // terminating the generator function early.\n        yield;\n      }\n    }\n  };\n};\n\n/**\n * Create a trapGuest that can be paired with makeAtomicsTrapHost.\n *\n * This guest iterates through the consecutive slices of the JSON-encoded data,\n * then returns it.\n *\n * @param {SharedArrayBuffer} transferBuffer\n * @returns {TrapGuest}\n */\nexport const makeAtomicsTrapGuest = transferBuffer => {\n  const { statusbuf, lenbuf, databuf } = splitTransferBuffer(transferBuffer);\n\n  return ({ startTrap }) => {\n    // Start by sending the trap call to the host.\n    const it = startTrap();\n\n    /** @type {Uint8Array | undefined} */\n    let encoded;\n    let i = 0;\n    let done = false;\n    while (!done) {\n      // Tell that we are ready for another buffer.\n      statusbuf[0] = STATUS_WAITING;\n      const { done: itDone } = it.next();\n      assert(!itDone, X`Internal error; it.next() returned done=${itDone}`);\n\n      // Wait for the host to wake us.\n      Atomics.wait(statusbuf, 0, STATUS_WAITING);\n\n      // Determine whether this is the last buffer.\n      // eslint-disable-next-line no-bitwise\n      done = (statusbuf[0] & STATUS_FLAG_DONE) !== 0;\n\n      // Accumulate the encoded buffer.\n      const remaining = Number(lenbuf[0]);\n      const datalen = Math.min(remaining, databuf.byteLength);\n      if (!encoded) {\n        if (done) {\n          // Special case: we are done on first try, so we don't need to copy\n          // anything.\n          encoded = databuf.subarray(0, datalen);\n          break;\n        }\n        // Allocate our buffer for the remaining data.\n        encoded = new Uint8Array(remaining);\n      }\n\n      // Copy the next buffer.\n      encoded.set(databuf.subarray(0, datalen), i);\n      i += datalen;\n    }\n\n    // This throw is harmless if the host iterator has already finished, and\n    // if not finished, captp will correctly raise an error.\n    //\n    // TODO: It would be nice to use an error type, but captp is just too\n    // noisy with spurious \"Temporary logging of sent error\" messages.\n    // it.throw(assert.error(X`Trap host has not finished`));\n    it.throw(null);\n\n    // eslint-disable-next-line no-bitwise\n    const isReject = !!(statusbuf[0] & STATUS_FLAG_REJECT);\n\n    // Decode the accumulated encoded buffer.\n    const td = new TextDecoder('utf-8');\n    const json = td.decode(encoded);\n\n    // Parse the JSON data into marshalled form.\n    const serialized = JSON.parse(json);\n    return [isReject, serialized];\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}