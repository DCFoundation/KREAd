{"ast":null,"code":"/* global globalThis */\n// @ts-check\n/// <reference types=\"ses\"/>\n\n/** @type {PromiseConstructor} */\nconst BestPipelinablePromise = globalThis.HandledPromise || Promise;\n/**\n * @template T\n * @typedef {Object} PromiseKit A reified Promise\n * @property {(value: ERef<T>) => void} resolve\n * @property {(reason: any) => void} reject\n * @property {Promise<T>} promise\n */\n\n/**\n * PromiseRecord is deprecated in favor of PromiseKit.\n *\n * @template T\n * @typedef {PromiseKit<T>} PromiseRecord\n */\n\n/**\n * @template T\n * @typedef {T | PromiseLike<T>} ERef\n * A reference of some kind for to an object of type T. It may be a direct\n * reference to a local T. It may be a local presence for a remote T. It may\n * be a promise for a local or remote T. Or it may even be a thenable\n * (a promise-like non-promise with a \"then\" method) for a T.\n */\n\n/**\n * Needed to prevent type errors where functions are detected to be undefined.\n */\n\nconst NOOP_INITIALIZER = harden(() => {});\n/**\n * makePromiseKit() builds a Promise object, and returns a record\n * containing the promise itself, as well as separate facets for resolving\n * and rejecting it.\n *\n * @template T\n * @returns {PromiseKit<T>}\n */\n\nexport function makePromiseKit() {\n  /** @type {(value: ERef<T>) => void} */\n  let resolve = NOOP_INITIALIZER;\n  /** @type {(reason: unknown) => void} */\n\n  let reject = NOOP_INITIALIZER;\n  /** @type {Promise<T>} */\n\n  const promise = new BestPipelinablePromise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return harden({\n    promise,\n    resolve,\n    reject\n  });\n}\nharden(makePromiseKit);\n/**\n * Determine if the argument is a Promise.\n *\n * @param {any} maybePromise The value to examine\n * @returns {maybePromise is Promise} Whether it is a promise\n */\n\nexport function isPromise(maybePromise) {\n  return Promise.resolve(maybePromise) === maybePromise;\n}\nharden(isPromise);","map":{"version":3,"names":["BestPipelinablePromise","globalThis","HandledPromise","Promise","NOOP_INITIALIZER","harden","makePromiseKit","resolve","reject","promise","res","rej","isPromise","maybePromise"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/promise-kit/index.js"],"sourcesContent":["/* global globalThis */\n// @ts-check\n\n/// <reference types=\"ses\"/>\n\n/** @type {PromiseConstructor} */\nconst BestPipelinablePromise = globalThis.HandledPromise || Promise;\n\n/**\n * @template T\n * @typedef {Object} PromiseKit A reified Promise\n * @property {(value: ERef<T>) => void} resolve\n * @property {(reason: any) => void} reject\n * @property {Promise<T>} promise\n */\n\n/**\n * PromiseRecord is deprecated in favor of PromiseKit.\n *\n * @template T\n * @typedef {PromiseKit<T>} PromiseRecord\n */\n\n/**\n * @template T\n * @typedef {T | PromiseLike<T>} ERef\n * A reference of some kind for to an object of type T. It may be a direct\n * reference to a local T. It may be a local presence for a remote T. It may\n * be a promise for a local or remote T. Or it may even be a thenable\n * (a promise-like non-promise with a \"then\" method) for a T.\n */\n\n/**\n * Needed to prevent type errors where functions are detected to be undefined.\n */\nconst NOOP_INITIALIZER = harden(() => {});\n\n/**\n * makePromiseKit() builds a Promise object, and returns a record\n * containing the promise itself, as well as separate facets for resolving\n * and rejecting it.\n *\n * @template T\n * @returns {PromiseKit<T>}\n */\nexport function makePromiseKit() {\n  /** @type {(value: ERef<T>) => void} */\n  let resolve = NOOP_INITIALIZER;\n  /** @type {(reason: unknown) => void} */\n  let reject = NOOP_INITIALIZER;\n\n  /** @type {Promise<T>} */\n  const promise = new BestPipelinablePromise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return harden({ promise, resolve, reject });\n}\nharden(makePromiseKit);\n\n/**\n * Determine if the argument is a Promise.\n *\n * @param {any} maybePromise The value to examine\n * @returns {maybePromise is Promise} Whether it is a promise\n */\nexport function isPromise(maybePromise) {\n  return Promise.resolve(maybePromise) === maybePromise;\n}\nharden(isPromise);\n"],"mappings":"AAAA;AACA;AAEA;;AAEA;AACA,MAAMA,sBAAsB,GAAGC,UAAU,CAACC,cAAX,IAA6BC,OAA5D;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAGC,MAAM,CAAC,MAAM,CAAE,CAAT,CAA/B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASC,cAAT,GAA0B;EAC/B;EACA,IAAIC,OAAO,GAAGH,gBAAd;EACA;;EACA,IAAII,MAAM,GAAGJ,gBAAb;EAEA;;EACA,MAAMK,OAAO,GAAG,IAAIT,sBAAJ,CAA2B,CAACU,GAAD,EAAMC,GAAN,KAAc;IACvDJ,OAAO,GAAGG,GAAV;IACAF,MAAM,GAAGG,GAAT;EACD,CAHe,CAAhB;EAKA,OAAON,MAAM,CAAC;IAAEI,OAAF;IAAWF,OAAX;IAAoBC;EAApB,CAAD,CAAb;AACD;AACDH,MAAM,CAACC,cAAD,CAAN;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAASM,SAAT,CAAmBC,YAAnB,EAAiC;EACtC,OAAOV,OAAO,CAACI,OAAR,CAAgBM,YAAhB,MAAkCA,YAAzC;AACD;AACDR,MAAM,CAACO,SAAD,CAAN"},"metadata":{},"sourceType":"module"}