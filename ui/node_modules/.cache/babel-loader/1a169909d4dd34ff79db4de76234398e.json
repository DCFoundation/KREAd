{"ast":null,"code":"import { FERAL_FUNCTION, SyntaxError, TypeError, defineProperties, getPrototypeOf, setPrototypeOf } from './commons.js'; // This module replaces the original `Function` constructor, and the original\n// `%GeneratorFunction%`, `%AsyncFunction%` and `%AsyncGeneratorFunction%`,\n// with safe replacements that throw if invoked.\n//\n// These are all reachable via syntax, so it isn't sufficient to just\n// replace global properties with safe versions. Our main goal is to prevent\n// access to the `Function` constructor through these starting points.\n//\n// After modules block is done, the originals must no longer be reachable,\n// unless a copy has been made, and functions can only be created by syntax\n// (using eval) or by invoking a previously saved reference to the originals.\n//\n// Typically, this module will not be used directly, but via the\n// [lockdown - shim] which handles all necessary repairs and taming in SES.\n//\n// Relation to ECMA specifications\n//\n// The taming of constructors really wants to be part of the standard, because\n// new constructors may be added in the future, reachable from syntax, and this\n// list must be updated to match.\n//\n// In addition, the standard needs to define four new intrinsics for the safe\n// replacement functions. See [./whitelist intrinsics].\n//\n// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * tameFunctionConstructors()\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n */\n\nexport default function tameFunctionConstructors() {\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    FERAL_FUNCTION.prototype.constructor('return 1');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return {};\n  }\n\n  const newIntrinsics = {};\n  /*\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n\n  function repairFunction(name, intrinsicName, declaration) {\n    let FunctionInstance;\n\n    try {\n      // eslint-disable-next-line no-eval, no-restricted-globals\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      } // Re-throw\n\n\n      throw e;\n    }\n\n    const FunctionPrototype = getPrototypeOf(FunctionInstance); // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    // eslint-disable-next-line func-names\n\n    const InertConstructor = function () {\n      throw new TypeError('Function.prototype.constructor is not a valid constructor.');\n    };\n\n    defineProperties(InertConstructor, {\n      prototype: {\n        value: FunctionPrototype\n      },\n      name: {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n      }\n    });\n    defineProperties(FunctionPrototype, {\n      constructor: {\n        value: InertConstructor\n      }\n    }); // Reconstructs the inheritance among the new tamed constructors\n    // to mirror the original specified in normal JS.\n\n    if (InertConstructor !== FERAL_FUNCTION.prototype.constructor) {\n      setPrototypeOf(InertConstructor, FERAL_FUNCTION.prototype.constructor);\n    }\n\n    newIntrinsics[intrinsicName] = InertConstructor;\n  } // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the\n  // tamed Function function constructor.\n\n\n  repairFunction('Function', '%InertFunction%', '(function(){})');\n  repairFunction('GeneratorFunction', '%InertGeneratorFunction%', '(function*(){})');\n  repairFunction('AsyncFunction', '%InertAsyncFunction%', '(async function(){})');\n  repairFunction('AsyncGeneratorFunction', '%InertAsyncGeneratorFunction%', '(async function*(){})');\n  return newIntrinsics;\n}","map":{"version":3,"names":["FERAL_FUNCTION","SyntaxError","TypeError","defineProperties","getPrototypeOf","setPrototypeOf","tameFunctionConstructors","prototype","constructor","ignore","newIntrinsics","repairFunction","name","intrinsicName","declaration","FunctionInstance","eval","e","FunctionPrototype","InertConstructor","value","writable","enumerable","configurable"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/tame-function-constructors.js"],"sourcesContent":["import {\n  FERAL_FUNCTION,\n  SyntaxError,\n  TypeError,\n  defineProperties,\n  getPrototypeOf,\n  setPrototypeOf,\n} from './commons.js';\n\n// This module replaces the original `Function` constructor, and the original\n// `%GeneratorFunction%`, `%AsyncFunction%` and `%AsyncGeneratorFunction%`,\n// with safe replacements that throw if invoked.\n//\n// These are all reachable via syntax, so it isn't sufficient to just\n// replace global properties with safe versions. Our main goal is to prevent\n// access to the `Function` constructor through these starting points.\n//\n// After modules block is done, the originals must no longer be reachable,\n// unless a copy has been made, and functions can only be created by syntax\n// (using eval) or by invoking a previously saved reference to the originals.\n//\n// Typically, this module will not be used directly, but via the\n// [lockdown - shim] which handles all necessary repairs and taming in SES.\n//\n// Relation to ECMA specifications\n//\n// The taming of constructors really wants to be part of the standard, because\n// new constructors may be added in the future, reachable from syntax, and this\n// list must be updated to match.\n//\n// In addition, the standard needs to define four new intrinsics for the safe\n// replacement functions. See [./whitelist intrinsics].\n//\n// Adapted from SES/Caja\n// Copyright (C) 2011 Google Inc.\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n\n/**\n * tameFunctionConstructors()\n * This block replaces the original Function constructor, and the original\n * %GeneratorFunction% %AsyncFunction% and %AsyncGeneratorFunction%, with\n * safe replacements that throw if invoked.\n */\nexport default function tameFunctionConstructors() {\n  try {\n    // Verify that the method is not callable.\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    FERAL_FUNCTION.prototype.constructor('return 1');\n  } catch (ignore) {\n    // Throws, no need to patch.\n    return {};\n  }\n\n  const newIntrinsics = {};\n\n  /*\n   * The process to repair constructors:\n   * 1. Create an instance of the function by evaluating syntax\n   * 2. Obtain the prototype from the instance\n   * 3. Create a substitute tamed constructor\n   * 4. Replace the original constructor with the tamed constructor\n   * 5. Replace tamed constructor prototype property with the original one\n   * 6. Replace its [[Prototype]] slot with the tamed constructor of Function\n   */\n  function repairFunction(name, intrinsicName, declaration) {\n    let FunctionInstance;\n    try {\n      // eslint-disable-next-line no-eval, no-restricted-globals\n      FunctionInstance = (0, eval)(declaration);\n    } catch (e) {\n      if (e instanceof SyntaxError) {\n        // Prevent failure on platforms where async and/or generators\n        // are not supported.\n        return;\n      }\n      // Re-throw\n      throw e;\n    }\n    const FunctionPrototype = getPrototypeOf(FunctionInstance);\n\n    // Prevents the evaluation of source when calling constructor on the\n    // prototype of functions.\n    // eslint-disable-next-line func-names\n    const InertConstructor = function() {\n      throw new TypeError(\n        'Function.prototype.constructor is not a valid constructor.',\n      );\n    };\n    defineProperties(InertConstructor, {\n      prototype: { value: FunctionPrototype },\n      name: {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true,\n      },\n    });\n\n    defineProperties(FunctionPrototype, {\n      constructor: { value: InertConstructor },\n    });\n\n    // Reconstructs the inheritance among the new tamed constructors\n    // to mirror the original specified in normal JS.\n    if (InertConstructor !== FERAL_FUNCTION.prototype.constructor) {\n      setPrototypeOf(InertConstructor, FERAL_FUNCTION.prototype.constructor);\n    }\n\n    newIntrinsics[intrinsicName] = InertConstructor;\n  }\n\n  // Here, the order of operation is important: Function needs to be repaired\n  // first since the other repaired constructors need to inherit from the\n  // tamed Function function constructor.\n\n  repairFunction('Function', '%InertFunction%', '(function(){})');\n  repairFunction(\n    'GeneratorFunction',\n    '%InertGeneratorFunction%',\n    '(function*(){})',\n  );\n  repairFunction(\n    'AsyncFunction',\n    '%InertAsyncFunction%',\n    '(async function(){})',\n  );\n  repairFunction(\n    'AsyncGeneratorFunction',\n    '%InertAsyncGeneratorFunction%',\n    '(async function*(){})',\n  );\n\n  return newIntrinsics;\n}\n"],"mappings":"AAAA,SACEA,cADF,EAEEC,WAFF,EAGEC,SAHF,EAIEC,gBAJF,EAKEC,cALF,EAMEC,cANF,QAOO,cAPP,C,CASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,wBAAT,GAAoC;EACjD,IAAI;IACF;IACA;IACAN,cAAc,CAACO,SAAf,CAAyBC,WAAzB,CAAqC,UAArC;EACD,CAJD,CAIE,OAAOC,MAAP,EAAe;IACf;IACA,OAAO,EAAP;EACD;;EAED,MAAMC,aAAa,GAAG,EAAtB;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,SAASC,cAAT,CAAwBC,IAAxB,EAA8BC,aAA9B,EAA6CC,WAA7C,EAA0D;IACxD,IAAIC,gBAAJ;;IACA,IAAI;MACF;MACAA,gBAAgB,GAAG,CAAC,GAAGC,IAAJ,EAAUF,WAAV,CAAnB;IACD,CAHD,CAGE,OAAOG,CAAP,EAAU;MACV,IAAIA,CAAC,YAAYhB,WAAjB,EAA8B;QAC5B;QACA;QACA;MACD,CALS,CAMV;;;MACA,MAAMgB,CAAN;IACD;;IACD,MAAMC,iBAAiB,GAAGd,cAAc,CAACW,gBAAD,CAAxC,CAdwD,CAgBxD;IACA;IACA;;IACA,MAAMI,gBAAgB,GAAG,YAAW;MAClC,MAAM,IAAIjB,SAAJ,CACJ,4DADI,CAAN;IAGD,CAJD;;IAKAC,gBAAgB,CAACgB,gBAAD,EAAmB;MACjCZ,SAAS,EAAE;QAAEa,KAAK,EAAEF;MAAT,CADsB;MAEjCN,IAAI,EAAE;QACJQ,KAAK,EAAER,IADH;QAEJS,QAAQ,EAAE,KAFN;QAGJC,UAAU,EAAE,KAHR;QAIJC,YAAY,EAAE;MAJV;IAF2B,CAAnB,CAAhB;IAUApB,gBAAgB,CAACe,iBAAD,EAAoB;MAClCV,WAAW,EAAE;QAAEY,KAAK,EAAED;MAAT;IADqB,CAApB,CAAhB,CAlCwD,CAsCxD;IACA;;IACA,IAAIA,gBAAgB,KAAKnB,cAAc,CAACO,SAAf,CAAyBC,WAAlD,EAA+D;MAC7DH,cAAc,CAACc,gBAAD,EAAmBnB,cAAc,CAACO,SAAf,CAAyBC,WAA5C,CAAd;IACD;;IAEDE,aAAa,CAACG,aAAD,CAAb,GAA+BM,gBAA/B;EACD,CAlEgD,CAoEjD;EACA;EACA;;;EAEAR,cAAc,CAAC,UAAD,EAAa,iBAAb,EAAgC,gBAAhC,CAAd;EACAA,cAAc,CACZ,mBADY,EAEZ,0BAFY,EAGZ,iBAHY,CAAd;EAKAA,cAAc,CACZ,eADY,EAEZ,sBAFY,EAGZ,sBAHY,CAAd;EAKAA,cAAc,CACZ,wBADY,EAEZ,+BAFY,EAGZ,uBAHY,CAAd;EAMA,OAAOD,aAAP;AACD"},"metadata":{},"sourceType":"module"}