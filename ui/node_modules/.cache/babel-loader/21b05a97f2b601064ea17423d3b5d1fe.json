{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport './types.js';\n/**\n * Adaptor from a notifierP to an async iterable.\n * The notifierP can be any object that has an eventually invokable\n * `getUpdateSince` method that behaves according to the notifier\n * spec. This can be a notifier, a promise for a local or remote\n * notfier, or a presence of a remote notifier.\n *\n * It is also used internally by notifier.js so that a notifier itself is an\n * async iterable.\n *\n * An async iterable is an object with a `[Symbol.asyncIterator]()` method\n * that returns an async iterator. The async iterator we return here has only\n * a `next()` method, without the optional `return` and `throw` methods. The\n * omitted methods, if present, would be used by the for/await/of loop to\n * inform the iterator of early termination. But this adaptor would not do\n * anything useful in reaction to this notification.\n *\n * An async iterator's `next()` method returns a promise for an iteration\n * result. An iteration result is a record with `value` and `done` properties.\n *\n * The purpose of building on the notifier protocol is to have a lossy\n * adaptor, where intermediate results can be missed in favor of more recent\n * results which are therefore less stale. See\n * https://github.com/Agoric/documentation/blob/master/main/distributed-programming.md#notifiers\n *\n * @template T\n * @param {ERef<BaseNotifier<T>>} notifierP\n * @returns {ConsistentAsyncIterable<T>}\n */\n\nexport const makeAsyncIterableFromNotifier = notifierP => {\n  return Far('asyncIterableFromNotifier', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {UpdateCount} */\n      let localUpdateCount;\n      /** @type {Promise<{value: T, done: boolean}> | undefined} */\n\n      let myIterationResultP;\n      return Far('asyncIteratorFromNotifier', {\n        next: () => {\n          if (!myIterationResultP) {\n            // In this adaptor, once `next()` is called and returns an\n            // unresolved promise, `myIterationResultP`, and until\n            // `myIterationResultP` is fulfilled with an\n            // iteration result, further `next()` calls will return the same\n            // `myIterationResultP` promise again without asking the notifier\n            // for more updates. If there's already an unanswered ask in the\n            // air, all further asks should just reuse the result of that one.\n            //\n            // This reuse behavior is only needed for code that uses the async\n            // iterator protocol explicitly. When this async iterator is\n            // consumed by a for/await/of loop, `next()` will only be called\n            // after the promise for the previous iteration result has\n            // fulfilled. If it fulfills with `done: true`, the for/await/of\n            // loop will never call `next()` again.\n            //\n            // See\n            // https://2ality.com/2016/10/asynchronous-iteration.html#queuing-next()-invocations\n            // for an explicit use that sends `next()` without waiting.\n            myIterationResultP = E(notifierP).getUpdateSince(localUpdateCount).then(_ref => {\n              let {\n                value,\n                updateCount\n              } = _ref;\n              localUpdateCount = updateCount;\n              const done = localUpdateCount === undefined;\n\n              if (!done) {\n                // Once the outstanding question has been answered, stop\n                // using that answer, so any further `next()` questions\n                // cause a new `getUpdateSince` request.\n                //\n                // But only if more answers are expected. Once the notifier\n                // is `done`, that was the last answer so reuse it forever.\n                myIterationResultP = undefined;\n              }\n\n              return harden({\n                value,\n                done\n              });\n            });\n          }\n\n          return myIterationResultP;\n        }\n      });\n    }\n  });\n};\n/**\n * This advances `asyncIteratorP` updating `iterationObserver` with each\n * successive value. The `iterationObserver` may only be interested in certain\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\n * `observeIterator` feature tests for those methods before calling them.\n *\n * @template T\n * @param {ERef<AsyncIterator<T>>} asyncIteratorP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\n\nexport const observeIterator = (asyncIteratorP, iterationObserver) => {\n  return new Promise(ack => {\n    const recur = () => {\n      E.when(E(asyncIteratorP).next(), _ref2 => {\n        let {\n          value,\n          done\n        } = _ref2;\n\n        if (done) {\n          iterationObserver.finish && iterationObserver.finish(value);\n          ack(undefined);\n        } else {\n          iterationObserver.updateState && iterationObserver.updateState(value);\n          recur();\n        }\n      }, reason => {\n        iterationObserver.fail && iterationObserver.fail(reason);\n        ack(undefined);\n      });\n    };\n\n    recur();\n  });\n};\n/**\n * This reads from `asyncIterableP` updating `iterationObserver` with each\n * successive value. The `iterationObserver` may only be interested in certain\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\n * `observeIteration` feature tests for those methods before calling them.\n *\n * @template T\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\n\nexport const observeIteration = (asyncIterableP, iterationObserver) => {\n  const iteratorP = E(asyncIterableP)[Symbol.asyncIterator]();\n  return observeIterator(iteratorP, iterationObserver);\n};\n/**\n * @deprecated Use `observeIteration` instead\n * @template T\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @returns {Promise<undefined>}\n */\n\nexport const updateFromIterable = (iterationObserver, asyncIterableP) => observeIteration(asyncIterableP, iterationObserver);\n/**\n * As updates come in from the possibly remote `notifierP`, update\n * the local `updater`. Since the updates come from a notifier, they\n * are lossy, i.e., once a more recent state can be reported, less recent\n * states are assumed irrelevant and dropped.\n *\n * @template T\n * @param {ERef<Notifier<T>>} notifierP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\n\nexport const observeNotifier = (notifierP, iterationObserver) => observeIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);\n/**\n * @deprecated Use 'observeNotifier` instead.\n * @template T\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @param {ERef<Notifier<T>>} notifierP\n * @returns {Promise<undefined>}\n */\n\nexport const updateFromNotifier = (iterationObserver, notifierP) => observeIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);","map":{"version":3,"names":["E","Far","makeAsyncIterableFromNotifier","notifierP","Symbol","asyncIterator","localUpdateCount","myIterationResultP","next","getUpdateSince","then","value","updateCount","done","undefined","harden","observeIterator","asyncIteratorP","iterationObserver","Promise","ack","recur","when","finish","updateState","reason","fail","observeIteration","asyncIterableP","iteratorP","updateFromIterable","observeNotifier","updateFromNotifier"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@agoric/notifier/src/asyncIterableAdaptor.js"],"sourcesContent":["// @ts-check\n/// <reference types=\"ses\"/>\n\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\n\nimport './types.js';\n\n/**\n * Adaptor from a notifierP to an async iterable.\n * The notifierP can be any object that has an eventually invokable\n * `getUpdateSince` method that behaves according to the notifier\n * spec. This can be a notifier, a promise for a local or remote\n * notfier, or a presence of a remote notifier.\n *\n * It is also used internally by notifier.js so that a notifier itself is an\n * async iterable.\n *\n * An async iterable is an object with a `[Symbol.asyncIterator]()` method\n * that returns an async iterator. The async iterator we return here has only\n * a `next()` method, without the optional `return` and `throw` methods. The\n * omitted methods, if present, would be used by the for/await/of loop to\n * inform the iterator of early termination. But this adaptor would not do\n * anything useful in reaction to this notification.\n *\n * An async iterator's `next()` method returns a promise for an iteration\n * result. An iteration result is a record with `value` and `done` properties.\n *\n * The purpose of building on the notifier protocol is to have a lossy\n * adaptor, where intermediate results can be missed in favor of more recent\n * results which are therefore less stale. See\n * https://github.com/Agoric/documentation/blob/master/main/distributed-programming.md#notifiers\n *\n * @template T\n * @param {ERef<BaseNotifier<T>>} notifierP\n * @returns {ConsistentAsyncIterable<T>}\n */\nexport const makeAsyncIterableFromNotifier = notifierP => {\n  return Far('asyncIterableFromNotifier', {\n    [Symbol.asyncIterator]: () => {\n      /** @type {UpdateCount} */\n      let localUpdateCount;\n      /** @type {Promise<{value: T, done: boolean}> | undefined} */\n      let myIterationResultP;\n      return Far('asyncIteratorFromNotifier', {\n        next: () => {\n          if (!myIterationResultP) {\n            // In this adaptor, once `next()` is called and returns an\n            // unresolved promise, `myIterationResultP`, and until\n            // `myIterationResultP` is fulfilled with an\n            // iteration result, further `next()` calls will return the same\n            // `myIterationResultP` promise again without asking the notifier\n            // for more updates. If there's already an unanswered ask in the\n            // air, all further asks should just reuse the result of that one.\n            //\n            // This reuse behavior is only needed for code that uses the async\n            // iterator protocol explicitly. When this async iterator is\n            // consumed by a for/await/of loop, `next()` will only be called\n            // after the promise for the previous iteration result has\n            // fulfilled. If it fulfills with `done: true`, the for/await/of\n            // loop will never call `next()` again.\n            //\n            // See\n            // https://2ality.com/2016/10/asynchronous-iteration.html#queuing-next()-invocations\n            // for an explicit use that sends `next()` without waiting.\n            myIterationResultP = E(notifierP)\n              .getUpdateSince(localUpdateCount)\n              .then(({ value, updateCount }) => {\n                localUpdateCount = updateCount;\n                const done = localUpdateCount === undefined;\n                if (!done) {\n                  // Once the outstanding question has been answered, stop\n                  // using that answer, so any further `next()` questions\n                  // cause a new `getUpdateSince` request.\n                  //\n                  // But only if more answers are expected. Once the notifier\n                  // is `done`, that was the last answer so reuse it forever.\n                  myIterationResultP = undefined;\n                }\n                return harden({ value, done });\n              });\n          }\n          return myIterationResultP;\n        },\n      });\n    },\n  });\n};\n\n/**\n * This advances `asyncIteratorP` updating `iterationObserver` with each\n * successive value. The `iterationObserver` may only be interested in certain\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\n * `observeIterator` feature tests for those methods before calling them.\n *\n * @template T\n * @param {ERef<AsyncIterator<T>>} asyncIteratorP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\nexport const observeIterator = (asyncIteratorP, iterationObserver) => {\n  return new Promise(ack => {\n    const recur = () => {\n      E.when(\n        E(asyncIteratorP).next(),\n        ({ value, done }) => {\n          if (done) {\n            iterationObserver.finish && iterationObserver.finish(value);\n            ack(undefined);\n          } else {\n            iterationObserver.updateState &&\n              iterationObserver.updateState(value);\n            recur();\n          }\n        },\n        reason => {\n          iterationObserver.fail && iterationObserver.fail(reason);\n          ack(undefined);\n        },\n      );\n    };\n    recur();\n  });\n};\n\n/**\n * This reads from `asyncIterableP` updating `iterationObserver` with each\n * successive value. The `iterationObserver` may only be interested in certain\n * occurrences (`updateState`, `finish`, `fail`), so for convenience,\n * `observeIteration` feature tests for those methods before calling them.\n *\n * @template T\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\nexport const observeIteration = (asyncIterableP, iterationObserver) => {\n  const iteratorP = E(asyncIterableP)[Symbol.asyncIterator]();\n  return observeIterator(iteratorP, iterationObserver);\n};\n\n/**\n * @deprecated Use `observeIteration` instead\n * @template T\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @returns {Promise<undefined>}\n */\nexport const updateFromIterable = (iterationObserver, asyncIterableP) =>\n  observeIteration(asyncIterableP, iterationObserver);\n\n/**\n * As updates come in from the possibly remote `notifierP`, update\n * the local `updater`. Since the updates come from a notifier, they\n * are lossy, i.e., once a more recent state can be reported, less recent\n * states are assumed irrelevant and dropped.\n *\n * @template T\n * @param {ERef<Notifier<T>>} notifierP\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @returns {Promise<undefined>}\n */\nexport const observeNotifier = (notifierP, iterationObserver) =>\n  observeIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);\n\n/**\n * @deprecated Use 'observeNotifier` instead.\n * @template T\n * @param {Partial<IterationObserver<T>>} iterationObserver\n * @param {ERef<Notifier<T>>} notifierP\n * @returns {Promise<undefined>}\n */\nexport const updateFromNotifier = (iterationObserver, notifierP) =>\n  observeIteration(makeAsyncIterableFromNotifier(notifierP), iterationObserver);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}