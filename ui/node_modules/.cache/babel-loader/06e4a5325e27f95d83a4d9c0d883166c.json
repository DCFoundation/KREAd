{"ast":null,"code":"// Copyright (C) 2019 Agoric, under Apache License 2.0\n// @ts-check\n// To ensure that this module operates without special privilege, it should\n// not reference the free variable `console` except for its own internal\n// debugging purposes in the declaration of `internalDebugConsole`, which is\n// normally commented out.\n// This module however has top level mutable state which is observable to code\n// given access to the `loggedErrorHandler`, such as the causal console\n// of `console.js`. However, for code that does not have such access, this\n// module should not be observably impure.\nimport { RangeError, TypeError, WeakMap, arrayJoin, arrayMap, arrayPop, arrayPush, assign, freeze, globalThis, is, isError, stringIndexOf, stringReplace, stringSlice, stringStartsWith, weakmapDelete, weakmapGet, weakmapHas, weakmapSet } from '../commons.js';\nimport { an, bestEffortStringify } from './stringify-utils.js';\nimport './types.js';\nimport './internal-types.js'; // For our internal debugging purposes, uncomment\n// const internalDebugConsole = console;\n// /////////////////////////////////////////////////////////////////////////////\n\n/** @type {WeakMap<StringablePayload, any>} */\n\nconst declassifiers = new WeakMap();\n/** @type {AssertQuote} */\n\nconst quote = function (payload) {\n  let spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  const result = freeze({\n    toString: freeze(() => bestEffortStringify(payload, spaces))\n  });\n  weakmapSet(declassifiers, result, payload);\n  return result;\n};\n\nfreeze(quote); // /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} HiddenDetails\n *\n * Captures the arguments passed to the `details` template string tag.\n *\n * @property {TemplateStringsArray | string[]} template\n * @property {any[]} args\n */\n\n/**\n * @type {WeakMap<DetailsToken, HiddenDetails>}\n *\n * Maps from a details token which a `details` template literal returned\n * to a record of the contents of that template literal expression.\n */\n\nconst hiddenDetailsMap = new WeakMap();\n/**\n * @param {HiddenDetails} hiddenDetails\n * @returns {string}\n */\n\nconst getMessageString = _ref => {\n  let {\n    template,\n    args\n  } = _ref;\n  const parts = [template[0]];\n\n  for (let i = 0; i < args.length; i += 1) {\n    const arg = args[i];\n    let argStr;\n\n    if (weakmapHas(declassifiers, arg)) {\n      argStr = `${arg}`;\n    } else if (isError(arg)) {\n      argStr = `(${an(arg.name)})`;\n    } else {\n      argStr = `(${an(typeof arg)})`;\n    }\n\n    arrayPush(parts, argStr, template[i + 1]);\n  }\n\n  return arrayJoin(parts, '');\n};\n/**\n * Give detailsTokens a toString behavior. To minimize the overhead of\n * creating new detailsTokens, we do this with an\n * inherited `this` sensitive `toString` method, even though we normally\n * avoid `this` sensitivity. To protect the method from inappropriate\n * `this` application, it does something interesting only for objects\n * registered in `redactedDetails`, which should be exactly the detailsTokens.\n *\n * The printing behavior must not reveal anything redacted, so we just use\n * the same `getMessageString` we use to construct the redacted message\n * string for a thrown assertion error.\n */\n\n\nconst DetailsTokenProto = freeze({\n  toString() {\n    const hiddenDetails = weakmapGet(hiddenDetailsMap, this);\n\n    if (hiddenDetails === undefined) {\n      return '[Not a DetailsToken]';\n    }\n\n    return getMessageString(hiddenDetails);\n  }\n\n});\nfreeze(DetailsTokenProto.toString);\n/**\n * Normally this is the function exported as `assert.details` and often\n * spelled `d`. However, if the `{errorTaming: 'unsafe'}` option is given to\n * `lockdown`, then `unredactedDetails` is used instead.\n *\n * There are some unconditional uses of `redactedDetails` in this module. All\n * of them should be uses where the template literal has no redacted\n * substitution values. In those cases, the two are equivalent.\n *\n * @type {DetailsTag}\n */\n\nconst redactedDetails = function (template) {\n  // Keep in mind that the vast majority of calls to `details` creates\n  // a details token that is never used, so this path must remain as fast as\n  // possible. Hence we store what we've got with little processing, postponing\n  // all the work to happen only if needed, for example, if an assertion fails.\n  const detailsToken = freeze({\n    __proto__: DetailsTokenProto\n  });\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  weakmapSet(hiddenDetailsMap, detailsToken, {\n    template,\n    args\n  });\n  return detailsToken;\n};\n\nfreeze(redactedDetails);\n/**\n * `unredactedDetails` is like `details` except that it does not redact\n * anything. It acts like `details` would act if all substitution values\n * were wrapped with the `quote` function above (the function normally\n * spelled `q`). If the `{errorTaming: 'unsafe'}` option is given to\n * `lockdown`, then the lockdown-shim arranges for the global `assert` to be\n * one whose `details` property is `unredactedDetails`.\n * This setting optimizes the debugging and testing experience at the price\n * of safety. `unredactedDetails` also sacrifices the speed of `details`,\n * which is usually fine in debugging and testing.\n *\n * @type {DetailsTag}\n */\n\nconst unredactedDetails = function (template) {\n  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  args = arrayMap(args, arg => weakmapHas(declassifiers, arg) ? arg : quote(arg));\n  return redactedDetails(template, ...args);\n};\n\nfreeze(unredactedDetails);\nexport { unredactedDetails };\n/**\n * @param {HiddenDetails} hiddenDetails\n * @returns {LogArgs}\n */\n\nconst getLogArgs = _ref2 => {\n  let {\n    template,\n    args\n  } = _ref2;\n  const logArgs = [template[0]];\n\n  for (let i = 0; i < args.length; i += 1) {\n    let arg = args[i];\n\n    if (weakmapHas(declassifiers, arg)) {\n      arg = weakmapGet(declassifiers, arg);\n    } // Remove the extra spaces (since console.error puts them\n    // between each cause).\n\n\n    const priorWithoutSpace = stringReplace(arrayPop(logArgs) || '', / $/, '');\n\n    if (priorWithoutSpace !== '') {\n      arrayPush(logArgs, priorWithoutSpace);\n    }\n\n    const nextWithoutSpace = stringReplace(template[i + 1], /^ /, '');\n    arrayPush(logArgs, arg, nextWithoutSpace);\n  }\n\n  if (logArgs[logArgs.length - 1] === '') {\n    arrayPop(logArgs);\n  }\n\n  return logArgs;\n};\n/**\n * @type {WeakMap<Error, LogArgs>}\n *\n * Maps from an error object to the log args that are a more informative\n * alternative message for that error. When logging the error, these\n * log args should be preferred to `error.message`.\n */\n\n\nconst hiddenMessageLogArgs = new WeakMap(); // So each error tag will be unique.\n\nlet errorTagNum = 0;\n/**\n * @type {WeakMap<Error, string>}\n */\n\nconst errorTags = new WeakMap();\n/**\n * @param {Error} err\n * @param {string=} optErrorName\n * @returns {string}\n */\n\nconst tagError = function (err) {\n  let optErrorName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : err.name;\n  let errorTag = weakmapGet(errorTags, err);\n\n  if (errorTag !== undefined) {\n    return errorTag;\n  }\n\n  errorTagNum += 1;\n  errorTag = `${optErrorName}#${errorTagNum}`;\n  weakmapSet(errorTags, err, errorTag);\n  return errorTag;\n};\n/**\n * @type {AssertMakeError}\n */\n\n\nconst makeError = function () {\n  let optDetails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : redactedDetails`Assert failed`;\n  let ErrorConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalThis.Error;\n  let {\n    errorName = undefined\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof optDetails === 'string') {\n    // If it is a string, use it as the literal part of the template so\n    // it doesn't get quoted.\n    optDetails = redactedDetails([optDetails]);\n  }\n\n  const hiddenDetails = weakmapGet(hiddenDetailsMap, optDetails);\n\n  if (hiddenDetails === undefined) {\n    throw new TypeError(`unrecognized details ${quote(optDetails)}`);\n  }\n\n  const messageString = getMessageString(hiddenDetails);\n  const error = new ErrorConstructor(messageString);\n  weakmapSet(hiddenMessageLogArgs, error, getLogArgs(hiddenDetails));\n\n  if (errorName !== undefined) {\n    tagError(error, errorName);\n  } // The next line is a particularly fruitful place to put a breakpoint.\n\n\n  return error;\n};\n\nfreeze(makeError); // /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @type {WeakMap<Error, LogArgs[]>}\n *\n * Maps from an error to an array of log args, where each log args is\n * remembered as an annotation on that error. This can be used, for example,\n * to keep track of additional causes of the error. The elements of any\n * log args may include errors which are associated with further annotations.\n * An augmented console, like the causal console of `console.js`, could\n * then retrieve the graph of such annotations.\n */\n\nconst hiddenNoteLogArgsArrays = new WeakMap();\n/**\n * @type {WeakMap<Error, NoteCallback[]>}\n *\n * An augmented console will normally only take the hidden noteArgs array once,\n * when it logs the error being annotated. Once that happens, further\n * annotations of that error should go to the console immediately. We arrange\n * that by accepting a note-callback function from the console as an optional\n * part of that taking operation. Normally there will only be at most one\n * callback per error, but that depends on console behavior which we should not\n * assume. We make this an array of callbacks so multiple registrations\n * are independent.\n */\n\nconst hiddenNoteCallbackArrays = new WeakMap();\n/** @type {AssertNote} */\n\nconst note = (error, detailsNote) => {\n  if (typeof detailsNote === 'string') {\n    // If it is a string, use it as the literal part of the template so\n    // it doesn't get quoted.\n    detailsNote = redactedDetails([detailsNote]);\n  }\n\n  const hiddenDetails = weakmapGet(hiddenDetailsMap, detailsNote);\n\n  if (hiddenDetails === undefined) {\n    throw new TypeError(`unrecognized details ${quote(detailsNote)}`);\n  }\n\n  const logArgs = getLogArgs(hiddenDetails);\n  const callbacks = weakmapGet(hiddenNoteCallbackArrays, error);\n\n  if (callbacks !== undefined) {\n    for (const callback of callbacks) {\n      callback(error, logArgs);\n    }\n  } else {\n    const logArgsArray = weakmapGet(hiddenNoteLogArgsArrays, error);\n\n    if (logArgsArray !== undefined) {\n      arrayPush(logArgsArray, logArgs);\n    } else {\n      weakmapSet(hiddenNoteLogArgsArrays, error, [logArgs]);\n    }\n  }\n};\n\nfreeze(note);\n/**\n * The unprivileged form that just uses the de facto `error.stack` property.\n * The start compartment normally has a privileged `globalThis.getStackString`\n * which should be preferred if present.\n *\n * @param {Error} error\n * @returns {string}\n */\n\nconst defaultGetStackString = error => {\n  if (!('stack' in error)) {\n    return '';\n  }\n\n  const stackString = `${error.stack}`;\n  const pos = stringIndexOf(stackString, '\\n');\n\n  if (stringStartsWith(stackString, ' ') || pos === -1) {\n    return stackString;\n  }\n\n  return stringSlice(stackString, pos + 1); // exclude the initial newline\n};\n/** @type {LoggedErrorHandler} */\n\n\nconst loggedErrorHandler = {\n  getStackString: globalThis.getStackString || defaultGetStackString,\n  tagError: error => tagError(error),\n  resetErrorTagNum: () => {\n    errorTagNum = 0;\n  },\n  getMessageLogArgs: error => weakmapGet(hiddenMessageLogArgs, error),\n  takeMessageLogArgs: error => {\n    const result = weakmapGet(hiddenMessageLogArgs, error);\n    weakmapDelete(hiddenMessageLogArgs, error);\n    return result;\n  },\n  takeNoteLogArgsArray: (error, callback) => {\n    const result = weakmapGet(hiddenNoteLogArgsArrays, error);\n    weakmapDelete(hiddenNoteLogArgsArrays, error);\n\n    if (callback !== undefined) {\n      const callbacks = weakmapGet(hiddenNoteCallbackArrays, error);\n\n      if (callbacks) {\n        arrayPush(callbacks, callback);\n      } else {\n        weakmapSet(hiddenNoteCallbackArrays, error, [callback]);\n      }\n    }\n\n    return result || [];\n  }\n};\nfreeze(loggedErrorHandler);\nexport { loggedErrorHandler }; // /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @type {MakeAssert}\n */\n\nconst makeAssert = function () {\n  let optRaise = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n  let unredacted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const details = unredacted ? unredactedDetails : redactedDetails;\n  /** @type {AssertFail} */\n\n  const fail = function () {\n    let optDetails = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : details`Assert failed`;\n    let ErrorConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalThis.Error;\n    const reason = makeError(optDetails, ErrorConstructor);\n\n    if (optRaise !== undefined) {\n      optRaise(reason);\n    }\n\n    throw reason;\n  };\n\n  freeze(fail); // Don't freeze or export `baseAssert` until we add methods.\n  // TODO If I change this from a `function` function to an arrow\n  // function, I seem to get type errors from TypeScript. Why?\n\n  /** @type {BaseAssert} */\n\n  function baseAssert(flag) {\n    let optDetails = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : details`Check failed`;\n    let ErrorConstructor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : globalThis.Error;\n\n    if (!flag) {\n      throw fail(optDetails, ErrorConstructor);\n    }\n  }\n  /** @type {AssertEqual} */\n\n\n  const equal = function (actual, expected) {\n    let optDetails = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : details`Expected ${actual} is same as ${expected}`;\n    let ErrorConstructor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : RangeError;\n    baseAssert(is(actual, expected), optDetails, ErrorConstructor);\n  };\n\n  freeze(equal);\n  /** @type {AssertTypeof} */\n\n  const assertTypeof = (specimen, typename, optDetails) => {\n    baseAssert(typeof typename === 'string', details`${quote(typename)} must be a string`);\n\n    if (optDetails === undefined) {\n      // Like\n      // ```js\n      // optDetails = details`${specimen} must be ${quote(an(typename))}`;\n      // ```\n      // except it puts the typename into the literal part of the template\n      // so it doesn't get quoted.\n      optDetails = details(['', ` must be ${an(typename)}`], specimen);\n    }\n\n    equal(typeof specimen, typename, optDetails, TypeError);\n  };\n\n  freeze(assertTypeof);\n  /** @type {AssertString} */\n\n  const assertString = (specimen, optDetails) => assertTypeof(specimen, 'string', optDetails); // Note that \"assert === baseAssert\"\n\n  /** @type {Assert} */\n\n\n  const assert = assign(baseAssert, {\n    error: makeError,\n    fail,\n    equal,\n    typeof: assertTypeof,\n    string: assertString,\n    note,\n    details,\n    quote,\n    makeAssert\n  });\n  return freeze(assert);\n};\n\nfreeze(makeAssert);\nexport { makeAssert };\n/** @type {Assert} */\n\nconst assert = makeAssert();\nexport { assert };","map":{"version":3,"names":["RangeError","TypeError","WeakMap","arrayJoin","arrayMap","arrayPop","arrayPush","assign","freeze","globalThis","is","isError","stringIndexOf","stringReplace","stringSlice","stringStartsWith","weakmapDelete","weakmapGet","weakmapHas","weakmapSet","an","bestEffortStringify","declassifiers","quote","payload","spaces","undefined","result","toString","hiddenDetailsMap","getMessageString","template","args","parts","i","length","arg","argStr","name","DetailsTokenProto","hiddenDetails","redactedDetails","detailsToken","__proto__","unredactedDetails","getLogArgs","logArgs","priorWithoutSpace","nextWithoutSpace","hiddenMessageLogArgs","errorTagNum","errorTags","tagError","err","optErrorName","errorTag","makeError","optDetails","ErrorConstructor","Error","errorName","messageString","error","hiddenNoteLogArgsArrays","hiddenNoteCallbackArrays","note","detailsNote","callbacks","callback","logArgsArray","defaultGetStackString","stackString","stack","pos","loggedErrorHandler","getStackString","resetErrorTagNum","getMessageLogArgs","takeMessageLogArgs","takeNoteLogArgsArray","makeAssert","optRaise","unredacted","details","fail","reason","baseAssert","flag","equal","actual","expected","assertTypeof","specimen","typename","assertString","assert","typeof","string"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/error/assert.js"],"sourcesContent":["// Copyright (C) 2019 Agoric, under Apache License 2.0\n// @ts-check\n\n// To ensure that this module operates without special privilege, it should\n// not reference the free variable `console` except for its own internal\n// debugging purposes in the declaration of `internalDebugConsole`, which is\n// normally commented out.\n\n// This module however has top level mutable state which is observable to code\n// given access to the `loggedErrorHandler`, such as the causal console\n// of `console.js`. However, for code that does not have such access, this\n// module should not be observably impure.\n\nimport {\n  RangeError,\n  TypeError,\n  WeakMap,\n  arrayJoin,\n  arrayMap,\n  arrayPop,\n  arrayPush,\n  assign,\n  freeze,\n  globalThis,\n  is,\n  isError,\n  stringIndexOf,\n  stringReplace,\n  stringSlice,\n  stringStartsWith,\n  weakmapDelete,\n  weakmapGet,\n  weakmapHas,\n  weakmapSet,\n} from '../commons.js';\nimport { an, bestEffortStringify } from './stringify-utils.js';\nimport './types.js';\nimport './internal-types.js';\n\n// For our internal debugging purposes, uncomment\n// const internalDebugConsole = console;\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/** @type {WeakMap<StringablePayload, any>} */\nconst declassifiers = new WeakMap();\n\n/** @type {AssertQuote} */\nconst quote = (payload, spaces = undefined) => {\n  const result = freeze({\n    toString: freeze(() => bestEffortStringify(payload, spaces)),\n  });\n  weakmapSet(declassifiers, result, payload);\n  return result;\n};\nfreeze(quote);\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {Object} HiddenDetails\n *\n * Captures the arguments passed to the `details` template string tag.\n *\n * @property {TemplateStringsArray | string[]} template\n * @property {any[]} args\n */\n\n/**\n * @type {WeakMap<DetailsToken, HiddenDetails>}\n *\n * Maps from a details token which a `details` template literal returned\n * to a record of the contents of that template literal expression.\n */\nconst hiddenDetailsMap = new WeakMap();\n\n/**\n * @param {HiddenDetails} hiddenDetails\n * @returns {string}\n */\nconst getMessageString = ({ template, args }) => {\n  const parts = [template[0]];\n  for (let i = 0; i < args.length; i += 1) {\n    const arg = args[i];\n    let argStr;\n    if (weakmapHas(declassifiers, arg)) {\n      argStr = `${arg}`;\n    } else if (isError(arg)) {\n      argStr = `(${an(arg.name)})`;\n    } else {\n      argStr = `(${an(typeof arg)})`;\n    }\n    arrayPush(parts, argStr, template[i + 1]);\n  }\n  return arrayJoin(parts, '');\n};\n\n/**\n * Give detailsTokens a toString behavior. To minimize the overhead of\n * creating new detailsTokens, we do this with an\n * inherited `this` sensitive `toString` method, even though we normally\n * avoid `this` sensitivity. To protect the method from inappropriate\n * `this` application, it does something interesting only for objects\n * registered in `redactedDetails`, which should be exactly the detailsTokens.\n *\n * The printing behavior must not reveal anything redacted, so we just use\n * the same `getMessageString` we use to construct the redacted message\n * string for a thrown assertion error.\n */\nconst DetailsTokenProto = freeze({\n  toString() {\n    const hiddenDetails = weakmapGet(hiddenDetailsMap, this);\n    if (hiddenDetails === undefined) {\n      return '[Not a DetailsToken]';\n    }\n    return getMessageString(hiddenDetails);\n  },\n});\nfreeze(DetailsTokenProto.toString);\n\n/**\n * Normally this is the function exported as `assert.details` and often\n * spelled `d`. However, if the `{errorTaming: 'unsafe'}` option is given to\n * `lockdown`, then `unredactedDetails` is used instead.\n *\n * There are some unconditional uses of `redactedDetails` in this module. All\n * of them should be uses where the template literal has no redacted\n * substitution values. In those cases, the two are equivalent.\n *\n * @type {DetailsTag}\n */\nconst redactedDetails = (template, ...args) => {\n  // Keep in mind that the vast majority of calls to `details` creates\n  // a details token that is never used, so this path must remain as fast as\n  // possible. Hence we store what we've got with little processing, postponing\n  // all the work to happen only if needed, for example, if an assertion fails.\n  const detailsToken = freeze({ __proto__: DetailsTokenProto });\n  weakmapSet(hiddenDetailsMap, detailsToken, { template, args });\n  return detailsToken;\n};\nfreeze(redactedDetails);\n\n/**\n * `unredactedDetails` is like `details` except that it does not redact\n * anything. It acts like `details` would act if all substitution values\n * were wrapped with the `quote` function above (the function normally\n * spelled `q`). If the `{errorTaming: 'unsafe'}` option is given to\n * `lockdown`, then the lockdown-shim arranges for the global `assert` to be\n * one whose `details` property is `unredactedDetails`.\n * This setting optimizes the debugging and testing experience at the price\n * of safety. `unredactedDetails` also sacrifices the speed of `details`,\n * which is usually fine in debugging and testing.\n *\n * @type {DetailsTag}\n */\nconst unredactedDetails = (template, ...args) => {\n  args = arrayMap(args, arg =>\n    weakmapHas(declassifiers, arg) ? arg : quote(arg),\n  );\n  return redactedDetails(template, ...args);\n};\nfreeze(unredactedDetails);\nexport { unredactedDetails };\n\n/**\n * @param {HiddenDetails} hiddenDetails\n * @returns {LogArgs}\n */\nconst getLogArgs = ({ template, args }) => {\n  const logArgs = [template[0]];\n  for (let i = 0; i < args.length; i += 1) {\n    let arg = args[i];\n    if (weakmapHas(declassifiers, arg)) {\n      arg = weakmapGet(declassifiers, arg);\n    }\n    // Remove the extra spaces (since console.error puts them\n    // between each cause).\n    const priorWithoutSpace = stringReplace(arrayPop(logArgs) || '', / $/, '');\n    if (priorWithoutSpace !== '') {\n      arrayPush(logArgs, priorWithoutSpace);\n    }\n    const nextWithoutSpace = stringReplace(template[i + 1], /^ /, '');\n    arrayPush(logArgs, arg, nextWithoutSpace);\n  }\n  if (logArgs[logArgs.length - 1] === '') {\n    arrayPop(logArgs);\n  }\n  return logArgs;\n};\n\n/**\n * @type {WeakMap<Error, LogArgs>}\n *\n * Maps from an error object to the log args that are a more informative\n * alternative message for that error. When logging the error, these\n * log args should be preferred to `error.message`.\n */\nconst hiddenMessageLogArgs = new WeakMap();\n\n// So each error tag will be unique.\nlet errorTagNum = 0;\n\n/**\n * @type {WeakMap<Error, string>}\n */\nconst errorTags = new WeakMap();\n\n/**\n * @param {Error} err\n * @param {string=} optErrorName\n * @returns {string}\n */\nconst tagError = (err, optErrorName = err.name) => {\n  let errorTag = weakmapGet(errorTags, err);\n  if (errorTag !== undefined) {\n    return errorTag;\n  }\n  errorTagNum += 1;\n  errorTag = `${optErrorName}#${errorTagNum}`;\n  weakmapSet(errorTags, err, errorTag);\n  return errorTag;\n};\n\n/**\n * @type {AssertMakeError}\n */\nconst makeError = (\n  optDetails = redactedDetails`Assert failed`,\n  ErrorConstructor = globalThis.Error,\n  { errorName = undefined } = {},\n) => {\n  if (typeof optDetails === 'string') {\n    // If it is a string, use it as the literal part of the template so\n    // it doesn't get quoted.\n    optDetails = redactedDetails([optDetails]);\n  }\n  const hiddenDetails = weakmapGet(hiddenDetailsMap, optDetails);\n  if (hiddenDetails === undefined) {\n    throw new TypeError(`unrecognized details ${quote(optDetails)}`);\n  }\n  const messageString = getMessageString(hiddenDetails);\n  const error = new ErrorConstructor(messageString);\n  weakmapSet(hiddenMessageLogArgs, error, getLogArgs(hiddenDetails));\n  if (errorName !== undefined) {\n    tagError(error, errorName);\n  }\n  // The next line is a particularly fruitful place to put a breakpoint.\n  return error;\n};\nfreeze(makeError);\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @type {WeakMap<Error, LogArgs[]>}\n *\n * Maps from an error to an array of log args, where each log args is\n * remembered as an annotation on that error. This can be used, for example,\n * to keep track of additional causes of the error. The elements of any\n * log args may include errors which are associated with further annotations.\n * An augmented console, like the causal console of `console.js`, could\n * then retrieve the graph of such annotations.\n */\nconst hiddenNoteLogArgsArrays = new WeakMap();\n\n/**\n * @type {WeakMap<Error, NoteCallback[]>}\n *\n * An augmented console will normally only take the hidden noteArgs array once,\n * when it logs the error being annotated. Once that happens, further\n * annotations of that error should go to the console immediately. We arrange\n * that by accepting a note-callback function from the console as an optional\n * part of that taking operation. Normally there will only be at most one\n * callback per error, but that depends on console behavior which we should not\n * assume. We make this an array of callbacks so multiple registrations\n * are independent.\n */\nconst hiddenNoteCallbackArrays = new WeakMap();\n\n/** @type {AssertNote} */\nconst note = (error, detailsNote) => {\n  if (typeof detailsNote === 'string') {\n    // If it is a string, use it as the literal part of the template so\n    // it doesn't get quoted.\n    detailsNote = redactedDetails([detailsNote]);\n  }\n  const hiddenDetails = weakmapGet(hiddenDetailsMap, detailsNote);\n  if (hiddenDetails === undefined) {\n    throw new TypeError(`unrecognized details ${quote(detailsNote)}`);\n  }\n  const logArgs = getLogArgs(hiddenDetails);\n  const callbacks = weakmapGet(hiddenNoteCallbackArrays, error);\n  if (callbacks !== undefined) {\n    for (const callback of callbacks) {\n      callback(error, logArgs);\n    }\n  } else {\n    const logArgsArray = weakmapGet(hiddenNoteLogArgsArrays, error);\n    if (logArgsArray !== undefined) {\n      arrayPush(logArgsArray, logArgs);\n    } else {\n      weakmapSet(hiddenNoteLogArgsArrays, error, [logArgs]);\n    }\n  }\n};\nfreeze(note);\n\n/**\n * The unprivileged form that just uses the de facto `error.stack` property.\n * The start compartment normally has a privileged `globalThis.getStackString`\n * which should be preferred if present.\n *\n * @param {Error} error\n * @returns {string}\n */\nconst defaultGetStackString = error => {\n  if (!('stack' in error)) {\n    return '';\n  }\n  const stackString = `${error.stack}`;\n  const pos = stringIndexOf(stackString, '\\n');\n  if (stringStartsWith(stackString, ' ') || pos === -1) {\n    return stackString;\n  }\n  return stringSlice(stackString, pos + 1); // exclude the initial newline\n};\n\n/** @type {LoggedErrorHandler} */\nconst loggedErrorHandler = {\n  getStackString: globalThis.getStackString || defaultGetStackString,\n  tagError: error => tagError(error),\n  resetErrorTagNum: () => {\n    errorTagNum = 0;\n  },\n  getMessageLogArgs: error => weakmapGet(hiddenMessageLogArgs, error),\n  takeMessageLogArgs: error => {\n    const result = weakmapGet(hiddenMessageLogArgs, error);\n    weakmapDelete(hiddenMessageLogArgs, error);\n    return result;\n  },\n  takeNoteLogArgsArray: (error, callback) => {\n    const result = weakmapGet(hiddenNoteLogArgsArrays, error);\n    weakmapDelete(hiddenNoteLogArgsArrays, error);\n    if (callback !== undefined) {\n      const callbacks = weakmapGet(hiddenNoteCallbackArrays, error);\n      if (callbacks) {\n        arrayPush(callbacks, callback);\n      } else {\n        weakmapSet(hiddenNoteCallbackArrays, error, [callback]);\n      }\n    }\n    return result || [];\n  },\n};\nfreeze(loggedErrorHandler);\nexport { loggedErrorHandler };\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @type {MakeAssert}\n */\nconst makeAssert = (optRaise = undefined, unredacted = false) => {\n  const details = unredacted ? unredactedDetails : redactedDetails;\n  /** @type {AssertFail} */\n  const fail = (\n    optDetails = details`Assert failed`,\n    ErrorConstructor = globalThis.Error,\n  ) => {\n    const reason = makeError(optDetails, ErrorConstructor);\n    if (optRaise !== undefined) {\n      optRaise(reason);\n    }\n    throw reason;\n  };\n  freeze(fail);\n\n  // Don't freeze or export `baseAssert` until we add methods.\n  // TODO If I change this from a `function` function to an arrow\n  // function, I seem to get type errors from TypeScript. Why?\n  /** @type {BaseAssert} */\n  function baseAssert(\n    flag,\n    optDetails = details`Check failed`,\n    ErrorConstructor = globalThis.Error,\n  ) {\n    if (!flag) {\n      throw fail(optDetails, ErrorConstructor);\n    }\n  }\n\n  /** @type {AssertEqual} */\n  const equal = (\n    actual,\n    expected,\n    optDetails = details`Expected ${actual} is same as ${expected}`,\n    ErrorConstructor = RangeError,\n  ) => {\n    baseAssert(is(actual, expected), optDetails, ErrorConstructor);\n  };\n  freeze(equal);\n\n  /** @type {AssertTypeof} */\n  const assertTypeof = (specimen, typename, optDetails) => {\n    baseAssert(\n      typeof typename === 'string',\n      details`${quote(typename)} must be a string`,\n    );\n    if (optDetails === undefined) {\n      // Like\n      // ```js\n      // optDetails = details`${specimen} must be ${quote(an(typename))}`;\n      // ```\n      // except it puts the typename into the literal part of the template\n      // so it doesn't get quoted.\n      optDetails = details(['', ` must be ${an(typename)}`], specimen);\n    }\n    equal(typeof specimen, typename, optDetails, TypeError);\n  };\n  freeze(assertTypeof);\n\n  /** @type {AssertString} */\n  const assertString = (specimen, optDetails) =>\n    assertTypeof(specimen, 'string', optDetails);\n\n  // Note that \"assert === baseAssert\"\n  /** @type {Assert} */\n  const assert = assign(baseAssert, {\n    error: makeError,\n    fail,\n    equal,\n    typeof: assertTypeof,\n    string: assertString,\n    note,\n    details,\n    quote,\n    makeAssert,\n  });\n  return freeze(assert);\n};\nfreeze(makeAssert);\nexport { makeAssert };\n\n/** @type {Assert} */\nconst assert = makeAssert();\nexport { assert };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}