{"ast":null,"code":"// @ts-check\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  ownKeys\n} = Reflect;\n/**\n * The well known symbols are static symbol values on the `Symbol` constructor.\n */\n\nconst wellKnownSymbolNames = new Map(ownKeys(Symbol).filter(name => typeof name === 'string' && typeof Symbol[name] === 'symbol').filter(name => {\n  assert( // @ts-ignore It doesn't know name cannot be a symbol\n  !name.startsWith('@@'), X`Did not expect Symbol to have a symbol-valued property name starting with \"@@\" ${q(name)}`);\n  return true;\n}) // @ts-ignore It doesn't know name cannot be a symbol\n.map(name => [Symbol[name], `@@${name}`]));\n/**\n * The passable symbols are the well known symbols (the symbol values\n * of static properties of the `Symbol` constructor) and the registered\n * symbols.\n *\n * @param {any} sym\n * @returns {boolean}\n */\n\nexport const isPassableSymbol = sym => typeof sym === 'symbol' && (typeof Symbol.keyFor(sym) === 'string' || wellKnownSymbolNames.has(sym));\nharden(isPassableSymbol);\nexport const assertPassableSymbol = sym => assert(isPassableSymbol(sym), X`Only registered symbols or well-known symbols are passable: ${q(sym)}`);\nharden(assertPassableSymbol);\n/**\n * If `sym` is a passable symbol, return a string that uniquely identifies this\n * symbol. If `sym` is a non-passable symbol, return `undefined`.\n *\n * The passable symbols are the well known symbols (the symbol values\n * of static properties of the `Symbol` constructor) and the registered\n * symbols. Since the registration string of a registered symbol can be any\n * string, if we simply used that to identify those symbols, there would not\n * be any remaining strings left over to identify the well-known symbols.\n * Instead, we reserve strings beginning with `\"@@\"` for purposes of this\n * encoding. We identify a well known symbol such as `Symbol.iterator`\n * by prefixing the property name with `\"@@\"`, such as `\"@@iterator\"`.\n * For registered symbols whose name happens to begin with `\"@@\"`, such\n * as `Symbol.for('@@iterator')` or `Symbol.for('@@foo')`, we identify\n * them by prefixing them with an extra `\"@@\"`, such as\n * `\"@@@@iterator\"` or `\"@@@@foo\"`. (This is the Hilbert Hotel encoding\n * technique.)\n *\n * @param {symbol} sym\n * @returns {string=}\n */\n\nexport const nameForPassableSymbol = sym => {\n  const name = Symbol.keyFor(sym);\n\n  if (name === undefined) {\n    return wellKnownSymbolNames.get(sym);\n  }\n\n  if (name.startsWith('@@')) {\n    return `@@${name}`;\n  }\n\n  return name;\n};\nharden(nameForPassableSymbol);\nexport const AtAtPrefixPattern = /^@@(.*)$/;\nharden(AtAtPrefixPattern);\n/**\n * If `name` is a string that could have been produced by\n * `nameForPassableSymbol`, return the symbol argument it was produced to\n * represent.\n *\n *    If `name` does not begin with `\"@@\"`, then just the corresponding\n *      registered symbol, `Symbol.for(name)`.\n *    If `name` is `\"@@\"` followed by a well known symbol's property name on\n *      `Symbol` such `\"@@iterator\", return that well known symbol such as\n *      `Symbol.iterator`\n *    If `name` begins with `\"@@@@\"` it encodes the registered symbol whose\n *      name begins with `\"@@\"` instead.\n *    Otherwise, if name begins with `\"@@\"` it may encode a registered symbol\n *      from a future version of JavaScript, but it is not one we can decode\n *      yet, so throw.\n *\n * @param {string} name\n * @returns {symbol=}\n */\n\nexport const passableSymbolForName = name => {\n  if (typeof name !== 'string') {\n    return undefined;\n  }\n\n  const match = AtAtPrefixPattern.exec(name);\n\n  if (match) {\n    const suffix = match[1];\n\n    if (suffix.startsWith('@@')) {\n      return Symbol.for(suffix);\n    } else {\n      const sym = Symbol[suffix];\n\n      if (typeof sym === 'symbol') {\n        return sym;\n      }\n\n      assert.fail(X`Reserved for well known symbol ${q(suffix)}: ${q(name)}`);\n    }\n  }\n\n  return Symbol.for(name);\n};\nharden(passableSymbolForName);","map":{"version":3,"names":["details","X","quote","q","assert","ownKeys","Reflect","wellKnownSymbolNames","Map","Symbol","filter","name","startsWith","map","isPassableSymbol","sym","keyFor","has","harden","assertPassableSymbol","nameForPassableSymbol","undefined","get","AtAtPrefixPattern","passableSymbolForName","match","exec","suffix","for","fail"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/helpers/symbol.js"],"sourcesContent":["// @ts-check\n\nconst { details: X, quote: q } = assert;\nconst { ownKeys } = Reflect;\n\n/**\n * The well known symbols are static symbol values on the `Symbol` constructor.\n */\nconst wellKnownSymbolNames = new Map(\n  ownKeys(Symbol)\n    .filter(\n      name => typeof name === 'string' && typeof Symbol[name] === 'symbol',\n    )\n    .filter(name => {\n      assert(\n        // @ts-ignore It doesn't know name cannot be a symbol\n        !name.startsWith('@@'),\n        X`Did not expect Symbol to have a symbol-valued property name starting with \"@@\" ${q(\n          name,\n        )}`,\n      );\n      return true;\n    })\n    // @ts-ignore It doesn't know name cannot be a symbol\n    .map(name => [Symbol[name], `@@${name}`]),\n);\n\n/**\n * The passable symbols are the well known symbols (the symbol values\n * of static properties of the `Symbol` constructor) and the registered\n * symbols.\n *\n * @param {any} sym\n * @returns {boolean}\n */\nexport const isPassableSymbol = sym =>\n  typeof sym === 'symbol' &&\n  (typeof Symbol.keyFor(sym) === 'string' || wellKnownSymbolNames.has(sym));\nharden(isPassableSymbol);\n\nexport const assertPassableSymbol = sym =>\n  assert(\n    isPassableSymbol(sym),\n    X`Only registered symbols or well-known symbols are passable: ${q(sym)}`,\n  );\nharden(assertPassableSymbol);\n\n/**\n * If `sym` is a passable symbol, return a string that uniquely identifies this\n * symbol. If `sym` is a non-passable symbol, return `undefined`.\n *\n * The passable symbols are the well known symbols (the symbol values\n * of static properties of the `Symbol` constructor) and the registered\n * symbols. Since the registration string of a registered symbol can be any\n * string, if we simply used that to identify those symbols, there would not\n * be any remaining strings left over to identify the well-known symbols.\n * Instead, we reserve strings beginning with `\"@@\"` for purposes of this\n * encoding. We identify a well known symbol such as `Symbol.iterator`\n * by prefixing the property name with `\"@@\"`, such as `\"@@iterator\"`.\n * For registered symbols whose name happens to begin with `\"@@\"`, such\n * as `Symbol.for('@@iterator')` or `Symbol.for('@@foo')`, we identify\n * them by prefixing them with an extra `\"@@\"`, such as\n * `\"@@@@iterator\"` or `\"@@@@foo\"`. (This is the Hilbert Hotel encoding\n * technique.)\n *\n * @param {symbol} sym\n * @returns {string=}\n */\nexport const nameForPassableSymbol = sym => {\n  const name = Symbol.keyFor(sym);\n  if (name === undefined) {\n    return wellKnownSymbolNames.get(sym);\n  }\n  if (name.startsWith('@@')) {\n    return `@@${name}`;\n  }\n  return name;\n};\nharden(nameForPassableSymbol);\n\nexport const AtAtPrefixPattern = /^@@(.*)$/;\nharden(AtAtPrefixPattern);\n\n/**\n * If `name` is a string that could have been produced by\n * `nameForPassableSymbol`, return the symbol argument it was produced to\n * represent.\n *\n *    If `name` does not begin with `\"@@\"`, then just the corresponding\n *      registered symbol, `Symbol.for(name)`.\n *    If `name` is `\"@@\"` followed by a well known symbol's property name on\n *      `Symbol` such `\"@@iterator\", return that well known symbol such as\n *      `Symbol.iterator`\n *    If `name` begins with `\"@@@@\"` it encodes the registered symbol whose\n *      name begins with `\"@@\"` instead.\n *    Otherwise, if name begins with `\"@@\"` it may encode a registered symbol\n *      from a future version of JavaScript, but it is not one we can decode\n *      yet, so throw.\n *\n * @param {string} name\n * @returns {symbol=}\n */\nexport const passableSymbolForName = name => {\n  if (typeof name !== 'string') {\n    return undefined;\n  }\n  const match = AtAtPrefixPattern.exec(name);\n  if (match) {\n    const suffix = match[1];\n    if (suffix.startsWith('@@')) {\n      return Symbol.for(suffix);\n    } else {\n      const sym = Symbol[suffix];\n      if (typeof sym === 'symbol') {\n        return sym;\n      }\n      assert.fail(X`Reserved for well known symbol ${q(suffix)}: ${q(name)}`);\n    }\n  }\n  return Symbol.for(name);\n};\nharden(passableSymbolForName);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}