{"ast":null,"code":"// For brevity, in this file, as in module-link.js, the term \"moduleRecord\"\n// without qualification means \"module compartment record\".\n// This is a super-set of the \"static module record\", that is reusable between\n// compartments with different hooks.\n// The \"module compartment record\" captures the compartment and overlays the\n// module's \"imports\" with the more specific \"resolvedImports\" as inferred from\n// the particular compartment's \"resolveHook\".\nimport { ReferenceError, TypeError, Map, Set, arrayJoin, arrayMap, arrayPush, create, freeze, mapGet, mapHas, mapSet, setAdd, promiseCatch, promiseThen, values, weakmapGet } from './commons.js';\nimport { assert } from './error/assert.js';\nconst {\n  details: d,\n  quote: q\n} = assert;\n\nconst noop = () => {}; // `makeAlias` constructs compartment specifier tuples for the `aliases`\n// private field of compartments.\n// These aliases allow a compartment to alias an internal module specifier to a\n// module specifier in an external compartment, and also to create internal\n// aliases.\n// Both are facilitated by the moduleMap Compartment constructor option.\n\n\nexport const makeAlias = (compartment, specifier) => freeze({\n  compartment,\n  specifier\n}); // `resolveAll` pre-computes resolutions of all imports within the compartment\n// in which a module was loaded.\n\nconst resolveAll = (imports, resolveHook, fullReferrerSpecifier) => {\n  const resolvedImports = create(null);\n\n  for (const importSpecifier of imports) {\n    const fullSpecifier = resolveHook(importSpecifier, fullReferrerSpecifier);\n    resolvedImports[importSpecifier] = fullSpecifier;\n  }\n\n  return freeze(resolvedImports);\n};\n\nconst loadRecord = async (compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, staticModuleRecord, pendingJobs, moduleLoads, errors) => {\n  const {\n    resolveHook,\n    moduleRecords\n  } = weakmapGet(compartmentPrivateFields, compartment); // resolve all imports relative to this referrer module.\n\n  const resolvedImports = resolveAll(staticModuleRecord.imports, resolveHook, moduleSpecifier);\n  const moduleRecord = freeze({\n    compartment,\n    staticModuleRecord,\n    moduleSpecifier,\n    resolvedImports\n  }); // Enqueue jobs to load this module's shallow dependencies.\n\n  for (const fullSpecifier of values(resolvedImports)) {\n    // Behold: recursion.\n    // eslint-disable-next-line no-use-before-define\n    const dependencyLoaded = memoizedLoadWithErrorAnnotation(compartmentPrivateFields, moduleAliases, compartment, fullSpecifier, pendingJobs, moduleLoads, errors);\n    setAdd(pendingJobs, promiseThen(dependencyLoaded, noop, error => {\n      arrayPush(errors, error);\n    }));\n  } // Memoize.\n\n\n  mapSet(moduleRecords, moduleSpecifier, moduleRecord);\n  return moduleRecord;\n};\n\nconst loadWithoutErrorAnnotation = async (compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, pendingJobs, moduleLoads, errors) => {\n  const {\n    importHook,\n    moduleMap,\n    moduleMapHook,\n    moduleRecords\n  } = weakmapGet(compartmentPrivateFields, compartment); // Follow moduleMap, or moduleMapHook if present.\n\n  let aliasNamespace = moduleMap[moduleSpecifier];\n\n  if (aliasNamespace === undefined && moduleMapHook !== undefined) {\n    aliasNamespace = moduleMapHook(moduleSpecifier);\n  }\n\n  if (typeof aliasNamespace === 'string') {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.fail(d`Cannot map module ${q(moduleSpecifier)} to ${q(aliasNamespace)} in parent compartment, not yet implemented`, TypeError);\n  } else if (aliasNamespace !== undefined) {\n    const alias = weakmapGet(moduleAliases, aliasNamespace);\n\n    if (alias === undefined) {\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      assert.fail(d`Cannot map module ${q(moduleSpecifier)} because the value is not a module exports namespace, or is from another realm`, ReferenceError);\n    } // Behold: recursion.\n    // eslint-disable-next-line no-use-before-define\n\n\n    const aliasRecord = await memoizedLoadWithErrorAnnotation(compartmentPrivateFields, moduleAliases, alias.compartment, alias.specifier, pendingJobs, moduleLoads, errors);\n    mapSet(moduleRecords, moduleSpecifier, aliasRecord);\n    return aliasRecord;\n  }\n\n  if (mapHas(moduleRecords, moduleSpecifier)) {\n    return mapGet(moduleRecords, moduleSpecifier);\n  }\n\n  const staticModuleRecord = await importHook(moduleSpecifier);\n\n  if (staticModuleRecord === null || typeof staticModuleRecord !== 'object') {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.fail(d`importHook must return a promise for an object, for module ${q(moduleSpecifier)} in compartment ${q(compartment.name)}`);\n  }\n\n  if (staticModuleRecord.record !== undefined) {\n    const {\n      compartment: aliasCompartment = compartment,\n      specifier: aliasSpecifier = moduleSpecifier,\n      record: aliasModuleRecord\n    } = staticModuleRecord;\n    const aliasRecord = await loadRecord(compartmentPrivateFields, moduleAliases, aliasCompartment, aliasSpecifier, aliasModuleRecord, pendingJobs, moduleLoads, errors);\n    mapSet(moduleRecords, moduleSpecifier, aliasRecord);\n    return aliasRecord;\n  }\n\n  return loadRecord(compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, staticModuleRecord, pendingJobs, moduleLoads, errors);\n};\n\nconst memoizedLoadWithErrorAnnotation = async (compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, pendingJobs, moduleLoads, errors) => {\n  const {\n    name: compartmentName\n  } = weakmapGet(compartmentPrivateFields, compartment); // Prevent data-lock from recursion into branches visited in dependent loads.\n\n  let compartmentLoading = mapGet(moduleLoads, compartment);\n\n  if (compartmentLoading === undefined) {\n    compartmentLoading = new Map();\n    mapSet(moduleLoads, compartment, compartmentLoading);\n  }\n\n  let moduleLoading = mapGet(compartmentLoading, moduleSpecifier);\n\n  if (moduleLoading !== undefined) {\n    return moduleLoading;\n  }\n\n  moduleLoading = promiseCatch(loadWithoutErrorAnnotation(compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, pendingJobs, moduleLoads, errors), error => {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.note(error, d`${error.message}, loading ${q(moduleSpecifier)} in compartment ${q(compartmentName)}`);\n    throw error;\n  });\n  mapSet(compartmentLoading, moduleSpecifier, moduleLoading);\n  return moduleLoading;\n};\n/*\n * `load` asynchronously gathers the `StaticModuleRecord`s for a module and its\n * transitive dependencies.\n * The module records refer to each other by a reference to the dependency's\n * compartment and the specifier of the module within its own compartment.\n * This graph is then ready to be synchronously linked and executed.\n */\n\n\nexport const load = async (compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier) => {\n  const {\n    name: compartmentName\n  } = weakmapGet(compartmentPrivateFields, compartment);\n  /** @type {Set<Promise<undefined>>} */\n\n  const pendingJobs = new Set();\n  /** @type {Map<Object, Map<string, Promise<Record>>} */\n\n  const moduleLoads = new Map();\n  /** @type {Array<Error>} */\n\n  const errors = [];\n  const dependencyLoaded = memoizedLoadWithErrorAnnotation(compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier, pendingJobs, moduleLoads, errors);\n  setAdd(pendingJobs, promiseThen(dependencyLoaded, noop, error => {\n    arrayPush(errors, error);\n  })); // Drain pending jobs queue.\n  // Each job is a promise for undefined, regardless of success or failure.\n  // Before we add a job to the queue, we catch any error and push it into the\n  // `errors` accumulator.\n\n  for (const job of pendingJobs) {\n    // eslint-disable-next-line no-await-in-loop\n    await job;\n  } // Throw an aggregate error if there were any errors.\n\n\n  if (errors.length > 0) {\n    throw new TypeError(`Failed to load module ${q(moduleSpecifier)} in package ${q(compartmentName)} (${errors.length} underlying failures: ${arrayJoin(arrayMap(errors, error => error.message), ', ')}`);\n  }\n};","map":{"version":3,"names":["ReferenceError","TypeError","Map","Set","arrayJoin","arrayMap","arrayPush","create","freeze","mapGet","mapHas","mapSet","setAdd","promiseCatch","promiseThen","values","weakmapGet","assert","details","d","quote","q","noop","makeAlias","compartment","specifier","resolveAll","imports","resolveHook","fullReferrerSpecifier","resolvedImports","importSpecifier","fullSpecifier","loadRecord","compartmentPrivateFields","moduleAliases","moduleSpecifier","staticModuleRecord","pendingJobs","moduleLoads","errors","moduleRecords","moduleRecord","dependencyLoaded","memoizedLoadWithErrorAnnotation","error","loadWithoutErrorAnnotation","importHook","moduleMap","moduleMapHook","aliasNamespace","undefined","fail","alias","aliasRecord","name","record","aliasCompartment","aliasSpecifier","aliasModuleRecord","compartmentName","compartmentLoading","moduleLoading","note","message","load","job","length"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/module-load.js"],"sourcesContent":["// For brevity, in this file, as in module-link.js, the term \"moduleRecord\"\n// without qualification means \"module compartment record\".\n// This is a super-set of the \"static module record\", that is reusable between\n// compartments with different hooks.\n// The \"module compartment record\" captures the compartment and overlays the\n// module's \"imports\" with the more specific \"resolvedImports\" as inferred from\n// the particular compartment's \"resolveHook\".\n\nimport {\n  ReferenceError,\n  TypeError,\n  Map,\n  Set,\n  arrayJoin,\n  arrayMap,\n  arrayPush,\n  create,\n  freeze,\n  mapGet,\n  mapHas,\n  mapSet,\n  setAdd,\n  promiseCatch,\n  promiseThen,\n  values,\n  weakmapGet,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\nconst { details: d, quote: q } = assert;\n\nconst noop = () => {};\n\n// `makeAlias` constructs compartment specifier tuples for the `aliases`\n// private field of compartments.\n// These aliases allow a compartment to alias an internal module specifier to a\n// module specifier in an external compartment, and also to create internal\n// aliases.\n// Both are facilitated by the moduleMap Compartment constructor option.\nexport const makeAlias = (compartment, specifier) =>\n  freeze({\n    compartment,\n    specifier,\n  });\n\n// `resolveAll` pre-computes resolutions of all imports within the compartment\n// in which a module was loaded.\nconst resolveAll = (imports, resolveHook, fullReferrerSpecifier) => {\n  const resolvedImports = create(null);\n  for (const importSpecifier of imports) {\n    const fullSpecifier = resolveHook(importSpecifier, fullReferrerSpecifier);\n    resolvedImports[importSpecifier] = fullSpecifier;\n  }\n  return freeze(resolvedImports);\n};\n\nconst loadRecord = async (\n  compartmentPrivateFields,\n  moduleAliases,\n  compartment,\n  moduleSpecifier,\n  staticModuleRecord,\n  pendingJobs,\n  moduleLoads,\n  errors,\n) => {\n  const { resolveHook, moduleRecords } = weakmapGet(\n    compartmentPrivateFields,\n    compartment,\n  );\n\n  // resolve all imports relative to this referrer module.\n  const resolvedImports = resolveAll(\n    staticModuleRecord.imports,\n    resolveHook,\n    moduleSpecifier,\n  );\n  const moduleRecord = freeze({\n    compartment,\n    staticModuleRecord,\n    moduleSpecifier,\n    resolvedImports,\n  });\n\n  // Enqueue jobs to load this module's shallow dependencies.\n  for (const fullSpecifier of values(resolvedImports)) {\n    // Behold: recursion.\n    // eslint-disable-next-line no-use-before-define\n    const dependencyLoaded = memoizedLoadWithErrorAnnotation(\n      compartmentPrivateFields,\n      moduleAliases,\n      compartment,\n      fullSpecifier,\n      pendingJobs,\n      moduleLoads,\n      errors,\n    );\n    setAdd(\n      pendingJobs,\n      promiseThen(dependencyLoaded, noop, error => {\n        arrayPush(errors, error);\n      }),\n    );\n  }\n\n  // Memoize.\n  mapSet(moduleRecords, moduleSpecifier, moduleRecord);\n  return moduleRecord;\n};\n\nconst loadWithoutErrorAnnotation = async (\n  compartmentPrivateFields,\n  moduleAliases,\n  compartment,\n  moduleSpecifier,\n  pendingJobs,\n  moduleLoads,\n  errors,\n) => {\n  const { importHook, moduleMap, moduleMapHook, moduleRecords } = weakmapGet(\n    compartmentPrivateFields,\n    compartment,\n  );\n\n  // Follow moduleMap, or moduleMapHook if present.\n  let aliasNamespace = moduleMap[moduleSpecifier];\n  if (aliasNamespace === undefined && moduleMapHook !== undefined) {\n    aliasNamespace = moduleMapHook(moduleSpecifier);\n  }\n  if (typeof aliasNamespace === 'string') {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.fail(\n      d`Cannot map module ${q(moduleSpecifier)} to ${q(\n        aliasNamespace,\n      )} in parent compartment, not yet implemented`,\n      TypeError,\n    );\n  } else if (aliasNamespace !== undefined) {\n    const alias = weakmapGet(moduleAliases, aliasNamespace);\n    if (alias === undefined) {\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      assert.fail(\n        d`Cannot map module ${q(\n          moduleSpecifier,\n        )} because the value is not a module exports namespace, or is from another realm`,\n        ReferenceError,\n      );\n    }\n    // Behold: recursion.\n    // eslint-disable-next-line no-use-before-define\n    const aliasRecord = await memoizedLoadWithErrorAnnotation(\n      compartmentPrivateFields,\n      moduleAliases,\n      alias.compartment,\n      alias.specifier,\n      pendingJobs,\n      moduleLoads,\n      errors,\n    );\n    mapSet(moduleRecords, moduleSpecifier, aliasRecord);\n    return aliasRecord;\n  }\n\n  if (mapHas(moduleRecords, moduleSpecifier)) {\n    return mapGet(moduleRecords, moduleSpecifier);\n  }\n\n  const staticModuleRecord = await importHook(moduleSpecifier);\n\n  if (staticModuleRecord === null || typeof staticModuleRecord !== 'object') {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.fail(\n      d`importHook must return a promise for an object, for module ${q(\n        moduleSpecifier,\n      )} in compartment ${q(compartment.name)}`,\n    );\n  }\n\n  if (staticModuleRecord.record !== undefined) {\n    const {\n      compartment: aliasCompartment = compartment,\n      specifier: aliasSpecifier = moduleSpecifier,\n      record: aliasModuleRecord,\n    } = staticModuleRecord;\n\n    const aliasRecord = await loadRecord(\n      compartmentPrivateFields,\n      moduleAliases,\n      aliasCompartment,\n      aliasSpecifier,\n      aliasModuleRecord,\n      pendingJobs,\n      moduleLoads,\n      errors,\n    );\n    mapSet(moduleRecords, moduleSpecifier, aliasRecord);\n    return aliasRecord;\n  }\n\n  return loadRecord(\n    compartmentPrivateFields,\n    moduleAliases,\n    compartment,\n    moduleSpecifier,\n    staticModuleRecord,\n    pendingJobs,\n    moduleLoads,\n    errors,\n  );\n};\n\nconst memoizedLoadWithErrorAnnotation = async (\n  compartmentPrivateFields,\n  moduleAliases,\n  compartment,\n  moduleSpecifier,\n  pendingJobs,\n  moduleLoads,\n  errors,\n) => {\n  const { name: compartmentName } = weakmapGet(\n    compartmentPrivateFields,\n    compartment,\n  );\n\n  // Prevent data-lock from recursion into branches visited in dependent loads.\n  let compartmentLoading = mapGet(moduleLoads, compartment);\n  if (compartmentLoading === undefined) {\n    compartmentLoading = new Map();\n    mapSet(moduleLoads, compartment, compartmentLoading);\n  }\n  let moduleLoading = mapGet(compartmentLoading, moduleSpecifier);\n  if (moduleLoading !== undefined) {\n    return moduleLoading;\n  }\n\n  moduleLoading = promiseCatch(\n    loadWithoutErrorAnnotation(\n      compartmentPrivateFields,\n      moduleAliases,\n      compartment,\n      moduleSpecifier,\n      pendingJobs,\n      moduleLoads,\n      errors,\n    ),\n    error => {\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      assert.note(\n        error,\n        d`${error.message}, loading ${q(moduleSpecifier)} in compartment ${q(\n          compartmentName,\n        )}`,\n      );\n      throw error;\n    },\n  );\n\n  mapSet(compartmentLoading, moduleSpecifier, moduleLoading);\n\n  return moduleLoading;\n};\n\n/*\n * `load` asynchronously gathers the `StaticModuleRecord`s for a module and its\n * transitive dependencies.\n * The module records refer to each other by a reference to the dependency's\n * compartment and the specifier of the module within its own compartment.\n * This graph is then ready to be synchronously linked and executed.\n */\nexport const load = async (\n  compartmentPrivateFields,\n  moduleAliases,\n  compartment,\n  moduleSpecifier,\n) => {\n  const { name: compartmentName } = weakmapGet(\n    compartmentPrivateFields,\n    compartment,\n  );\n\n  /** @type {Set<Promise<undefined>>} */\n  const pendingJobs = new Set();\n  /** @type {Map<Object, Map<string, Promise<Record>>} */\n  const moduleLoads = new Map();\n  /** @type {Array<Error>} */\n  const errors = [];\n\n  const dependencyLoaded = memoizedLoadWithErrorAnnotation(\n    compartmentPrivateFields,\n    moduleAliases,\n    compartment,\n    moduleSpecifier,\n    pendingJobs,\n    moduleLoads,\n    errors,\n  );\n  setAdd(\n    pendingJobs,\n    promiseThen(dependencyLoaded, noop, error => {\n      arrayPush(errors, error);\n    }),\n  );\n\n  // Drain pending jobs queue.\n  // Each job is a promise for undefined, regardless of success or failure.\n  // Before we add a job to the queue, we catch any error and push it into the\n  // `errors` accumulator.\n  for (const job of pendingJobs) {\n    // eslint-disable-next-line no-await-in-loop\n    await job;\n  }\n\n  // Throw an aggregate error if there were any errors.\n  if (errors.length > 0) {\n    throw new TypeError(\n      `Failed to load module ${q(moduleSpecifier)} in package ${q(\n        compartmentName,\n      )} (${errors.length} underlying failures: ${arrayJoin(\n        arrayMap(errors, error => error.message),\n        ', ',\n      )}`,\n    );\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SACEA,cADF,EAEEC,SAFF,EAGEC,GAHF,EAIEC,GAJF,EAKEC,SALF,EAMEC,QANF,EAOEC,SAPF,EAQEC,MARF,EASEC,MATF,EAUEC,MAVF,EAWEC,MAXF,EAYEC,MAZF,EAaEC,MAbF,EAcEC,YAdF,EAeEC,WAfF,EAgBEC,MAhBF,EAiBEC,UAjBF,QAkBO,cAlBP;AAmBA,SAASC,MAAT,QAAuB,mBAAvB;AAEA,MAAM;EAAEC,OAAO,EAAEC,CAAX;EAAcC,KAAK,EAAEC;AAArB,IAA2BJ,MAAjC;;AAEA,MAAMK,IAAI,GAAG,MAAM,CAAE,CAArB,C,CAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMC,SAAS,GAAG,CAACC,WAAD,EAAcC,SAAd,KACvBjB,MAAM,CAAC;EACLgB,WADK;EAELC;AAFK,CAAD,CADD,C,CAMP;AACA;;AACA,MAAMC,UAAU,GAAG,CAACC,OAAD,EAAUC,WAAV,EAAuBC,qBAAvB,KAAiD;EAClE,MAAMC,eAAe,GAAGvB,MAAM,CAAC,IAAD,CAA9B;;EACA,KAAK,MAAMwB,eAAX,IAA8BJ,OAA9B,EAAuC;IACrC,MAAMK,aAAa,GAAGJ,WAAW,CAACG,eAAD,EAAkBF,qBAAlB,CAAjC;IACAC,eAAe,CAACC,eAAD,CAAf,GAAmCC,aAAnC;EACD;;EACD,OAAOxB,MAAM,CAACsB,eAAD,CAAb;AACD,CAPD;;AASA,MAAMG,UAAU,GAAG,OACjBC,wBADiB,EAEjBC,aAFiB,EAGjBX,WAHiB,EAIjBY,eAJiB,EAKjBC,kBALiB,EAMjBC,WANiB,EAOjBC,WAPiB,EAQjBC,MARiB,KASd;EACH,MAAM;IAAEZ,WAAF;IAAea;EAAf,IAAiCzB,UAAU,CAC/CkB,wBAD+C,EAE/CV,WAF+C,CAAjD,CADG,CAMH;;EACA,MAAMM,eAAe,GAAGJ,UAAU,CAChCW,kBAAkB,CAACV,OADa,EAEhCC,WAFgC,EAGhCQ,eAHgC,CAAlC;EAKA,MAAMM,YAAY,GAAGlC,MAAM,CAAC;IAC1BgB,WAD0B;IAE1Ba,kBAF0B;IAG1BD,eAH0B;IAI1BN;EAJ0B,CAAD,CAA3B,CAZG,CAmBH;;EACA,KAAK,MAAME,aAAX,IAA4BjB,MAAM,CAACe,eAAD,CAAlC,EAAqD;IACnD;IACA;IACA,MAAMa,gBAAgB,GAAGC,+BAA+B,CACtDV,wBADsD,EAEtDC,aAFsD,EAGtDX,WAHsD,EAItDQ,aAJsD,EAKtDM,WALsD,EAMtDC,WANsD,EAOtDC,MAPsD,CAAxD;IASA5B,MAAM,CACJ0B,WADI,EAEJxB,WAAW,CAAC6B,gBAAD,EAAmBrB,IAAnB,EAAyBuB,KAAK,IAAI;MAC3CvC,SAAS,CAACkC,MAAD,EAASK,KAAT,CAAT;IACD,CAFU,CAFP,CAAN;EAMD,CAtCE,CAwCH;;;EACAlC,MAAM,CAAC8B,aAAD,EAAgBL,eAAhB,EAAiCM,YAAjC,CAAN;EACA,OAAOA,YAAP;AACD,CApDD;;AAsDA,MAAMI,0BAA0B,GAAG,OACjCZ,wBADiC,EAEjCC,aAFiC,EAGjCX,WAHiC,EAIjCY,eAJiC,EAKjCE,WALiC,EAMjCC,WANiC,EAOjCC,MAPiC,KAQ9B;EACH,MAAM;IAAEO,UAAF;IAAcC,SAAd;IAAyBC,aAAzB;IAAwCR;EAAxC,IAA0DzB,UAAU,CACxEkB,wBADwE,EAExEV,WAFwE,CAA1E,CADG,CAMH;;EACA,IAAI0B,cAAc,GAAGF,SAAS,CAACZ,eAAD,CAA9B;;EACA,IAAIc,cAAc,KAAKC,SAAnB,IAAgCF,aAAa,KAAKE,SAAtD,EAAiE;IAC/DD,cAAc,GAAGD,aAAa,CAACb,eAAD,CAA9B;EACD;;EACD,IAAI,OAAOc,cAAP,KAA0B,QAA9B,EAAwC;IACtC;IACAjC,MAAM,CAACmC,IAAP,CACEjC,CAAE,qBAAoBE,CAAC,CAACe,eAAD,CAAkB,OAAMf,CAAC,CAC9C6B,cAD8C,CAE9C,6CAHJ,EAIEjD,SAJF;EAMD,CARD,MAQO,IAAIiD,cAAc,KAAKC,SAAvB,EAAkC;IACvC,MAAME,KAAK,GAAGrC,UAAU,CAACmB,aAAD,EAAgBe,cAAhB,CAAxB;;IACA,IAAIG,KAAK,KAAKF,SAAd,EAAyB;MACvB;MACAlC,MAAM,CAACmC,IAAP,CACEjC,CAAE,qBAAoBE,CAAC,CACrBe,eADqB,CAErB,gFAHJ,EAIEpC,cAJF;IAMD,CAVsC,CAWvC;IACA;;;IACA,MAAMsD,WAAW,GAAG,MAAMV,+BAA+B,CACvDV,wBADuD,EAEvDC,aAFuD,EAGvDkB,KAAK,CAAC7B,WAHiD,EAIvD6B,KAAK,CAAC5B,SAJiD,EAKvDa,WALuD,EAMvDC,WANuD,EAOvDC,MAPuD,CAAzD;IASA7B,MAAM,CAAC8B,aAAD,EAAgBL,eAAhB,EAAiCkB,WAAjC,CAAN;IACA,OAAOA,WAAP;EACD;;EAED,IAAI5C,MAAM,CAAC+B,aAAD,EAAgBL,eAAhB,CAAV,EAA4C;IAC1C,OAAO3B,MAAM,CAACgC,aAAD,EAAgBL,eAAhB,CAAb;EACD;;EAED,MAAMC,kBAAkB,GAAG,MAAMU,UAAU,CAACX,eAAD,CAA3C;;EAEA,IAAIC,kBAAkB,KAAK,IAAvB,IAA+B,OAAOA,kBAAP,KAA8B,QAAjE,EAA2E;IACzE;IACApB,MAAM,CAACmC,IAAP,CACEjC,CAAE,8DAA6DE,CAAC,CAC9De,eAD8D,CAE9D,mBAAkBf,CAAC,CAACG,WAAW,CAAC+B,IAAb,CAAmB,EAH1C;EAKD;;EAED,IAAIlB,kBAAkB,CAACmB,MAAnB,KAA8BL,SAAlC,EAA6C;IAC3C,MAAM;MACJ3B,WAAW,EAAEiC,gBAAgB,GAAGjC,WAD5B;MAEJC,SAAS,EAAEiC,cAAc,GAAGtB,eAFxB;MAGJoB,MAAM,EAAEG;IAHJ,IAIFtB,kBAJJ;IAMA,MAAMiB,WAAW,GAAG,MAAMrB,UAAU,CAClCC,wBADkC,EAElCC,aAFkC,EAGlCsB,gBAHkC,EAIlCC,cAJkC,EAKlCC,iBALkC,EAMlCrB,WANkC,EAOlCC,WAPkC,EAQlCC,MARkC,CAApC;IAUA7B,MAAM,CAAC8B,aAAD,EAAgBL,eAAhB,EAAiCkB,WAAjC,CAAN;IACA,OAAOA,WAAP;EACD;;EAED,OAAOrB,UAAU,CACfC,wBADe,EAEfC,aAFe,EAGfX,WAHe,EAIfY,eAJe,EAKfC,kBALe,EAMfC,WANe,EAOfC,WAPe,EAQfC,MARe,CAAjB;AAUD,CAnGD;;AAqGA,MAAMI,+BAA+B,GAAG,OACtCV,wBADsC,EAEtCC,aAFsC,EAGtCX,WAHsC,EAItCY,eAJsC,EAKtCE,WALsC,EAMtCC,WANsC,EAOtCC,MAPsC,KAQnC;EACH,MAAM;IAAEe,IAAI,EAAEK;EAAR,IAA4B5C,UAAU,CAC1CkB,wBAD0C,EAE1CV,WAF0C,CAA5C,CADG,CAMH;;EACA,IAAIqC,kBAAkB,GAAGpD,MAAM,CAAC8B,WAAD,EAAcf,WAAd,CAA/B;;EACA,IAAIqC,kBAAkB,KAAKV,SAA3B,EAAsC;IACpCU,kBAAkB,GAAG,IAAI3D,GAAJ,EAArB;IACAS,MAAM,CAAC4B,WAAD,EAAcf,WAAd,EAA2BqC,kBAA3B,CAAN;EACD;;EACD,IAAIC,aAAa,GAAGrD,MAAM,CAACoD,kBAAD,EAAqBzB,eAArB,CAA1B;;EACA,IAAI0B,aAAa,KAAKX,SAAtB,EAAiC;IAC/B,OAAOW,aAAP;EACD;;EAEDA,aAAa,GAAGjD,YAAY,CAC1BiC,0BAA0B,CACxBZ,wBADwB,EAExBC,aAFwB,EAGxBX,WAHwB,EAIxBY,eAJwB,EAKxBE,WALwB,EAMxBC,WANwB,EAOxBC,MAPwB,CADA,EAU1BK,KAAK,IAAI;IACP;IACA5B,MAAM,CAAC8C,IAAP,CACElB,KADF,EAEE1B,CAAE,GAAE0B,KAAK,CAACmB,OAAQ,aAAY3C,CAAC,CAACe,eAAD,CAAkB,mBAAkBf,CAAC,CAClEuC,eADkE,CAElE,EAJJ;IAMA,MAAMf,KAAN;EACD,CAnByB,CAA5B;EAsBAlC,MAAM,CAACkD,kBAAD,EAAqBzB,eAArB,EAAsC0B,aAAtC,CAAN;EAEA,OAAOA,aAAP;AACD,CAlDD;AAoDA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMG,IAAI,GAAG,OAClB/B,wBADkB,EAElBC,aAFkB,EAGlBX,WAHkB,EAIlBY,eAJkB,KAKf;EACH,MAAM;IAAEmB,IAAI,EAAEK;EAAR,IAA4B5C,UAAU,CAC1CkB,wBAD0C,EAE1CV,WAF0C,CAA5C;EAKA;;EACA,MAAMc,WAAW,GAAG,IAAInC,GAAJ,EAApB;EACA;;EACA,MAAMoC,WAAW,GAAG,IAAIrC,GAAJ,EAApB;EACA;;EACA,MAAMsC,MAAM,GAAG,EAAf;EAEA,MAAMG,gBAAgB,GAAGC,+BAA+B,CACtDV,wBADsD,EAEtDC,aAFsD,EAGtDX,WAHsD,EAItDY,eAJsD,EAKtDE,WALsD,EAMtDC,WANsD,EAOtDC,MAPsD,CAAxD;EASA5B,MAAM,CACJ0B,WADI,EAEJxB,WAAW,CAAC6B,gBAAD,EAAmBrB,IAAnB,EAAyBuB,KAAK,IAAI;IAC3CvC,SAAS,CAACkC,MAAD,EAASK,KAAT,CAAT;EACD,CAFU,CAFP,CAAN,CAtBG,CA6BH;EACA;EACA;EACA;;EACA,KAAK,MAAMqB,GAAX,IAAkB5B,WAAlB,EAA+B;IAC7B;IACA,MAAM4B,GAAN;EACD,CApCE,CAsCH;;;EACA,IAAI1B,MAAM,CAAC2B,MAAP,GAAgB,CAApB,EAAuB;IACrB,MAAM,IAAIlE,SAAJ,CACH,yBAAwBoB,CAAC,CAACe,eAAD,CAAkB,eAAcf,CAAC,CACzDuC,eADyD,CAEzD,KAAIpB,MAAM,CAAC2B,MAAO,yBAAwB/D,SAAS,CACnDC,QAAQ,CAACmC,MAAD,EAASK,KAAK,IAAIA,KAAK,CAACmB,OAAxB,CAD2C,EAEnD,IAFmD,CAGnD,EANE,CAAN;EAQD;AACF,CAtDM"},"metadata":{},"sourceType":"module"}