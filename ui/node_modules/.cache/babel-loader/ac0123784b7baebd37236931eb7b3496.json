{"ast":null,"code":"import { FERAL_FUNCTION, arrayJoin } from './commons.js';\n/**\n * buildOptimizer()\n * Given an array of indentifier, the optimizer return a `const` declaration\n * destructring `this`.\n *\n * @param {Array<string>} constants\n */\n\nfunction buildOptimizer(constants) {\n  // No need to build an optimizer when there are no constants.\n  if (constants.length === 0) return ''; // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n/**\n * makeEvaluateFactory()\n * The factory create 'evaluate' functions with the correct optimizer\n * inserted.\n *\n * @param {Array<string>} [constants]\n */\n\n\nexport const makeEvaluateFactory = function () {\n  let constants = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const optimizer = buildOptimizer(constants); // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // `this` value holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches constant variable names for speed.\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated (the globalObject).\n  // 4: The outer sloppy function is passed one parameter, the scope proxy.\n  //    as the `this` parameter.\n  // Notes:\n  // - everything in the 'optimizer' string is looked up in the proxy\n  //   (including an 'arguments[0]', which points at the Proxy).\n  // - keywords like 'function' which are reserved keywords, and cannot be\n  //   used as a variable, so they are not part of the optimizer.\n  // - when 'eval' is looked up in the proxy, and it's the first time it is\n  //   looked up after allowNextEvalToBeUnsafe is turned on, the proxy returns\n  //   the powerful, unsafe eval intrinsic, and flips allowNextEvalToBeUnsafe\n  //   back to false. Any reference to 'eval' in that string will get the tamed\n  //   evaluator.\n  // TODO https://github.com/endojs/endo/issues/816\n  // The optimizer currently runs under sloppy mode, and although we doubt that\n  // there is any vulnerability introduced just by running the optimizer\n  // sloppy, we are much more confident in the semantics of strict mode.\n  // The motivation for having the optimizer in sloppy mode is that it can be\n  // reused for multiple evaluations, but in practice we have no such calls.\n  // We could probably both move the optimizer into the inner function\n  // and we could also simplify makeEvaluateFactory to simply evaluate.\n\n  return FERAL_FUNCTION(`\n    with (this) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n};","map":{"version":3,"names":["FERAL_FUNCTION","arrayJoin","buildOptimizer","constants","length","makeEvaluateFactory","optimizer"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/make-evaluate-factory.js"],"sourcesContent":["import { FERAL_FUNCTION, arrayJoin } from './commons.js';\n\n/**\n * buildOptimizer()\n * Given an array of indentifier, the optimizer return a `const` declaration\n * destructring `this`.\n *\n * @param {Array<string>} constants\n */\nfunction buildOptimizer(constants) {\n  // No need to build an optimizer when there are no constants.\n  if (constants.length === 0) return '';\n  // Use 'this' to avoid going through the scope proxy, which is unecessary\n  // since the optimizer only needs references to the safe global.\n  return `const {${arrayJoin(constants, ',')}} = this;`;\n}\n\n/**\n * makeEvaluateFactory()\n * The factory create 'evaluate' functions with the correct optimizer\n * inserted.\n *\n * @param {Array<string>} [constants]\n */\nexport const makeEvaluateFactory = (constants = []) => {\n  const optimizer = buildOptimizer(constants);\n\n  // Create a function in sloppy mode, so that we can use 'with'. It returns\n  // a function in strict mode that evaluates the provided code using direct\n  // eval, and thus in strict mode in the same scope. We must be very careful\n  // to not create new names in this scope\n\n  // 1: we use 'with' (around a Proxy) to catch all free variable names. The\n  // `this` value holds the Proxy which safely wraps the safeGlobal\n  // 2: 'optimizer' catches constant variable names for speed.\n  // 3: The inner strict function is effectively passed two parameters:\n  //    a) its arguments[0] is the source to be directly evaluated.\n  //    b) its 'this' is the this binding seen by the code being\n  //       directly evaluated (the globalObject).\n  // 4: The outer sloppy function is passed one parameter, the scope proxy.\n  //    as the `this` parameter.\n\n  // Notes:\n  // - everything in the 'optimizer' string is looked up in the proxy\n  //   (including an 'arguments[0]', which points at the Proxy).\n  // - keywords like 'function' which are reserved keywords, and cannot be\n  //   used as a variable, so they are not part of the optimizer.\n  // - when 'eval' is looked up in the proxy, and it's the first time it is\n  //   looked up after allowNextEvalToBeUnsafe is turned on, the proxy returns\n  //   the powerful, unsafe eval intrinsic, and flips allowNextEvalToBeUnsafe\n  //   back to false. Any reference to 'eval' in that string will get the tamed\n  //   evaluator.\n\n  // TODO https://github.com/endojs/endo/issues/816\n  // The optimizer currently runs under sloppy mode, and although we doubt that\n  // there is any vulnerability introduced just by running the optimizer\n  // sloppy, we are much more confident in the semantics of strict mode.\n  // The motivation for having the optimizer in sloppy mode is that it can be\n  // reused for multiple evaluations, but in practice we have no such calls.\n  // We could probably both move the optimizer into the inner function\n  // and we could also simplify makeEvaluateFactory to simply evaluate.\n  return FERAL_FUNCTION(`\n    with (this) {\n      ${optimizer}\n      return function() {\n        'use strict';\n        return eval(arguments[0]);\n      };\n    }\n  `);\n};\n"],"mappings":"AAAA,SAASA,cAAT,EAAyBC,SAAzB,QAA0C,cAA1C;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,cAAT,CAAwBC,SAAxB,EAAmC;EACjC;EACA,IAAIA,SAAS,CAACC,MAAV,KAAqB,CAAzB,EAA4B,OAAO,EAAP,CAFK,CAGjC;EACA;;EACA,OAAQ,UAASH,SAAS,CAACE,SAAD,EAAY,GAAZ,CAAiB,WAA3C;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,mBAAmB,GAAG,YAAoB;EAAA,IAAnBF,SAAmB,uEAAP,EAAO;EACrD,MAAMG,SAAS,GAAGJ,cAAc,CAACC,SAAD,CAAhC,CADqD,CAGrD;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,OAAOH,cAAc,CAAE;AACzB;AACA,QAAQM,SAAU;AAClB;AACA;AACA;AACA;AACA;AACA,GARuB,CAArB;AASD,CA9CM"},"metadata":{},"sourceType":"module"}