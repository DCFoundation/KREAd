{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\n\n/** @template Slot @typedef {import('@endo/marshal').ConvertValToSlot<Slot>} ConvertValToSlot */\n\n/** @template Slot @typedef {import('@endo/marshal').ConvertSlotToVal<Slot>} ConvertSlotToVal */\n// Your app may need to `import '@endo/eventual-send/shim.js'` to get HandledPromise\n// This logic was mostly lifted from @agoric/swingset-vat liveSlots.js\n// Defects in it are mfig's fault.\nimport { Remotable, Far, makeMarshal, QCLASS } from '@endo/marshal';\nimport { E, HandledPromise } from '@endo/eventual-send';\nimport { isPromise, makePromiseKit } from '@endo/promise-kit';\nimport { makeTrap } from './trap.js';\nimport './types.js';\nexport { E };\nconst {\n  details: X\n} = assert;\n/**\n * @param {any} maybeThenable\n * @returns {boolean}\n */\n\nconst isThenable = maybeThenable => maybeThenable && typeof maybeThenable.then === 'function';\n/**\n * @typedef {Object} CapTPOptions the options to makeCapTP\n * @property {(err: any) => void} onReject\n * @property {number} epoch an integer tag to attach to all messages in order to\n * assist in ignoring earlier defunct instance's messages\n * @property {TrapGuest} trapGuest if specified, enable this CapTP (guest) to\n * use Trap(target) to block while the recipient (host) resolves and\n * communicates the response to the message\n * @property {TrapHost} trapHost if specified, enable this CapTP (host) to serve\n * objects marked with makeTrapHandler to synchronous clients (guests)\n */\n\n/**\n * Create a CapTP connection.\n *\n * @param {string} ourId our name for the current side\n * @param {(obj: Record<string, any>) => void} rawSend send a JSONable packet\n * @param {any} bootstrapObj the object to export to the other side\n * @param {Partial<CapTPOptions>} opts options to the connection\n */\n\n\nexport const makeCapTP = function (ourId, rawSend) {\n  let bootstrapObj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    onReject = err => console.error('CapTP', ourId, 'exception:', err),\n    epoch = 0,\n    trapGuest,\n    trapHost\n  } = opts; // It's a hazard to have trapGuest and trapHost both enabled, as we may\n  // encounter deadlock.  Without a lot more bookkeeping, we can't detect it for\n  // more general networks of CapTPs, but we are conservative for at least this\n  // one case.\n\n  assert(!(trapHost && trapGuest), X`CapTP ${ourId} can only be one of either trapGuest or trapHost`);\n\n  const disconnectReason = id => Error(`${JSON.stringify(id)} connection closed`);\n  /** @type {Map<string, Promise<IteratorResult<void, void>>>} */\n\n\n  const trapIteratorResultP = new Map();\n  /** @type {Map<string, AsyncIterator<void, void, any>>} */\n\n  const trapIterator = new Map();\n  /** @type {any} */\n\n  let unplug = false;\n\n  const quietReject = async function () {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let returnIt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    if ((unplug === false || reason !== unplug) && reason !== undefined) {\n      onReject(reason);\n    }\n\n    if (!returnIt) {\n      return Promise.resolve();\n    } // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n\n\n    const p = Promise.reject(reason);\n    p.catch(_ => {});\n    return p;\n  };\n  /**\n   * @param {Record<string, any>} obj\n   */\n\n\n  const send = obj => {\n    // Don't throw here if unplugged, just don't send.\n    if (unplug === false) {\n      rawSend(obj);\n    }\n  };\n  /**\n   * convertValToSlot and convertSlotToVal both perform side effects,\n   * populating the c-lists (imports/exports/questions/answers) upon\n   * marshalling/unmarshalling.  As we traverse the datastructure representing\n   * the message, we discover what we need to import/export and send relevant\n   * messages across the wire.\n   */\n\n\n  const {\n    serialize,\n    unserialize\n  } = makeMarshal( // eslint-disable-next-line no-use-before-define\n  convertValToSlot, // eslint-disable-next-line no-use-before-define\n  convertSlotToVal, {\n    marshalName: `captp:${ourId}`,\n    // TODO Temporary hack.\n    // See https://github.com/Agoric/agoric-sdk/issues/2780\n    errorIdNum: 20000\n  });\n  /** @type {WeakMap<any, CapTPSlot>} */\n\n  const valToSlot = new WeakMap(); // exports looked up by val\n\n  /** @type {Map<CapTPSlot, any>} */\n\n  const slotToVal = new Map(); // reverse\n\n  const exportedTrapHandlers = new WeakSet(); // Used to construct slot names for promises/non-promises.\n  // In this version of CapTP we use strings for export/import slot names.\n  // prefixed with 'p' if promises and 'o' otherwise;\n\n  let lastPromiseID = 0;\n  let lastExportID = 0; // Since we decide the ids for questions, we use this to increment the\n  // question key\n\n  let lastQuestionID = 0;\n  /** @type {Map<string, any>} */\n\n  const questions = new Map(); // chosen by us\n\n  /** @type {Map<string, any>} */\n\n  const answers = new Map(); // chosen by our peer\n\n  /** @type {Map<number, any>} */\n\n  const imports = new Map(); // chosen by our peer\n\n  /**\n   * Called at marshalling time.  Either retrieves an existing export, or if\n   * not yet exported, records this exported object.  If a promise, sets up a\n   * promise listener to inform the other side when the promise is\n   * fulfilled/broken.\n   *\n   * @type {ConvertValToSlot<CapTPSlot>}\n   */\n\n  function convertValToSlot(val) {\n    if (!valToSlot.has(val)) {\n      /**\n       * new export\n       *\n       * @type {CapTPSlot}\n       */\n      let slot;\n\n      if (isPromise(val)) {\n        // This is a promise, so we're going to increment the lastPromiseId\n        // and use that to construct the slot name.  Promise slots are prefaced\n        // with 'p+'.\n        lastPromiseID += 1;\n        const promiseID = lastPromiseID;\n        slot = `p+${promiseID}`; // Set up promise listener to inform other side when this promise\n        // is fulfilled/broken\n\n        val.then(res => send({\n          type: 'CTP_RESOLVE',\n          promiseID,\n          res: serialize(harden(res))\n        }), rej => send({\n          type: 'CTP_RESOLVE',\n          promiseID,\n          rej: serialize(harden(rej))\n        }));\n      } else {\n        // Since this isn't a promise, we instead increment the lastExportId and\n        // use that to construct the slot name.  Non-promises are prefaced with\n        // 'o+' for normal objects, or `t+` for syncable.\n        lastExportID += 1;\n        const exportID = lastExportID;\n\n        if (exportedTrapHandlers.has(val)) {\n          slot = `t+${exportID}`;\n        } else {\n          slot = `o+${exportID}`;\n        }\n      } // Now record the export in both valToSlot and slotToVal so we can look it\n      // up from either the value or the slot name later.\n\n\n      valToSlot.set(val, slot);\n      slotToVal.set(slot, val);\n    } // At this point, the value is guaranteed to be exported, so return the\n    // associated slot number.\n\n\n    const slot = valToSlot.get(val);\n    assert.typeof(slot, 'string');\n    return slot;\n  }\n  /**\n   * Generate a new question in the questions table and set up a new\n   * remote handled promise.\n   *\n   * @returns {[string, ReturnType<typeof makeRemoteKit>]}\n   */\n\n\n  const makeQuestion = () => {\n    lastQuestionID += 1;\n    const questionID = `${ourId}#${lastQuestionID}`; // eslint-disable-next-line no-use-before-define\n\n    const pr = makeRemoteKit(questionID);\n    questions.set(questionID, pr); // To fix #2846:\n    // We return 'p' to the handler, and the eventual resolution of 'p' will\n    // be used to resolve the caller's Promise, but the caller never sees 'p'\n    // itself. The caller got back their Promise before the handler ever got\n    // invoked, and thus before queueMessage was called. If that caller\n    // passes the Promise they received as argument or return value, we want\n    // it to serialize as resultVPID. And if someone passes resultVPID to\n    // them, we want the user-level code to get back that Promise, not 'p'.\n\n    lastPromiseID += 1;\n    const promiseID = lastPromiseID;\n    const resultVPID = `p+${promiseID}`;\n    valToSlot.set(pr.p, resultVPID);\n    slotToVal.set(resultVPID, pr.p);\n    return [questionID, pr];\n  }; // Make a remote promise for `target` (an id in the questions table)\n\n\n  const makeRemoteKit = target => {\n    // This handler is set up such that it will transform both\n    // attribute access and method invocation of this remote promise\n    // as also being questions / remote handled promises\n    const handler = {\n      get(_o, prop) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop]))\n        });\n        return harden(pr.p);\n      },\n\n      applyFunction(_o, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([null, args]))\n        });\n        return harden(pr.p);\n      },\n\n      applyMethod(_o, prop, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        } // Support: o~.[prop](...args) remote method invocation\n\n\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop, args]))\n        });\n        return harden(pr.p);\n      }\n\n    };\n    const pr = {};\n    pr.p = new HandledPromise((res, rej, resolveWithPresence) => {\n      pr.rej = rej;\n\n      pr.resPres = () => resolveWithPresence(handler);\n\n      pr.res = res;\n    }, handler); // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n\n    pr.p.catch(e => quietReject(e, false));\n    return harden(pr);\n  };\n  /**\n   * Set up import\n   *\n   * @type {ConvertSlotToVal<CapTPSlot>}\n   */\n\n\n  function convertSlotToVal(theirSlot) {\n    let iface = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    let val; // Invert slot direction from other side.\n    // Inverted to prevent namespace collisions between slots we\n    // allocate and the ones the other side allocates.  If we allocate\n    // a slot, serialize it to the other side, and they send it back to\n    // us, we need to reference just our own slot, not one from their\n    // side.\n\n    const otherDir = theirSlot[1] === '+' ? '-' : '+';\n    const slot = `${theirSlot[0]}${otherDir}${theirSlot.slice(2)}`;\n\n    if (!slotToVal.has(slot)) {\n      // Make a new handled promise for the slot.\n      const pr = makeRemoteKit(slot);\n\n      if (slot[0] === 'o' || slot[0] === 't') {\n        if (iface === undefined) {\n          iface = `Alleged: Presence ${ourId} ${slot}`;\n        } // A new remote presence\n        // Use Remotable rather than Far to make a remote from a presence\n\n\n        val = Remotable(iface, undefined, pr.resPres());\n      } else {\n        // A new promise\n        imports.set(Number(slot.slice(2)), pr);\n        val = pr.p;\n      }\n\n      slotToVal.set(slot, val);\n      valToSlot.set(val, slot);\n    }\n\n    return slotToVal.get(slot);\n  } // Message handler used for CapTP dispatcher\n\n\n  const handler = {\n    // Remote is asking for bootstrap object\n    async CTP_BOOTSTRAP(obj) {\n      const {\n        questionID\n      } = obj;\n      const bootstrap = typeof bootstrapObj === 'function' ? bootstrapObj(obj) : bootstrapObj;\n      E.when(bootstrap, bs => {\n        // console.log('sending bootstrap', bootstrap);\n        answers.set(questionID, bs);\n        return send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          result: serialize(bs)\n        });\n      });\n    },\n\n    // Remote is invoking a method or retrieving a property.\n    async CTP_CALL(obj) {\n      // questionId: Remote promise (for promise pipelining) this call is\n      //   to fulfill\n      // target: Slot id of the target to be invoked.  Checks against\n      //   answers first; otherwise goes through unserializer\n      const {\n        questionID,\n        target,\n        trap\n      } = obj;\n      const [prop, args] = unserialize(obj.method);\n      let val;\n\n      if (answers.has(target)) {\n        val = answers.get(target);\n      } else {\n        val = unserialize({\n          body: JSON.stringify({\n            [QCLASS]: 'slot',\n            index: 0\n          }),\n          slots: [target]\n        });\n      }\n      /** @type {(isReject: boolean, value: any) => void} */\n\n\n      let processResult = (isReject, value) => {\n        send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          [isReject ? 'exception' : 'result']: serialize(harden(value))\n        });\n      };\n\n      if (trap) {\n        assert(exportedTrapHandlers.has(val), X`Refused Trap(${val}) because target was not registered with makeTrapHandler`);\n        assert.typeof(trapHost, 'function', X`CapTP cannot answer Trap(${val}) without a trapHost function`); // We need to create a promise for the \"isDone\" iteration right now to\n        // prevent a race with the other side.\n\n        const resultPK = makePromiseKit();\n        trapIteratorResultP.set(questionID, resultPK.promise);\n\n        processResult = async (isReject, value) => {\n          const serialized = serialize(harden(value));\n          const ait = trapHost([isReject, serialized]);\n\n          if (!ait) {\n            // One-shot, no async iterator.\n            resultPK.resolve({\n              done: true\n            });\n            return;\n          } // We're ready for them to drive the iterator.\n\n\n          trapIterator.set(questionID, ait);\n          resultPK.resolve({\n            done: false\n          });\n        };\n      } // If `args` is supplied, we're applying a method or function...\n      // otherwise this is property access\n\n\n      let hp;\n\n      if (!args) {\n        hp = HandledPromise.get(val, prop);\n      } else if (prop === null) {\n        hp = HandledPromise.applyFunction(val, args);\n      } else {\n        hp = HandledPromise.applyMethod(val, prop, args);\n      } // Answer with our handled promise\n\n\n      answers.set(questionID, hp); // We let rejections bubble up to our caller, `dispatch`.\n\n      await hp // Process this handled promise method's result when settled.\n      .then(fulfilment => processResult(false, fulfilment), reason => processResult(true, reason));\n    },\n\n    // Have the host serve more of the reply.\n    CTP_TRAP_ITERATE: async obj => {\n      assert(trapHost, X`CTP_TRAP_ITERATE is impossible without a trapHost`);\n      const {\n        questionID,\n        serialized\n      } = obj;\n      const resultP = trapIteratorResultP.get(questionID);\n      assert(resultP, X`CTP_TRAP_ITERATE did not expect ${questionID}`);\n      const [method, args] = unserialize(serialized);\n\n      const getNextResultP = async () => {\n        const result = await resultP; // Done with this trap iterator.\n\n        const cleanup = () => {\n          trapIterator.delete(questionID);\n          trapIteratorResultP.delete(questionID);\n          return harden({\n            done: true\n          });\n        }; // We want to ensure we clean up the iterator in case of any failure.\n\n\n        try {\n          if (!result || result.done) {\n            return cleanup();\n          }\n\n          const ait = trapIterator.get(questionID);\n\n          if (!ait) {\n            // The iterator is done, so we're done.\n            return cleanup();\n          } // Drive the next iteration.\n\n\n          return await ait[method](...args);\n        } catch (e) {\n          cleanup();\n\n          if (!e) {\n            assert.fail(X`trapGuest expected trapHost AsyncIterator(${questionID}) to be done, but it wasn't`);\n          }\n\n          assert.note(e, X`trapHost AsyncIterator(${questionID}) threw`);\n          throw e;\n        }\n      }; // Store the next result promise.\n\n\n      const nextResultP = getNextResultP();\n      trapIteratorResultP.set(questionID, nextResultP); // Ensure that our caller handles any rejection.\n\n      await nextResultP;\n    },\n\n    // Answer to one of our questions.\n    async CTP_RETURN(obj) {\n      const {\n        result,\n        exception,\n        answerID\n      } = obj;\n\n      if (!questions.has(answerID)) {\n        throw new Error(`Got an answer to a question we have not asked. (answerID = ${answerID} )`);\n      }\n\n      const pr = questions.get(answerID);\n\n      if ('exception' in obj) {\n        pr.rej(unserialize(exception));\n      } else {\n        pr.res(unserialize(result));\n      }\n    },\n\n    // Resolution to an imported promise\n    async CTP_RESOLVE(obj) {\n      const {\n        promiseID,\n        res,\n        rej\n      } = obj;\n\n      if (!imports.has(promiseID)) {\n        throw new Error(`Got a resolvement of a promise we have not imported. (promiseID = ${promiseID} )`);\n      }\n\n      const pr = imports.get(promiseID);\n\n      if ('rej' in obj) {\n        pr.rej(unserialize(rej));\n      } else {\n        pr.res(unserialize(res));\n      }\n\n      imports.delete(promiseID);\n    },\n\n    // The other side has signaled something has gone wrong.\n    // Pull the plug!\n    async CTP_DISCONNECT(obj) {\n      const {\n        reason = disconnectReason(ourId)\n      } = obj;\n\n      if (unplug === false) {\n        // Reject with the original reason.\n        quietReject(obj.reason, false);\n        unplug = reason; // Deliver the object, even though we're unplugged.\n\n        rawSend(obj);\n      }\n\n      for (const pr of questions.values()) {\n        pr.rej(reason);\n      }\n\n      for (const pr of imports.values()) {\n        pr.rej(reason);\n      }\n    }\n\n  }; // Get a reference to the other side's bootstrap object.\n\n  const getBootstrap = async () => {\n    if (unplug !== false) {\n      return quietReject(unplug);\n    }\n\n    const [questionID, pr] = makeQuestion();\n    send({\n      type: 'CTP_BOOTSTRAP',\n      epoch,\n      questionID\n    });\n    return harden(pr.p);\n  };\n\n  harden(handler); // Return a dispatch function.\n\n  const dispatch = obj => {\n    try {\n      if (unplug !== false) {\n        return false;\n      }\n\n      const fn = handler[obj.type];\n\n      if (fn) {\n        fn(obj).catch(e => quietReject(e, false));\n        return true;\n      }\n\n      return false;\n    } catch (e) {\n      quietReject(e, false);\n      return false;\n    }\n  }; // Abort a connection.\n\n\n  const abort = function () {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    dispatch({\n      type: 'CTP_DISCONNECT',\n      epoch,\n      reason\n    });\n  };\n\n  const makeTrapHandler = (name, obj) => {\n    const far = Far(name, obj);\n    exportedTrapHandlers.add(far);\n    return far;\n  }; // Put together our return value.\n\n\n  const rets = {\n    abort,\n    dispatch,\n    getBootstrap,\n    serialize,\n    unserialize,\n    makeTrapHandler,\n    Trap:\n    /** @type {Trap | undefined} */\n    undefined\n  };\n\n  if (trapGuest) {\n    assert.typeof(trapGuest, 'function', X`opts.trapGuest must be a function`); // Create the Trap proxy maker.\n\n    const makeTrapImpl = implMethod => function (target) {\n      assert(Promise.resolve(target) !== target, X`Trap(${target}) target cannot be a promise`);\n      const slot = valToSlot.get(target);\n      assert(slot && slot[1] === '-', X`Trap(${target}) target was not imported`);\n      assert(slot[0] === 't', X`Trap(${target}) imported target was not created with makeTrapHandler`); // Send a \"trap\" message.\n\n      lastQuestionID += 1;\n      const questionID = `${ourId}#${lastQuestionID}`; // Encode the \"method\" parameter of the CTP_CALL.\n\n      let method;\n\n      for (var _len = arguments.length, implArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        implArgs[_key - 1] = arguments[_key];\n      }\n\n      switch (implMethod) {\n        case 'get':\n          {\n            const [prop] = implArgs;\n            method = serialize(harden([prop]));\n            break;\n          }\n\n        case 'applyFunction':\n          {\n            const [args] = implArgs;\n            method = serialize(harden([null, args]));\n            break;\n          }\n\n        case 'applyMethod':\n          {\n            const [prop, args] = implArgs;\n            method = serialize(harden([prop, args]));\n            break;\n          }\n\n        default:\n          {\n            assert.fail(X`Internal error; unrecognized implMethod ${implMethod}`);\n          }\n      } // Set up the trap call with its identifying information and a way to send\n      // messages over the current CapTP data channel.\n\n\n      const [isException, serialized] = trapGuest({\n        trapMethod: implMethod,\n        slot,\n        trapArgs: implArgs,\n        startTrap: () => {\n          // Send the call metadata over the connection.\n          send({\n            type: 'CTP_CALL',\n            epoch,\n            trap: true,\n            // This is the magic marker.\n            questionID,\n            target: slot,\n            method\n          }); // Return an IterationObserver.\n\n          const makeIteratorMethod = (iteratorMethod, done) => function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            send({\n              type: 'CTP_TRAP_ITERATE',\n              epoch,\n              questionID,\n              serialized: serialize(harden([iteratorMethod, args]))\n            });\n            return harden({\n              done,\n              value: undefined\n            });\n          };\n\n          return harden({\n            next: makeIteratorMethod('next', false),\n            return: makeIteratorMethod('return', true),\n            throw: makeIteratorMethod('throw', true)\n          });\n        }\n      });\n      const value = unserialize(serialized);\n      assert(!isThenable(value), X`Trap(${target}) reply cannot be a Thenable; have ${value}`);\n\n      if (isException) {\n        throw value;\n      }\n\n      return value;\n    };\n    /** @type {TrapImpl} */\n\n\n    const trapImpl = {\n      applyFunction: makeTrapImpl('applyFunction'),\n      applyMethod: makeTrapImpl('applyMethod'),\n      get: makeTrapImpl('get')\n    };\n    harden(trapImpl);\n    rets.Trap = makeTrap(trapImpl);\n  }\n\n  return harden(rets);\n};","map":{"version":3,"names":["Remotable","Far","makeMarshal","QCLASS","E","HandledPromise","isPromise","makePromiseKit","makeTrap","details","X","assert","isThenable","maybeThenable","then","makeCapTP","ourId","rawSend","bootstrapObj","undefined","opts","onReject","err","console","error","epoch","trapGuest","trapHost","disconnectReason","id","Error","JSON","stringify","trapIteratorResultP","Map","trapIterator","unplug","quietReject","reason","returnIt","Promise","resolve","p","reject","catch","_","send","obj","serialize","unserialize","convertValToSlot","convertSlotToVal","marshalName","errorIdNum","valToSlot","WeakMap","slotToVal","exportedTrapHandlers","WeakSet","lastPromiseID","lastExportID","lastQuestionID","questions","answers","imports","val","has","slot","promiseID","res","type","harden","rej","exportID","set","get","typeof","makeQuestion","questionID","pr","makeRemoteKit","resultVPID","target","handler","_o","prop","method","applyFunction","args","applyMethod","resolveWithPresence","resPres","e","theirSlot","iface","otherDir","slice","Number","CTP_BOOTSTRAP","bootstrap","when","bs","answerID","result","CTP_CALL","trap","body","index","slots","processResult","isReject","value","resultPK","promise","serialized","ait","done","hp","fulfilment","CTP_TRAP_ITERATE","resultP","getNextResultP","cleanup","delete","fail","note","nextResultP","CTP_RETURN","exception","CTP_RESOLVE","CTP_DISCONNECT","values","getBootstrap","dispatch","fn","abort","makeTrapHandler","name","far","add","rets","Trap","makeTrapImpl","implMethod","implArgs","isException","trapMethod","trapArgs","startTrap","makeIteratorMethod","iteratorMethod","next","return","throw","trapImpl"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/captp/src/captp.js"],"sourcesContent":["// @ts-check\n/// <reference types=\"ses\"/>\n\n/** @template Slot @typedef {import('@endo/marshal').ConvertValToSlot<Slot>} ConvertValToSlot */\n/** @template Slot @typedef {import('@endo/marshal').ConvertSlotToVal<Slot>} ConvertSlotToVal */\n\n// Your app may need to `import '@endo/eventual-send/shim.js'` to get HandledPromise\n\n// This logic was mostly lifted from @agoric/swingset-vat liveSlots.js\n// Defects in it are mfig's fault.\nimport { Remotable, Far, makeMarshal, QCLASS } from '@endo/marshal';\nimport { E, HandledPromise } from '@endo/eventual-send';\nimport { isPromise, makePromiseKit } from '@endo/promise-kit';\n\nimport { makeTrap } from './trap.js';\n\nimport './types.js';\n\nexport { E };\n\nconst { details: X } = assert;\n\n/**\n * @param {any} maybeThenable\n * @returns {boolean}\n */\nconst isThenable = maybeThenable =>\n  maybeThenable && typeof maybeThenable.then === 'function';\n\n/**\n * @typedef {Object} CapTPOptions the options to makeCapTP\n * @property {(err: any) => void} onReject\n * @property {number} epoch an integer tag to attach to all messages in order to\n * assist in ignoring earlier defunct instance's messages\n * @property {TrapGuest} trapGuest if specified, enable this CapTP (guest) to\n * use Trap(target) to block while the recipient (host) resolves and\n * communicates the response to the message\n * @property {TrapHost} trapHost if specified, enable this CapTP (host) to serve\n * objects marked with makeTrapHandler to synchronous clients (guests)\n */\n\n/**\n * Create a CapTP connection.\n *\n * @param {string} ourId our name for the current side\n * @param {(obj: Record<string, any>) => void} rawSend send a JSONable packet\n * @param {any} bootstrapObj the object to export to the other side\n * @param {Partial<CapTPOptions>} opts options to the connection\n */\nexport const makeCapTP = (\n  ourId,\n  rawSend,\n  bootstrapObj = undefined,\n  opts = {},\n) => {\n  const {\n    onReject = err => console.error('CapTP', ourId, 'exception:', err),\n    epoch = 0,\n    trapGuest,\n    trapHost,\n  } = opts;\n\n  // It's a hazard to have trapGuest and trapHost both enabled, as we may\n  // encounter deadlock.  Without a lot more bookkeeping, we can't detect it for\n  // more general networks of CapTPs, but we are conservative for at least this\n  // one case.\n  assert(\n    !(trapHost && trapGuest),\n    X`CapTP ${ourId} can only be one of either trapGuest or trapHost`,\n  );\n\n  const disconnectReason = id =>\n    Error(`${JSON.stringify(id)} connection closed`);\n\n  /** @type {Map<string, Promise<IteratorResult<void, void>>>} */\n  const trapIteratorResultP = new Map();\n  /** @type {Map<string, AsyncIterator<void, void, any>>} */\n  const trapIterator = new Map();\n\n  /** @type {any} */\n  let unplug = false;\n  const quietReject = async (reason = undefined, returnIt = true) => {\n    if ((unplug === false || reason !== unplug) && reason !== undefined) {\n      onReject(reason);\n    }\n    if (!returnIt) {\n      return Promise.resolve();\n    }\n\n    // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n    const p = Promise.reject(reason);\n    p.catch(_ => {});\n    return p;\n  };\n\n  /**\n   * @param {Record<string, any>} obj\n   */\n  const send = obj => {\n    // Don't throw here if unplugged, just don't send.\n    if (unplug === false) {\n      rawSend(obj);\n    }\n  };\n\n  /**\n   * convertValToSlot and convertSlotToVal both perform side effects,\n   * populating the c-lists (imports/exports/questions/answers) upon\n   * marshalling/unmarshalling.  As we traverse the datastructure representing\n   * the message, we discover what we need to import/export and send relevant\n   * messages across the wire.\n   */\n  const { serialize, unserialize } = makeMarshal(\n    // eslint-disable-next-line no-use-before-define\n    convertValToSlot,\n    // eslint-disable-next-line no-use-before-define\n    convertSlotToVal,\n    {\n      marshalName: `captp:${ourId}`,\n      // TODO Temporary hack.\n      // See https://github.com/Agoric/agoric-sdk/issues/2780\n      errorIdNum: 20000,\n    },\n  );\n\n  /** @type {WeakMap<any, CapTPSlot>} */\n  const valToSlot = new WeakMap(); // exports looked up by val\n  /** @type {Map<CapTPSlot, any>} */\n  const slotToVal = new Map(); // reverse\n  const exportedTrapHandlers = new WeakSet();\n\n  // Used to construct slot names for promises/non-promises.\n  // In this version of CapTP we use strings for export/import slot names.\n  // prefixed with 'p' if promises and 'o' otherwise;\n  let lastPromiseID = 0;\n  let lastExportID = 0;\n  // Since we decide the ids for questions, we use this to increment the\n  // question key\n  let lastQuestionID = 0;\n\n  /** @type {Map<string, any>} */\n  const questions = new Map(); // chosen by us\n  /** @type {Map<string, any>} */\n  const answers = new Map(); // chosen by our peer\n  /** @type {Map<number, any>} */\n  const imports = new Map(); // chosen by our peer\n\n  /**\n   * Called at marshalling time.  Either retrieves an existing export, or if\n   * not yet exported, records this exported object.  If a promise, sets up a\n   * promise listener to inform the other side when the promise is\n   * fulfilled/broken.\n   *\n   * @type {ConvertValToSlot<CapTPSlot>}\n   */\n  function convertValToSlot(val) {\n    if (!valToSlot.has(val)) {\n      /**\n       * new export\n       *\n       * @type {CapTPSlot}\n       */\n      let slot;\n      if (isPromise(val)) {\n        // This is a promise, so we're going to increment the lastPromiseId\n        // and use that to construct the slot name.  Promise slots are prefaced\n        // with 'p+'.\n        lastPromiseID += 1;\n        const promiseID = lastPromiseID;\n        slot = `p+${promiseID}`;\n        // Set up promise listener to inform other side when this promise\n        // is fulfilled/broken\n        val.then(\n          res =>\n            send({\n              type: 'CTP_RESOLVE',\n              promiseID,\n              res: serialize(harden(res)),\n            }),\n          rej =>\n            send({\n              type: 'CTP_RESOLVE',\n              promiseID,\n              rej: serialize(harden(rej)),\n            }),\n        );\n      } else {\n        // Since this isn't a promise, we instead increment the lastExportId and\n        // use that to construct the slot name.  Non-promises are prefaced with\n        // 'o+' for normal objects, or `t+` for syncable.\n        lastExportID += 1;\n        const exportID = lastExportID;\n        if (exportedTrapHandlers.has(val)) {\n          slot = `t+${exportID}`;\n        } else {\n          slot = `o+${exportID}`;\n        }\n      }\n      // Now record the export in both valToSlot and slotToVal so we can look it\n      // up from either the value or the slot name later.\n      valToSlot.set(val, slot);\n      slotToVal.set(slot, val);\n    }\n    // At this point, the value is guaranteed to be exported, so return the\n    // associated slot number.\n    const slot = valToSlot.get(val);\n    assert.typeof(slot, 'string');\n    return slot;\n  }\n\n  /**\n   * Generate a new question in the questions table and set up a new\n   * remote handled promise.\n   *\n   * @returns {[string, ReturnType<typeof makeRemoteKit>]}\n   */\n  const makeQuestion = () => {\n    lastQuestionID += 1;\n    const questionID = `${ourId}#${lastQuestionID}`;\n    // eslint-disable-next-line no-use-before-define\n    const pr = makeRemoteKit(questionID);\n    questions.set(questionID, pr);\n\n    // To fix #2846:\n    // We return 'p' to the handler, and the eventual resolution of 'p' will\n    // be used to resolve the caller's Promise, but the caller never sees 'p'\n    // itself. The caller got back their Promise before the handler ever got\n    // invoked, and thus before queueMessage was called. If that caller\n    // passes the Promise they received as argument or return value, we want\n    // it to serialize as resultVPID. And if someone passes resultVPID to\n    // them, we want the user-level code to get back that Promise, not 'p'.\n    lastPromiseID += 1;\n    const promiseID = lastPromiseID;\n    const resultVPID = `p+${promiseID}`;\n    valToSlot.set(pr.p, resultVPID);\n    slotToVal.set(resultVPID, pr.p);\n\n    return [questionID, pr];\n  };\n\n  // Make a remote promise for `target` (an id in the questions table)\n  const makeRemoteKit = target => {\n    // This handler is set up such that it will transform both\n    // attribute access and method invocation of this remote promise\n    // as also being questions / remote handled promises\n    const handler = {\n      get(_o, prop) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop])),\n        });\n        return harden(pr.p);\n      },\n      applyFunction(_o, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([null, args])),\n        });\n        return harden(pr.p);\n      },\n      applyMethod(_o, prop, args) {\n        if (unplug !== false) {\n          return quietReject(unplug);\n        }\n        // Support: o~.[prop](...args) remote method invocation\n        const [questionID, pr] = makeQuestion();\n        send({\n          type: 'CTP_CALL',\n          epoch,\n          questionID,\n          target,\n          method: serialize(harden([prop, args])),\n        });\n        return harden(pr.p);\n      },\n    };\n\n    const pr = {};\n    pr.p = new HandledPromise((res, rej, resolveWithPresence) => {\n      pr.rej = rej;\n      pr.resPres = () => resolveWithPresence(handler);\n      pr.res = res;\n    }, handler);\n\n    // Silence the unhandled rejection warning, but don't affect\n    // the user's handlers.\n    pr.p.catch(e => quietReject(e, false));\n\n    return harden(pr);\n  };\n\n  /**\n   * Set up import\n   *\n   * @type {ConvertSlotToVal<CapTPSlot>}\n   */\n  function convertSlotToVal(theirSlot, iface = undefined) {\n    let val;\n    // Invert slot direction from other side.\n\n    // Inverted to prevent namespace collisions between slots we\n    // allocate and the ones the other side allocates.  If we allocate\n    // a slot, serialize it to the other side, and they send it back to\n    // us, we need to reference just our own slot, not one from their\n    // side.\n    const otherDir = theirSlot[1] === '+' ? '-' : '+';\n    const slot = `${theirSlot[0]}${otherDir}${theirSlot.slice(2)}`;\n    if (!slotToVal.has(slot)) {\n      // Make a new handled promise for the slot.\n      const pr = makeRemoteKit(slot);\n      if (slot[0] === 'o' || slot[0] === 't') {\n        if (iface === undefined) {\n          iface = `Alleged: Presence ${ourId} ${slot}`;\n        }\n        // A new remote presence\n        // Use Remotable rather than Far to make a remote from a presence\n        val = Remotable(iface, undefined, pr.resPres());\n      } else {\n        // A new promise\n        imports.set(Number(slot.slice(2)), pr);\n        val = pr.p;\n      }\n      slotToVal.set(slot, val);\n      valToSlot.set(val, slot);\n    }\n    return slotToVal.get(slot);\n  }\n\n  // Message handler used for CapTP dispatcher\n  const handler = {\n    // Remote is asking for bootstrap object\n    async CTP_BOOTSTRAP(obj) {\n      const { questionID } = obj;\n      const bootstrap =\n        typeof bootstrapObj === 'function' ? bootstrapObj(obj) : bootstrapObj;\n      E.when(bootstrap, bs => {\n        // console.log('sending bootstrap', bootstrap);\n        answers.set(questionID, bs);\n        return send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          result: serialize(bs),\n        });\n      });\n    },\n    // Remote is invoking a method or retrieving a property.\n    async CTP_CALL(obj) {\n      // questionId: Remote promise (for promise pipelining) this call is\n      //   to fulfill\n      // target: Slot id of the target to be invoked.  Checks against\n      //   answers first; otherwise goes through unserializer\n      const { questionID, target, trap } = obj;\n\n      const [prop, args] = unserialize(obj.method);\n      let val;\n      if (answers.has(target)) {\n        val = answers.get(target);\n      } else {\n        val = unserialize({\n          body: JSON.stringify({\n            [QCLASS]: 'slot',\n            index: 0,\n          }),\n          slots: [target],\n        });\n      }\n\n      /** @type {(isReject: boolean, value: any) => void} */\n      let processResult = (isReject, value) => {\n        send({\n          type: 'CTP_RETURN',\n          epoch,\n          answerID: questionID,\n          [isReject ? 'exception' : 'result']: serialize(harden(value)),\n        });\n      };\n      if (trap) {\n        assert(\n          exportedTrapHandlers.has(val),\n          X`Refused Trap(${val}) because target was not registered with makeTrapHandler`,\n        );\n        assert.typeof(\n          trapHost,\n          'function',\n          X`CapTP cannot answer Trap(${val}) without a trapHost function`,\n        );\n\n        // We need to create a promise for the \"isDone\" iteration right now to\n        // prevent a race with the other side.\n        const resultPK = makePromiseKit();\n        trapIteratorResultP.set(questionID, resultPK.promise);\n\n        processResult = async (isReject, value) => {\n          const serialized = serialize(harden(value));\n          const ait = trapHost([isReject, serialized]);\n          if (!ait) {\n            // One-shot, no async iterator.\n            resultPK.resolve({ done: true });\n            return;\n          }\n\n          // We're ready for them to drive the iterator.\n          trapIterator.set(questionID, ait);\n          resultPK.resolve({ done: false });\n        };\n      }\n\n      // If `args` is supplied, we're applying a method or function...\n      // otherwise this is property access\n      let hp;\n      if (!args) {\n        hp = HandledPromise.get(val, prop);\n      } else if (prop === null) {\n        hp = HandledPromise.applyFunction(val, args);\n      } else {\n        hp = HandledPromise.applyMethod(val, prop, args);\n      }\n\n      // Answer with our handled promise\n      answers.set(questionID, hp);\n\n      // We let rejections bubble up to our caller, `dispatch`.\n      await hp\n        // Process this handled promise method's result when settled.\n        .then(\n          fulfilment => processResult(false, fulfilment),\n          reason => processResult(true, reason),\n        );\n    },\n    // Have the host serve more of the reply.\n    CTP_TRAP_ITERATE: async obj => {\n      assert(trapHost, X`CTP_TRAP_ITERATE is impossible without a trapHost`);\n      const { questionID, serialized } = obj;\n\n      const resultP = trapIteratorResultP.get(questionID);\n      assert(resultP, X`CTP_TRAP_ITERATE did not expect ${questionID}`);\n\n      const [method, args] = unserialize(serialized);\n\n      const getNextResultP = async () => {\n        const result = await resultP;\n\n        // Done with this trap iterator.\n        const cleanup = () => {\n          trapIterator.delete(questionID);\n          trapIteratorResultP.delete(questionID);\n          return harden({ done: true });\n        };\n\n        // We want to ensure we clean up the iterator in case of any failure.\n        try {\n          if (!result || result.done) {\n            return cleanup();\n          }\n\n          const ait = trapIterator.get(questionID);\n          if (!ait) {\n            // The iterator is done, so we're done.\n            return cleanup();\n          }\n\n          // Drive the next iteration.\n          return await ait[method](...args);\n        } catch (e) {\n          cleanup();\n          if (!e) {\n            assert.fail(\n              X`trapGuest expected trapHost AsyncIterator(${questionID}) to be done, but it wasn't`,\n            );\n          }\n          assert.note(e, X`trapHost AsyncIterator(${questionID}) threw`);\n          throw e;\n        }\n      };\n\n      // Store the next result promise.\n      const nextResultP = getNextResultP();\n      trapIteratorResultP.set(questionID, nextResultP);\n\n      // Ensure that our caller handles any rejection.\n      await nextResultP;\n    },\n    // Answer to one of our questions.\n    async CTP_RETURN(obj) {\n      const { result, exception, answerID } = obj;\n      if (!questions.has(answerID)) {\n        throw new Error(\n          `Got an answer to a question we have not asked. (answerID = ${answerID} )`,\n        );\n      }\n      const pr = questions.get(answerID);\n      if ('exception' in obj) {\n        pr.rej(unserialize(exception));\n      } else {\n        pr.res(unserialize(result));\n      }\n    },\n    // Resolution to an imported promise\n    async CTP_RESOLVE(obj) {\n      const { promiseID, res, rej } = obj;\n      if (!imports.has(promiseID)) {\n        throw new Error(\n          `Got a resolvement of a promise we have not imported. (promiseID = ${promiseID} )`,\n        );\n      }\n      const pr = imports.get(promiseID);\n      if ('rej' in obj) {\n        pr.rej(unserialize(rej));\n      } else {\n        pr.res(unserialize(res));\n      }\n      imports.delete(promiseID);\n    },\n    // The other side has signaled something has gone wrong.\n    // Pull the plug!\n    async CTP_DISCONNECT(obj) {\n      const { reason = disconnectReason(ourId) } = obj;\n      if (unplug === false) {\n        // Reject with the original reason.\n        quietReject(obj.reason, false);\n        unplug = reason;\n        // Deliver the object, even though we're unplugged.\n        rawSend(obj);\n      }\n      for (const pr of questions.values()) {\n        pr.rej(reason);\n      }\n      for (const pr of imports.values()) {\n        pr.rej(reason);\n      }\n    },\n  };\n\n  // Get a reference to the other side's bootstrap object.\n  const getBootstrap = async () => {\n    if (unplug !== false) {\n      return quietReject(unplug);\n    }\n    const [questionID, pr] = makeQuestion();\n    send({\n      type: 'CTP_BOOTSTRAP',\n      epoch,\n      questionID,\n    });\n    return harden(pr.p);\n  };\n  harden(handler);\n\n  // Return a dispatch function.\n  const dispatch = obj => {\n    try {\n      if (unplug !== false) {\n        return false;\n      }\n      const fn = handler[obj.type];\n      if (fn) {\n        fn(obj).catch(e => quietReject(e, false));\n        return true;\n      }\n      return false;\n    } catch (e) {\n      quietReject(e, false);\n      return false;\n    }\n  };\n\n  // Abort a connection.\n  const abort = (reason = undefined) => {\n    dispatch({ type: 'CTP_DISCONNECT', epoch, reason });\n  };\n\n  const makeTrapHandler = (name, obj) => {\n    const far = Far(name, obj);\n    exportedTrapHandlers.add(far);\n    return far;\n  };\n\n  // Put together our return value.\n  const rets = {\n    abort,\n    dispatch,\n    getBootstrap,\n    serialize,\n    unserialize,\n    makeTrapHandler,\n    Trap: /** @type {Trap | undefined} */ (undefined),\n  };\n\n  if (trapGuest) {\n    assert.typeof(trapGuest, 'function', X`opts.trapGuest must be a function`);\n\n    // Create the Trap proxy maker.\n    const makeTrapImpl = implMethod => (target, ...implArgs) => {\n      assert(\n        Promise.resolve(target) !== target,\n        X`Trap(${target}) target cannot be a promise`,\n      );\n\n      const slot = valToSlot.get(target);\n      assert(\n        slot && slot[1] === '-',\n        X`Trap(${target}) target was not imported`,\n      );\n      assert(\n        slot[0] === 't',\n        X`Trap(${target}) imported target was not created with makeTrapHandler`,\n      );\n\n      // Send a \"trap\" message.\n      lastQuestionID += 1;\n      const questionID = `${ourId}#${lastQuestionID}`;\n\n      // Encode the \"method\" parameter of the CTP_CALL.\n      let method;\n      switch (implMethod) {\n        case 'get': {\n          const [prop] = implArgs;\n          method = serialize(harden([prop]));\n          break;\n        }\n        case 'applyFunction': {\n          const [args] = implArgs;\n          method = serialize(harden([null, args]));\n          break;\n        }\n        case 'applyMethod': {\n          const [prop, args] = implArgs;\n          method = serialize(harden([prop, args]));\n          break;\n        }\n        default: {\n          assert.fail(X`Internal error; unrecognized implMethod ${implMethod}`);\n        }\n      }\n\n      // Set up the trap call with its identifying information and a way to send\n      // messages over the current CapTP data channel.\n      const [isException, serialized] = trapGuest({\n        trapMethod: implMethod,\n        slot,\n        trapArgs: implArgs,\n        startTrap: () => {\n          // Send the call metadata over the connection.\n          send({\n            type: 'CTP_CALL',\n            epoch,\n            trap: true, // This is the magic marker.\n            questionID,\n            target: slot,\n            method,\n          });\n\n          // Return an IterationObserver.\n          const makeIteratorMethod = (iteratorMethod, done) => (...args) => {\n            send({\n              type: 'CTP_TRAP_ITERATE',\n              epoch,\n              questionID,\n              serialized: serialize(harden([iteratorMethod, args])),\n            });\n            return harden({ done, value: undefined });\n          };\n          return harden({\n            next: makeIteratorMethod('next', false),\n            return: makeIteratorMethod('return', true),\n            throw: makeIteratorMethod('throw', true),\n          });\n        },\n      });\n\n      const value = unserialize(serialized);\n      assert(\n        !isThenable(value),\n        X`Trap(${target}) reply cannot be a Thenable; have ${value}`,\n      );\n\n      if (isException) {\n        throw value;\n      }\n      return value;\n    };\n\n    /** @type {TrapImpl} */\n    const trapImpl = {\n      applyFunction: makeTrapImpl('applyFunction'),\n      applyMethod: makeTrapImpl('applyMethod'),\n      get: makeTrapImpl('get'),\n    };\n    harden(trapImpl);\n\n    rets.Trap = makeTrap(trapImpl);\n  }\n\n  return harden(rets);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}