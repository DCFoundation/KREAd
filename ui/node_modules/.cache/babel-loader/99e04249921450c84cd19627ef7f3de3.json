{"ast":null,"code":"// @ts-check\n\n/**\n * @template T\n * @typedef {import('@endo/promise-kit').ERef<T>} ERef\n */\n\n/**\n * @template T\n * @typedef {import('@endo/promise-kit').PromiseRecord<T>} PromiseRecord\n */\n\n/**\n * @template T\n * @typedef {{\n *   [Symbol.asyncIterator]: () => AsyncIterator<T, T>\n * }} ConsistentAsyncIterable\n * An AsyncIterable that returns the same type as it yields.\n */\n\n/**\n * @template T\n * @typedef {Object} IterationObserver<T>\n * A valid sequence of calls to the methods of an `IterationObserver`\n * represents an iteration. A valid sequence consists of any number of calls\n * to `updateState` with the successive non-final values, followed by a\n * final call to either `finish` with a successful `completion` value\n * or `fail` with the alleged `reason` for failure. After at most one\n * terminating calls, no further calls to these methods are valid and must be\n * rejected.\n * @property {(nonFinalValue: T) => void} updateState\n * @property {(completion: T) => void} finish\n * @property {(reason: any) => void} fail\n */\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {number | undefined} UpdateCount a value used to mark the position\n * in the update stream. For the last state, the updateCount is undefined.\n */\n\n/**\n * @template T\n * @typedef {Object} UpdateRecord<T>\n * @property {T} value is whatever state the service wants to publish\n * @property {UpdateCount} updateCount is a value that identifies the update\n */\n\n/**\n * @template T\n * @callback GetUpdateSince<T> Can be called repeatedly to get a sequence of\n * update records\n * @param {UpdateCount} [updateCount] return update record as of an update\n * count. If the `updateCount` argument is omitted or differs from the current\n * update count, return the current record.\n * Otherwise, after the next state change, the promise will resolve to the\n * then-current value of the record.\n * @returns {Promise<UpdateRecord<T>>} resolves to the corresponding\n * update\n */\n\n/**\n * @template T\n * @typedef {Object} BaseNotifier<T> an object that can be used to get the\n * current state or updates\n * @property {GetUpdateSince<T>} getUpdateSince return update record as of an\n * update count.\n */\n\n/**\n * @template T\n * @typedef {BaseNotifier<T>} NotifierInternals Will be shared between machines,\n * so it must be safe to expose. But other software should avoid depending on\n * its internal structure.\n */\n\n/**\n * @template T\n * @typedef {BaseNotifier<T> &\n *   ConsistentAsyncIterable<T> &\n *   SharableNotifier<T>\n * } Notifier<T> an object that can be used to get the current state or updates\n */\n\n/**\n * @template T\n * @typedef {Object} SharableNotifier\n * @property {() => ERef<NotifierInternals<T>>} getSharableNotifierInternals\n * Used to replicate the multicast values at other sites. To manually create a\n * local representative of a Notification, do\n * ```js\n * localIterable =\n *   makeNotifier(E(remoteIterable).getSharableNotifierInternals());\n * ```\n * The resulting `localIterable` also supports such remote use, and\n * will return access to the same representation.\n */\n\n/**\n * @template T\n * @typedef {Object} NotifierRecord<T> the produced notifier/updater pair\n * @property {IterationObserver<T>} updater the (closely-held) notifier producer\n * @property {Notifier<T>} notifier the (widely-held) notifier consumer\n */\n// /////////////////////////////////////////////////////////////////////////////\n// eslint-disable-next-line jsdoc/require-property\n\n/**\n * @template T\n * @typedef {{}} BaseSubscription<T>\n */\n\n/**\n * @template T\n * @typedef {Object} SubscriptionInternals\n * Will be shared between machines, so it must be safe to expose. But other\n * software should avoid depending on its internal structure.\n * @property {ERef<IteratorResult<T, T>>} head internal only\n * @property {Promise<SubscriptionInternals<T>>} tail internal onli\n */\n\n/**\n * @template T\n * @typedef {BaseSubscription<T> &\n *   ConsistentAsyncIterable<T> &\n *   SharableSubscription<T>} Subscription<T>\n * A form of AsyncIterable supporting distributed and multicast usage.\n */\n\n/**\n * @template T\n * @typedef {Object} SharableSubscription\n * @property {() => ERef<SubscriptionInternals<T>>} getSharableSubscriptionInternals\n * Used to replicate the multicast values at other sites. To manually create a\n * local representative of a Subscription, do\n * ```js\n * localIterable =\n *   makeSubscription(E(remoteIterable).getSharableSubscriptionInternals());\n * ```\n * The resulting `localIterable` also supports such remote use, and\n * will return access to the same representation.\n */\n\n/**\n * @template T\n * @typedef {AsyncIterator<T, T> & ConsistentAsyncIterable<T>} SubscriptionIterator<T>\n * an AsyncIterator supporting distributed and multicast usage.\n *\n * @property {() => Subscription<T>} subscribe\n * Get a new subscription whose starting position is this iterator's current\n * position.\n */\n\n/**\n * @template T\n * @typedef {Object} SubscriptionRecord<T>\n * @property {IterationObserver<T>} publication\n * @property {Subscription<T>} subscription\n */","map":{"version":3,"names":[],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@agoric/notifier/src/types.js"],"sourcesContent":["// @ts-check\n\n/**\n * @template T\n * @typedef {import('@endo/promise-kit').ERef<T>} ERef\n */\n\n/**\n * @template T\n * @typedef {import('@endo/promise-kit').PromiseRecord<T>} PromiseRecord\n */\n\n/**\n * @template T\n * @typedef {{\n *   [Symbol.asyncIterator]: () => AsyncIterator<T, T>\n * }} ConsistentAsyncIterable\n * An AsyncIterable that returns the same type as it yields.\n */\n\n/**\n * @template T\n * @typedef {Object} IterationObserver<T>\n * A valid sequence of calls to the methods of an `IterationObserver`\n * represents an iteration. A valid sequence consists of any number of calls\n * to `updateState` with the successive non-final values, followed by a\n * final call to either `finish` with a successful `completion` value\n * or `fail` with the alleged `reason` for failure. After at most one\n * terminating calls, no further calls to these methods are valid and must be\n * rejected.\n * @property {(nonFinalValue: T) => void} updateState\n * @property {(completion: T) => void} finish\n * @property {(reason: any) => void} fail\n */\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {number | undefined} UpdateCount a value used to mark the position\n * in the update stream. For the last state, the updateCount is undefined.\n */\n\n/**\n * @template T\n * @typedef {Object} UpdateRecord<T>\n * @property {T} value is whatever state the service wants to publish\n * @property {UpdateCount} updateCount is a value that identifies the update\n */\n\n/**\n * @template T\n * @callback GetUpdateSince<T> Can be called repeatedly to get a sequence of\n * update records\n * @param {UpdateCount} [updateCount] return update record as of an update\n * count. If the `updateCount` argument is omitted or differs from the current\n * update count, return the current record.\n * Otherwise, after the next state change, the promise will resolve to the\n * then-current value of the record.\n * @returns {Promise<UpdateRecord<T>>} resolves to the corresponding\n * update\n */\n\n/**\n * @template T\n * @typedef {Object} BaseNotifier<T> an object that can be used to get the\n * current state or updates\n * @property {GetUpdateSince<T>} getUpdateSince return update record as of an\n * update count.\n */\n\n/**\n * @template T\n * @typedef {BaseNotifier<T>} NotifierInternals Will be shared between machines,\n * so it must be safe to expose. But other software should avoid depending on\n * its internal structure.\n */\n\n/**\n * @template T\n * @typedef {BaseNotifier<T> &\n *   ConsistentAsyncIterable<T> &\n *   SharableNotifier<T>\n * } Notifier<T> an object that can be used to get the current state or updates\n */\n\n/**\n * @template T\n * @typedef {Object} SharableNotifier\n * @property {() => ERef<NotifierInternals<T>>} getSharableNotifierInternals\n * Used to replicate the multicast values at other sites. To manually create a\n * local representative of a Notification, do\n * ```js\n * localIterable =\n *   makeNotifier(E(remoteIterable).getSharableNotifierInternals());\n * ```\n * The resulting `localIterable` also supports such remote use, and\n * will return access to the same representation.\n */\n\n/**\n * @template T\n * @typedef {Object} NotifierRecord<T> the produced notifier/updater pair\n * @property {IterationObserver<T>} updater the (closely-held) notifier producer\n * @property {Notifier<T>} notifier the (widely-held) notifier consumer\n */\n\n// /////////////////////////////////////////////////////////////////////////////\n\n// eslint-disable-next-line jsdoc/require-property\n/**\n * @template T\n * @typedef {{}} BaseSubscription<T>\n */\n\n/**\n * @template T\n * @typedef {Object} SubscriptionInternals\n * Will be shared between machines, so it must be safe to expose. But other\n * software should avoid depending on its internal structure.\n * @property {ERef<IteratorResult<T, T>>} head internal only\n * @property {Promise<SubscriptionInternals<T>>} tail internal onli\n */\n\n/**\n * @template T\n * @typedef {BaseSubscription<T> &\n *   ConsistentAsyncIterable<T> &\n *   SharableSubscription<T>} Subscription<T>\n * A form of AsyncIterable supporting distributed and multicast usage.\n */\n\n/**\n * @template T\n * @typedef {Object} SharableSubscription\n * @property {() => ERef<SubscriptionInternals<T>>} getSharableSubscriptionInternals\n * Used to replicate the multicast values at other sites. To manually create a\n * local representative of a Subscription, do\n * ```js\n * localIterable =\n *   makeSubscription(E(remoteIterable).getSharableSubscriptionInternals());\n * ```\n * The resulting `localIterable` also supports such remote use, and\n * will return access to the same representation.\n */\n\n/**\n * @template T\n * @typedef {AsyncIterator<T, T> & ConsistentAsyncIterable<T>} SubscriptionIterator<T>\n * an AsyncIterator supporting distributed and multicast usage.\n *\n * @property {() => Subscription<T>} subscribe\n * Get a new subscription whose starting position is this iterator's current\n * position.\n */\n\n/**\n * @template T\n * @typedef {Object} SubscriptionRecord<T>\n * @property {IterationObserver<T>} publication\n * @property {Subscription<T>} subscription\n */\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"script"}