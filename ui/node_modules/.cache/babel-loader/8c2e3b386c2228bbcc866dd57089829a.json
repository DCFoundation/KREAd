{"ast":null,"code":"// @ts-check\nimport { Set, String, arrayJoin, arraySlice, freeze, is, isError, setAdd, setHas, stringIncludes, stringStartsWith, stringifyJson, toStringTagSymbol } from '../commons.js';\n/**\n * Joins English terms with commas and an optional conjunction.\n *\n * @param {string[]} terms\n * @param {\"and\" | \"or\"} conjunction\n */\n\nexport const enJoin = (terms, conjunction) => {\n  if (terms.length === 0) {\n    return '(none)';\n  } else if (terms.length === 1) {\n    return terms[0];\n  } else if (terms.length === 2) {\n    const [first, second] = terms;\n    return `${first} ${conjunction} ${second}`;\n  } else {\n    return `${arrayJoin(arraySlice(terms, 0, -1), ', ')}, ${conjunction} ${terms[terms.length - 1]}`;\n  }\n};\n/**\n * Prepend the correct indefinite article onto a noun, typically a typeof\n * result, e.g., \"an object\" vs. \"a number\"\n *\n * @param {string} str The noun to prepend\n * @returns {string} The noun prepended with a/an\n */\n\nconst an = str => {\n  str = `${str}`;\n\n  if (str.length >= 1 && stringIncludes('aeiouAEIOU', str[0])) {\n    return `an ${str}`;\n  }\n\n  return `a ${str}`;\n};\n\nfreeze(an);\nexport { an };\n/**\n * Like `JSON.stringify` but does not blow up if given a cycle or a bigint.\n * This is not\n * intended to be a serialization to support any useful unserialization,\n * or any programmatic use of the resulting string. The string is intended\n * *only* for showing a human under benign conditions, in order to be\n * informative enough for some\n * logging purposes. As such, this `bestEffortStringify` has an\n * imprecise specification and may change over time.\n *\n * The current `bestEffortStringify` possibly emits too many \"seen\"\n * markings: Not only for cycles, but also for repeated subtrees by\n * object identity.\n *\n * As a best effort only for diagnostic interpretation by humans,\n * `bestEffortStringify` also turns various cases that normal\n * `JSON.stringify` skips or errors on, like `undefined` or bigints,\n * into strings that convey their meaning. To distinguish this from\n * strings in the input, these synthesized strings always begin and\n * end with square brackets. To distinguish those strings from an\n * input string with square brackets, and input string that starts\n * with an open square bracket `[` is itself placed in square brackets.\n *\n * @param {any} payload\n * @param {(string|number)=} spaces\n * @returns {string}\n */\n\nconst bestEffortStringify = function (payload) {\n  let spaces = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  const seenSet = new Set();\n\n  const replacer = (_, val) => {\n    switch (typeof val) {\n      case 'object':\n        {\n          if (val === null) {\n            return null;\n          }\n\n          if (setHas(seenSet, val)) {\n            return '[Seen]';\n          }\n\n          setAdd(seenSet, val);\n\n          if (isError(val)) {\n            return `[${val.name}: ${val.message}]`;\n          }\n\n          if (toStringTagSymbol in val) {\n            // For the built-ins that have or inherit a `Symbol.toStringTag`-named\n            // property, most of them inherit the default `toString` method,\n            // which will print in a similar manner: `\"[object Foo]\"` vs\n            // `\"[Foo]\"`. The exceptions are\n            //    * `Symbol.prototype`, `BigInt.prototype`, `String.prototype`\n            //      which don't matter to us since we handle primitives\n            //      separately and we don't care about primitive wrapper objects.\n            //    * TODO\n            //      `Date.prototype`, `TypedArray.prototype`.\n            //      Hmmm, we probably should make special cases for these. We're\n            //      not using these yet, so it's not urgent. But others will run\n            //      into these.\n            //\n            // Once #2018 is closed, the only objects in our code that have or\n            // inherit a `Symbol.toStringTag`-named property are remotables\n            // or their remote presences.\n            // This printing will do a good job for these without\n            // violating abstraction layering. This behavior makes sense\n            // purely in terms of JavaScript concepts. That's some of the\n            // motivation for choosing that representation of remotables\n            // and their remote presences in the first place.\n            return `[${val[toStringTagSymbol]}]`;\n          }\n\n          return val;\n        }\n\n      case 'function':\n        {\n          return `[Function ${val.name || '<anon>'}]`;\n        }\n\n      case 'string':\n        {\n          if (stringStartsWith(val, '[')) {\n            return `[${val}]`;\n          }\n\n          return val;\n        }\n\n      case 'undefined':\n      case 'symbol':\n        {\n          return `[${String(val)}]`;\n        }\n\n      case 'bigint':\n        {\n          return `[${val}n]`;\n        }\n\n      case 'number':\n        {\n          if (is(val, NaN)) {\n            return '[NaN]';\n          } else if (val === Infinity) {\n            return '[Infinity]';\n          } else if (val === -Infinity) {\n            return '[-Infinity]';\n          }\n\n          return val;\n        }\n\n      default:\n        {\n          return val;\n        }\n    }\n  };\n\n  try {\n    return stringifyJson(payload, replacer, spaces);\n  } catch (_err) {\n    // Don't do anything more fancy here if there is any\n    // chance that might throw, unless you surround that\n    // with another try-catch-recovery. For example,\n    // the caught thing might be a proxy or other exotic\n    // object rather than an error. The proxy might throw\n    // whenever it is possible for it to.\n    return '[Something that failed to stringify]';\n  }\n};\n\nfreeze(bestEffortStringify);\nexport { bestEffortStringify };","map":{"version":3,"names":["Set","String","arrayJoin","arraySlice","freeze","is","isError","setAdd","setHas","stringIncludes","stringStartsWith","stringifyJson","toStringTagSymbol","enJoin","terms","conjunction","length","first","second","an","str","bestEffortStringify","payload","spaces","undefined","seenSet","replacer","_","val","name","message","NaN","Infinity","_err"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/error/stringify-utils.js"],"sourcesContent":["// @ts-check\n\nimport {\n  Set,\n  String,\n  arrayJoin,\n  arraySlice,\n  freeze,\n  is,\n  isError,\n  setAdd,\n  setHas,\n  stringIncludes,\n  stringStartsWith,\n  stringifyJson,\n  toStringTagSymbol,\n} from '../commons.js';\n\n/**\n * Joins English terms with commas and an optional conjunction.\n *\n * @param {string[]} terms\n * @param {\"and\" | \"or\"} conjunction\n */\nexport const enJoin = (terms, conjunction) => {\n  if (terms.length === 0) {\n    return '(none)';\n  } else if (terms.length === 1) {\n    return terms[0];\n  } else if (terms.length === 2) {\n    const [first, second] = terms;\n    return `${first} ${conjunction} ${second}`;\n  } else {\n    return `${arrayJoin(arraySlice(terms, 0, -1), ', ')}, ${conjunction} ${\n      terms[terms.length - 1]\n    }`;\n  }\n};\n\n/**\n * Prepend the correct indefinite article onto a noun, typically a typeof\n * result, e.g., \"an object\" vs. \"a number\"\n *\n * @param {string} str The noun to prepend\n * @returns {string} The noun prepended with a/an\n */\nconst an = str => {\n  str = `${str}`;\n  if (str.length >= 1 && stringIncludes('aeiouAEIOU', str[0])) {\n    return `an ${str}`;\n  }\n  return `a ${str}`;\n};\nfreeze(an);\nexport { an };\n\n/**\n * Like `JSON.stringify` but does not blow up if given a cycle or a bigint.\n * This is not\n * intended to be a serialization to support any useful unserialization,\n * or any programmatic use of the resulting string. The string is intended\n * *only* for showing a human under benign conditions, in order to be\n * informative enough for some\n * logging purposes. As such, this `bestEffortStringify` has an\n * imprecise specification and may change over time.\n *\n * The current `bestEffortStringify` possibly emits too many \"seen\"\n * markings: Not only for cycles, but also for repeated subtrees by\n * object identity.\n *\n * As a best effort only for diagnostic interpretation by humans,\n * `bestEffortStringify` also turns various cases that normal\n * `JSON.stringify` skips or errors on, like `undefined` or bigints,\n * into strings that convey their meaning. To distinguish this from\n * strings in the input, these synthesized strings always begin and\n * end with square brackets. To distinguish those strings from an\n * input string with square brackets, and input string that starts\n * with an open square bracket `[` is itself placed in square brackets.\n *\n * @param {any} payload\n * @param {(string|number)=} spaces\n * @returns {string}\n */\nconst bestEffortStringify = (payload, spaces = undefined) => {\n  const seenSet = new Set();\n  const replacer = (_, val) => {\n    switch (typeof val) {\n      case 'object': {\n        if (val === null) {\n          return null;\n        }\n        if (setHas(seenSet, val)) {\n          return '[Seen]';\n        }\n        setAdd(seenSet, val);\n        if (isError(val)) {\n          return `[${val.name}: ${val.message}]`;\n        }\n        if (toStringTagSymbol in val) {\n          // For the built-ins that have or inherit a `Symbol.toStringTag`-named\n          // property, most of them inherit the default `toString` method,\n          // which will print in a similar manner: `\"[object Foo]\"` vs\n          // `\"[Foo]\"`. The exceptions are\n          //    * `Symbol.prototype`, `BigInt.prototype`, `String.prototype`\n          //      which don't matter to us since we handle primitives\n          //      separately and we don't care about primitive wrapper objects.\n          //    * TODO\n          //      `Date.prototype`, `TypedArray.prototype`.\n          //      Hmmm, we probably should make special cases for these. We're\n          //      not using these yet, so it's not urgent. But others will run\n          //      into these.\n          //\n          // Once #2018 is closed, the only objects in our code that have or\n          // inherit a `Symbol.toStringTag`-named property are remotables\n          // or their remote presences.\n          // This printing will do a good job for these without\n          // violating abstraction layering. This behavior makes sense\n          // purely in terms of JavaScript concepts. That's some of the\n          // motivation for choosing that representation of remotables\n          // and their remote presences in the first place.\n          return `[${val[toStringTagSymbol]}]`;\n        }\n        return val;\n      }\n      case 'function': {\n        return `[Function ${val.name || '<anon>'}]`;\n      }\n      case 'string': {\n        if (stringStartsWith(val, '[')) {\n          return `[${val}]`;\n        }\n        return val;\n      }\n      case 'undefined':\n      case 'symbol': {\n        return `[${String(val)}]`;\n      }\n      case 'bigint': {\n        return `[${val}n]`;\n      }\n      case 'number': {\n        if (is(val, NaN)) {\n          return '[NaN]';\n        } else if (val === Infinity) {\n          return '[Infinity]';\n        } else if (val === -Infinity) {\n          return '[-Infinity]';\n        }\n        return val;\n      }\n      default: {\n        return val;\n      }\n    }\n  };\n  try {\n    return stringifyJson(payload, replacer, spaces);\n  } catch (_err) {\n    // Don't do anything more fancy here if there is any\n    // chance that might throw, unless you surround that\n    // with another try-catch-recovery. For example,\n    // the caught thing might be a proxy or other exotic\n    // object rather than an error. The proxy might throw\n    // whenever it is possible for it to.\n    return '[Something that failed to stringify]';\n  }\n};\nfreeze(bestEffortStringify);\nexport { bestEffortStringify };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}