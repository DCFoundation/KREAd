{"ast":null,"code":"// @ts-check\nimport { isObject } from './helpers/passStyle-helpers.js';\nimport { passStyleOf } from './passStyleOf.js';\n/** @typedef {import('./types.js').Passable} Passable */\n\n/** @template T @typedef {import('./types.js').CopyArray<T>} CopyArray */\n\n/** @template T @typedef {import('./types.js').CopyRecord<T>} CopyRecord */\n\n/** @typedef {import('./types.js').Remotable} Remotable */\n\nconst {\n  details: X,\n  quote: q\n} = assert;\n/**\n * Check whether the argument is a pass-by-copy array, AKA a \"copyArray\"\n * in @endo/marshal terms\n *\n * @param {Passable} array\n * @returns {array is CopyArray<any>}\n */\n\nconst isCopyArray = array => passStyleOf(array) === 'copyArray';\n\nharden(isCopyArray);\n/**\n * Check whether the argument is a pass-by-copy record, AKA a\n * \"copyRecord\" in @endo/marshal terms\n *\n * @param {Passable} record\n * @returns {record is CopyRecord<any>}\n */\n\nconst isRecord = record => passStyleOf(record) === 'copyRecord';\n\nharden(isRecord);\n/**\n * Check whether the argument is a remotable.\n *\n * @param {Passable} remotable\n * @returns {remotable is Remotable}\n */\n\nconst isRemotable = remotable => passStyleOf(remotable) === 'remotable';\n\nharden(isRemotable);\n/**\n * @callback AssertArray\n * @param {Passable} array\n * @param {string=} optNameOfArray\n * @returns {asserts array is CopyArray<any>}\n */\n\n/** @type {AssertArray} */\n\nconst assertCopyArray = function (array) {\n  let optNameOfArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Alleged array';\n  const passStyle = passStyleOf(array);\n  return assert(passStyle === 'copyArray', X`${q(optNameOfArray)} ${array} must be a pass-by-copy array, not ${q(passStyle)}`);\n};\n\nharden(assertCopyArray);\n/**\n * @callback AssertRecord\n * @param {Passable} record\n * @param {string=} optNameOfRecord\n * @returns {asserts record is CopyRecord<any>}\n */\n\n/** @type {AssertRecord} */\n\nconst assertRecord = function (record) {\n  let optNameOfRecord = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Alleged record';\n  const passStyle = passStyleOf(record);\n  return assert(passStyle === 'copyRecord', X`${q(optNameOfRecord)} ${record} must be a pass-by-copy record, not ${q(passStyle)}`);\n};\n\nharden(assertRecord);\n/**\n * @callback AssertRemotable\n * @param {Passable} remotable\n * @param {string=} optNameOfRemotable\n * @returns {asserts remotable is Remotable}\n */\n\n/** @type {AssertRemotable} */\n\nconst assertRemotable = function (remotable) {\n  let optNameOfRemotable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Alleged remotable';\n  const passStyle = passStyleOf(remotable);\n  return assert(passStyle === 'remotable', X`${q(optNameOfRemotable)} ${remotable} must be a remotable, not ${q(passStyle)}`);\n};\n\nharden(assertRemotable);\n\nconst assertPure = function (pureData) {\n  let optNameOfData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Allegedly pure data';\n  const passStyle = passStyleOf(pureData);\n\n  switch (passStyle) {\n    case 'copyArray':\n    case 'copyRecord':\n    case 'tagged':\n      {\n        return true;\n      }\n\n    default:\n      {\n        if (!isObject(pureData)) {\n          return true;\n        }\n\n        assert.fail(X`${q(optNameOfData)} ${pureData} must be pure, not a ${q(passStyle)}`);\n      }\n  }\n};\n\nharden(assertPure);\nexport { assertRecord, assertCopyArray, assertRemotable, isRemotable, isRecord, isCopyArray, assertPure };","map":{"version":3,"names":["isObject","passStyleOf","details","X","quote","q","assert","isCopyArray","array","harden","isRecord","record","isRemotable","remotable","assertCopyArray","optNameOfArray","passStyle","assertRecord","optNameOfRecord","assertRemotable","optNameOfRemotable","assertPure","pureData","optNameOfData","fail"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/typeGuards.js"],"sourcesContent":["// @ts-check\n\nimport { isObject } from './helpers/passStyle-helpers.js';\nimport { passStyleOf } from './passStyleOf.js';\n\n/** @typedef {import('./types.js').Passable} Passable */\n/** @template T @typedef {import('./types.js').CopyArray<T>} CopyArray */\n/** @template T @typedef {import('./types.js').CopyRecord<T>} CopyRecord */\n/** @typedef {import('./types.js').Remotable} Remotable */\n\nconst { details: X, quote: q } = assert;\n\n/**\n * Check whether the argument is a pass-by-copy array, AKA a \"copyArray\"\n * in @endo/marshal terms\n *\n * @param {Passable} array\n * @returns {array is CopyArray<any>}\n */\nconst isCopyArray = array => passStyleOf(array) === 'copyArray';\nharden(isCopyArray);\n\n/**\n * Check whether the argument is a pass-by-copy record, AKA a\n * \"copyRecord\" in @endo/marshal terms\n *\n * @param {Passable} record\n * @returns {record is CopyRecord<any>}\n */\nconst isRecord = record => passStyleOf(record) === 'copyRecord';\nharden(isRecord);\n\n/**\n * Check whether the argument is a remotable.\n *\n * @param {Passable} remotable\n * @returns {remotable is Remotable}\n */\nconst isRemotable = remotable => passStyleOf(remotable) === 'remotable';\nharden(isRemotable);\n\n/**\n * @callback AssertArray\n * @param {Passable} array\n * @param {string=} optNameOfArray\n * @returns {asserts array is CopyArray<any>}\n */\n\n/** @type {AssertArray} */\nconst assertCopyArray = (array, optNameOfArray = 'Alleged array') => {\n  const passStyle = passStyleOf(array);\n  return assert(\n    passStyle === 'copyArray',\n    X`${q(optNameOfArray)} ${array} must be a pass-by-copy array, not ${q(\n      passStyle,\n    )}`,\n  );\n};\nharden(assertCopyArray);\n\n/**\n * @callback AssertRecord\n * @param {Passable} record\n * @param {string=} optNameOfRecord\n * @returns {asserts record is CopyRecord<any>}\n */\n\n/** @type {AssertRecord} */\nconst assertRecord = (record, optNameOfRecord = 'Alleged record') => {\n  const passStyle = passStyleOf(record);\n  return assert(\n    passStyle === 'copyRecord',\n    X`${q(optNameOfRecord)} ${record} must be a pass-by-copy record, not ${q(\n      passStyle,\n    )}`,\n  );\n};\nharden(assertRecord);\n\n/**\n * @callback AssertRemotable\n * @param {Passable} remotable\n * @param {string=} optNameOfRemotable\n * @returns {asserts remotable is Remotable}\n */\n\n/** @type {AssertRemotable} */\nconst assertRemotable = (\n  remotable,\n  optNameOfRemotable = 'Alleged remotable',\n) => {\n  const passStyle = passStyleOf(remotable);\n  return assert(\n    passStyle === 'remotable',\n    X`${q(optNameOfRemotable)} ${remotable} must be a remotable, not ${q(\n      passStyle,\n    )}`,\n  );\n};\nharden(assertRemotable);\n\nconst assertPure = (pureData, optNameOfData = 'Allegedly pure data') => {\n  const passStyle = passStyleOf(pureData);\n  switch (passStyle) {\n    case 'copyArray':\n    case 'copyRecord':\n    case 'tagged': {\n      return true;\n    }\n    default: {\n      if (!isObject(pureData)) {\n        return true;\n      }\n      assert.fail(\n        X`${q(optNameOfData)} ${pureData} must be pure, not a ${q(passStyle)}`,\n      );\n    }\n  }\n};\nharden(assertPure);\n\nexport {\n  assertRecord,\n  assertCopyArray,\n  assertRemotable,\n  isRemotable,\n  isRecord,\n  isCopyArray,\n  assertPure,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}