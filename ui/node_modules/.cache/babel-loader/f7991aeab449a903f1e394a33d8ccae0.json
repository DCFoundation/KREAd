{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n// For brevity, in this file, as in module-load.js, the term \"moduleRecord\"\n// without qualification means \"module compartment record\".\n// This is a super-set of the \"static module record\", that is reusable between\n// compartments with different hooks.\n// The \"module compartment record\" captures the compartment and overlays the\n// module's \"imports\" with the more specific \"resolvedImports\" as inferred from\n// the particular compartment's \"resolveHook\".\nimport { assert } from './error/assert.js';\nimport { makeModuleInstance, makeThirdPartyModuleInstance } from './module-instance.js';\nimport { Map, ReferenceError, TypeError, entries, isArray, isObject, mapGet, mapHas, mapSet, weakmapGet } from './commons.js';\nconst {\n  quote: q\n} = assert; // `link` creates `ModuleInstances` and `ModuleNamespaces` for a module and its\n// transitive dependencies and connects their imports and exports.\n// After linking, the resulting working set is ready to be executed.\n// The linker only concerns itself with module namespaces that are objects with\n// property descriptors for their exports, which the Compartment proxies with\n// the actual `ModuleNamespace`.\n\nexport const link = (compartmentPrivateFields, moduleAliases, compartment, moduleSpecifier) => {\n  const {\n    name: compartmentName,\n    moduleRecords\n  } = weakmapGet(compartmentPrivateFields, compartment);\n  const moduleRecord = mapGet(moduleRecords, moduleSpecifier);\n\n  if (moduleRecord === undefined) {\n    throw new ReferenceError(`Missing link to module ${q(moduleSpecifier)} from compartment ${q(compartmentName)}`);\n  } // Mutual recursion so there's no confusion about which\n  // compartment is in context: the module record may be in another\n  // compartment, denoted by moduleRecord.compartment.\n  // eslint-disable-next-line no-use-before-define\n\n\n  return instantiate(compartmentPrivateFields, moduleAliases, moduleRecord);\n};\n\nfunction isPrecompiled(staticModuleRecord) {\n  return typeof staticModuleRecord.__syncModuleProgram__ === 'string';\n}\n\nfunction validatePrecompiledStaticModuleRecord(staticModuleRecord, moduleSpecifier) {\n  const {\n    __fixedExportMap__,\n    __liveExportMap__\n  } = staticModuleRecord;\n  assert(isObject(__fixedExportMap__), `Property '__fixedExportMap__' of a precompiled module record must be an object, got ${q(__fixedExportMap__)}, for module ${q(moduleSpecifier)}`);\n  assert(isObject(__liveExportMap__), `Property '__liveExportMap__' of a precompiled module record must be an object, got ${q(__liveExportMap__)}, for module ${q(moduleSpecifier)}`);\n}\n\nfunction isThirdParty(staticModuleRecord) {\n  return typeof staticModuleRecord.execute === 'function';\n}\n\nfunction validateThirdPartyStaticModuleRecord(staticModuleRecord, moduleSpecifier) {\n  const {\n    exports\n  } = staticModuleRecord;\n  assert(isArray(exports), `Property 'exports' of a third-party static module record must be an array, got ${q(exports)}, for module ${q(moduleSpecifier)}`);\n}\n\nfunction validateStaticModuleRecord(staticModuleRecord, moduleSpecifier) {\n  assert(isObject(staticModuleRecord), `Static module records must be of type object, got ${q(staticModuleRecord)}, for module ${q(moduleSpecifier)}`);\n  const {\n    imports,\n    exports,\n    reexports = []\n  } = staticModuleRecord;\n  assert(isArray(imports), `Property 'imports' of a static module record must be an array, got ${q(imports)}, for module ${q(moduleSpecifier)}`);\n  assert(isArray(exports), `Property 'exports' of a precompiled module record must be an array, got ${q(exports)}, for module ${q(moduleSpecifier)}`);\n  assert(isArray(reexports), `Property 'reexports' of a precompiled module record must be an array if present, got ${q(reexports)}, for module ${q(moduleSpecifier)}`);\n}\n\nexport const instantiate = (compartmentPrivateFields, moduleAliases, moduleRecord) => {\n  const {\n    compartment,\n    moduleSpecifier,\n    resolvedImports,\n    staticModuleRecord\n  } = moduleRecord;\n  const {\n    instances\n  } = weakmapGet(compartmentPrivateFields, compartment); // Memoize.\n\n  if (mapHas(instances, moduleSpecifier)) {\n    return mapGet(instances, moduleSpecifier);\n  }\n\n  validateStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n  const importedInstances = new Map();\n  let moduleInstance;\n\n  if (isPrecompiled(staticModuleRecord)) {\n    validatePrecompiledStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n    moduleInstance = makeModuleInstance(compartmentPrivateFields, moduleAliases, moduleRecord, importedInstances);\n  } else if (isThirdParty(staticModuleRecord)) {\n    validateThirdPartyStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n    moduleInstance = makeThirdPartyModuleInstance(compartmentPrivateFields, staticModuleRecord, compartment, moduleAliases, moduleSpecifier, resolvedImports);\n  } else {\n    throw new TypeError(`importHook must return a static module record, got ${q(staticModuleRecord)}`);\n  } // Memoize.\n\n\n  mapSet(instances, moduleSpecifier, moduleInstance); // Link dependency modules.\n\n  for (const [importSpecifier, resolvedSpecifier] of entries(resolvedImports)) {\n    const importedInstance = link(compartmentPrivateFields, moduleAliases, compartment, resolvedSpecifier);\n    mapSet(importedInstances, importSpecifier, importedInstance);\n  }\n\n  return moduleInstance;\n};","map":{"version":3,"names":["assert","makeModuleInstance","makeThirdPartyModuleInstance","Map","ReferenceError","TypeError","entries","isArray","isObject","mapGet","mapHas","mapSet","weakmapGet","quote","q","link","compartmentPrivateFields","moduleAliases","compartment","moduleSpecifier","name","compartmentName","moduleRecords","moduleRecord","undefined","instantiate","isPrecompiled","staticModuleRecord","__syncModuleProgram__","validatePrecompiledStaticModuleRecord","__fixedExportMap__","__liveExportMap__","isThirdParty","execute","validateThirdPartyStaticModuleRecord","exports","validateStaticModuleRecord","imports","reexports","resolvedImports","instances","importedInstances","moduleInstance","importSpecifier","resolvedSpecifier","importedInstance"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/module-link.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n\n// For brevity, in this file, as in module-load.js, the term \"moduleRecord\"\n// without qualification means \"module compartment record\".\n// This is a super-set of the \"static module record\", that is reusable between\n// compartments with different hooks.\n// The \"module compartment record\" captures the compartment and overlays the\n// module's \"imports\" with the more specific \"resolvedImports\" as inferred from\n// the particular compartment's \"resolveHook\".\n\nimport { assert } from './error/assert.js';\nimport {\n  makeModuleInstance,\n  makeThirdPartyModuleInstance,\n} from './module-instance.js';\nimport {\n  Map,\n  ReferenceError,\n  TypeError,\n  entries,\n  isArray,\n  isObject,\n  mapGet,\n  mapHas,\n  mapSet,\n  weakmapGet,\n} from './commons.js';\n\nconst { quote: q } = assert;\n\n// `link` creates `ModuleInstances` and `ModuleNamespaces` for a module and its\n// transitive dependencies and connects their imports and exports.\n// After linking, the resulting working set is ready to be executed.\n// The linker only concerns itself with module namespaces that are objects with\n// property descriptors for their exports, which the Compartment proxies with\n// the actual `ModuleNamespace`.\nexport const link = (\n  compartmentPrivateFields,\n  moduleAliases,\n  compartment,\n  moduleSpecifier,\n) => {\n  const { name: compartmentName, moduleRecords } = weakmapGet(\n    compartmentPrivateFields,\n    compartment,\n  );\n\n  const moduleRecord = mapGet(moduleRecords, moduleSpecifier);\n  if (moduleRecord === undefined) {\n    throw new ReferenceError(\n      `Missing link to module ${q(moduleSpecifier)} from compartment ${q(\n        compartmentName,\n      )}`,\n    );\n  }\n\n  // Mutual recursion so there's no confusion about which\n  // compartment is in context: the module record may be in another\n  // compartment, denoted by moduleRecord.compartment.\n  // eslint-disable-next-line no-use-before-define\n  return instantiate(compartmentPrivateFields, moduleAliases, moduleRecord);\n};\n\nfunction isPrecompiled(staticModuleRecord) {\n  return typeof staticModuleRecord.__syncModuleProgram__ === 'string';\n}\n\nfunction validatePrecompiledStaticModuleRecord(\n  staticModuleRecord,\n  moduleSpecifier,\n) {\n  const { __fixedExportMap__, __liveExportMap__ } = staticModuleRecord;\n  assert(\n    isObject(__fixedExportMap__),\n    `Property '__fixedExportMap__' of a precompiled module record must be an object, got ${q(\n      __fixedExportMap__,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n  assert(\n    isObject(__liveExportMap__),\n    `Property '__liveExportMap__' of a precompiled module record must be an object, got ${q(\n      __liveExportMap__,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n}\n\nfunction isThirdParty(staticModuleRecord) {\n  return typeof staticModuleRecord.execute === 'function';\n}\n\nfunction validateThirdPartyStaticModuleRecord(\n  staticModuleRecord,\n  moduleSpecifier,\n) {\n  const { exports } = staticModuleRecord;\n  assert(\n    isArray(exports),\n    `Property 'exports' of a third-party static module record must be an array, got ${q(\n      exports,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n}\n\nfunction validateStaticModuleRecord(staticModuleRecord, moduleSpecifier) {\n  assert(\n    isObject(staticModuleRecord),\n    `Static module records must be of type object, got ${q(\n      staticModuleRecord,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n  const { imports, exports, reexports = [] } = staticModuleRecord;\n  assert(\n    isArray(imports),\n    `Property 'imports' of a static module record must be an array, got ${q(\n      imports,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n  assert(\n    isArray(exports),\n    `Property 'exports' of a precompiled module record must be an array, got ${q(\n      exports,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n  assert(\n    isArray(reexports),\n    `Property 'reexports' of a precompiled module record must be an array if present, got ${q(\n      reexports,\n    )}, for module ${q(moduleSpecifier)}`,\n  );\n}\n\nexport const instantiate = (\n  compartmentPrivateFields,\n  moduleAliases,\n  moduleRecord,\n) => {\n  const {\n    compartment,\n    moduleSpecifier,\n    resolvedImports,\n    staticModuleRecord,\n  } = moduleRecord;\n  const { instances } = weakmapGet(compartmentPrivateFields, compartment);\n\n  // Memoize.\n  if (mapHas(instances, moduleSpecifier)) {\n    return mapGet(instances, moduleSpecifier);\n  }\n\n  validateStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n\n  const importedInstances = new Map();\n  let moduleInstance;\n  if (isPrecompiled(staticModuleRecord)) {\n    validatePrecompiledStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n    moduleInstance = makeModuleInstance(\n      compartmentPrivateFields,\n      moduleAliases,\n      moduleRecord,\n      importedInstances,\n    );\n  } else if (isThirdParty(staticModuleRecord)) {\n    validateThirdPartyStaticModuleRecord(staticModuleRecord, moduleSpecifier);\n    moduleInstance = makeThirdPartyModuleInstance(\n      compartmentPrivateFields,\n      staticModuleRecord,\n      compartment,\n      moduleAliases,\n      moduleSpecifier,\n      resolvedImports,\n    );\n  } else {\n    throw new TypeError(\n      `importHook must return a static module record, got ${q(\n        staticModuleRecord,\n      )}`,\n    );\n  }\n\n  // Memoize.\n  mapSet(instances, moduleSpecifier, moduleInstance);\n\n  // Link dependency modules.\n  for (const [importSpecifier, resolvedSpecifier] of entries(resolvedImports)) {\n    const importedInstance = link(\n      compartmentPrivateFields,\n      moduleAliases,\n      compartment,\n      resolvedSpecifier,\n    );\n    mapSet(importedInstances, importSpecifier, importedInstance);\n  }\n\n  return moduleInstance;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}