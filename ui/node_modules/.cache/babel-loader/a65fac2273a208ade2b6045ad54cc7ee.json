{"ast":null,"code":"// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// Copyright (C) 2018 Agoric\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// based upon:\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n// then copied from proposal-frozen-realms deep-freeze.js\n// then copied from SES/src/bundle/deepFreeze.js\n// @ts-check\nimport { Set, String, TypeError, WeakMap, WeakSet, apply, arrayForEach, defineProperty, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, getPrototypeOf, isInteger, isObject, objectHasOwnProperty, ownKeys, preventExtensions, setAdd, setForEach, setHas, toStringTagSymbol, typedArrayPrototype, weakmapGet, weakmapSet, weaksetAdd, weaksetHas } from './commons.js';\nimport { assert } from './error/assert.js';\n/**\n * @typedef {import('../index.js').Harden} Harden\n */\n// Obtain the string tag accessor of of TypedArray so we can indirectly use the\n// TypedArray brand check it employs.\n\nconst typedArrayToStringTag = getOwnPropertyDescriptor(typedArrayPrototype, toStringTagSymbol);\nassert(typedArrayToStringTag);\nconst getTypedArrayToStringTag = typedArrayToStringTag.get;\nassert(getTypedArrayToStringTag); // Exported for tests.\n\n/** @param {unknown} object */\n\nexport const isTypedArray = object => {\n  // The object must pass a brand check or toStringTag will return undefined.\n  const tag = apply(getTypedArrayToStringTag, object, []);\n  return tag !== undefined;\n};\n/**\n * @template T\n * @param {ArrayLike<T>} array\n */\n\nconst freezeTypedArray = array => {\n  const descs = getOwnPropertyDescriptors(array);\n  preventExtensions(array); // Downgrade writable expandos to readonly, even if non-configurable.\n\n  arrayForEach(ownKeys(descs), (\n  /** @type {string | symbol} */\n  name) => {\n    const desc = descs[\n    /** @type {string} */\n    name]; // The numbered properties are writable and non-configurable,\n    // and cannot be made non-writable by defineProperty.\n    // This is a strange behavior intrinsic to TypedArrays, but no more harmful\n    // than the mutability of properties of a hardened Map or Set,\n    // so we carve out this exceptional behavior.\n    //\n    // TypedArrays are integer-indexed exotic objects, so indexed properties\n    // outside the range of 0 to the typed array's length are disallowed.\n    // Assignment to these indexes silently fails and defining an indexed\n    // property throws an error.\n    // So, we only need to make non-index properties non-writable and\n    // non-configurable.\n    // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects\n\n    const number = +String(name);\n\n    if (!isInteger(number)) {\n      defineProperty(array, name, { ...desc,\n        writable: false,\n        configurable: false\n      });\n    }\n  });\n};\n/**\n * Create a `harden` function.\n *\n * @returns {Harden}\n */\n\n\nexport const makeHardener = () => {\n  const hardened = new WeakSet();\n  const {\n    harden\n  } = {\n    /**\n     * @template T\n     * @param {T} root\n     * @returns {T}\n     */\n    harden(root) {\n      const toFreeze = new Set();\n      const paths = new WeakMap(); // If val is something we should be freezing but aren't yet,\n      // add it to toFreeze.\n\n      /**\n       * @param {any} val\n       * @param {string} [path]\n       */\n\n      function enqueue(val) {\n        let path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\n        if (!isObject(val)) {\n          // ignore primitives\n          return;\n        }\n\n        const type = typeof val;\n\n        if (type !== 'object' && type !== 'function') {\n          // future proof: break until someone figures out what it should do\n          throw new TypeError(`Unexpected typeof: ${type}`);\n        }\n\n        if (weaksetHas(hardened, val) || setHas(toFreeze, val)) {\n          // Ignore if this is an exit, or we've already visited it\n          return;\n        } // console.warn(`adding ${val} to toFreeze`, val);\n\n\n        setAdd(toFreeze, val);\n        weakmapSet(paths, val, path);\n      }\n      /**\n       * @param {any} obj\n       */\n\n\n      function freezeAndTraverse(obj) {\n        // Now freeze the object to ensure reactive\n        // objects such as proxies won't add properties\n        // during traversal, before they get frozen.\n        // Object are verified before being enqueued,\n        // therefore this is a valid candidate.\n        // Throws if this fails (strict mode).\n        // Also throws if the object is an ArrayBuffer or any TypedArray.\n        if (isTypedArray(obj)) {\n          freezeTypedArray(obj);\n        } else {\n          freeze(obj);\n        } // we rely upon certain commitments of Object.freeze and proxies here\n        // get stable/immutable outbound links before a Proxy has a chance to do\n        // something sneaky.\n\n\n        const path = weakmapGet(paths, obj) || 'unknown';\n        const descs = getOwnPropertyDescriptors(obj);\n        const proto = getPrototypeOf(obj);\n        enqueue(proto, `${path}.__proto__`);\n        arrayForEach(ownKeys(descs), (\n        /** @type {string | symbol} */\n        name) => {\n          const pathname = `${path}.${String(name)}`; // The 'name' may be a symbol, and TypeScript doesn't like us to\n          // index arbitrary symbols on objects, so we pretend they're just\n          // strings.\n\n          const desc = descs[\n          /** @type {string} */\n          name]; // getOwnPropertyDescriptors is guaranteed to return well-formed\n          // descriptors, but they still inherit from Object.prototype. If\n          // someone has poisoned Object.prototype to add 'value' or 'get'\n          // properties, then a simple 'if (\"value\" in desc)' or 'desc.value'\n          // test could be confused. We use hasOwnProperty to be sure about\n          // whether 'value' is present or not, which tells us for sure that\n          // this is a data property.\n\n          if (objectHasOwnProperty(desc, 'value')) {\n            enqueue(desc.value, `${pathname}`);\n          } else {\n            enqueue(desc.get, `${pathname}(get)`);\n            enqueue(desc.set, `${pathname}(set)`);\n          }\n        });\n      }\n\n      function dequeue() {\n        // New values added before forEach() has finished will be visited.\n        setForEach(toFreeze, freezeAndTraverse);\n      }\n      /** @param {any} value */\n\n\n      function markHardened(value) {\n        weaksetAdd(hardened, value);\n      }\n\n      function commit() {\n        setForEach(toFreeze, markHardened);\n      }\n\n      enqueue(root);\n      dequeue(); // console.warn(\"toFreeze set:\", toFreeze);\n\n      commit();\n      return root;\n    }\n\n  };\n  return harden;\n};","map":{"version":3,"names":["Set","String","TypeError","WeakMap","WeakSet","apply","arrayForEach","defineProperty","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","getPrototypeOf","isInteger","isObject","objectHasOwnProperty","ownKeys","preventExtensions","setAdd","setForEach","setHas","toStringTagSymbol","typedArrayPrototype","weakmapGet","weakmapSet","weaksetAdd","weaksetHas","assert","typedArrayToStringTag","getTypedArrayToStringTag","get","isTypedArray","object","tag","undefined","freezeTypedArray","array","descs","name","desc","number","writable","configurable","makeHardener","hardened","harden","root","toFreeze","paths","enqueue","val","path","type","freezeAndTraverse","obj","proto","pathname","value","set","dequeue","markHardened","commit"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/make-hardener.js"],"sourcesContent":["// Adapted from SES/Caja - Copyright (C) 2011 Google Inc.\n// Copyright (C) 2018 Agoric\n\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// based upon:\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/startSES.js\n// https://github.com/google/caja/blob/master/src/com/google/caja/ses/repairES5.js\n// then copied from proposal-frozen-realms deep-freeze.js\n// then copied from SES/src/bundle/deepFreeze.js\n\n// @ts-check\n\nimport {\n  Set,\n  String,\n  TypeError,\n  WeakMap,\n  WeakSet,\n  apply,\n  arrayForEach,\n  defineProperty,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  getPrototypeOf,\n  isInteger,\n  isObject,\n  objectHasOwnProperty,\n  ownKeys,\n  preventExtensions,\n  setAdd,\n  setForEach,\n  setHas,\n  toStringTagSymbol,\n  typedArrayPrototype,\n  weakmapGet,\n  weakmapSet,\n  weaksetAdd,\n  weaksetHas,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\n/**\n * @typedef {import('../index.js').Harden} Harden\n */\n\n// Obtain the string tag accessor of of TypedArray so we can indirectly use the\n// TypedArray brand check it employs.\nconst typedArrayToStringTag = getOwnPropertyDescriptor(\n  typedArrayPrototype,\n  toStringTagSymbol,\n);\nassert(typedArrayToStringTag);\nconst getTypedArrayToStringTag = typedArrayToStringTag.get;\nassert(getTypedArrayToStringTag);\n\n// Exported for tests.\n/** @param {unknown} object */\nexport const isTypedArray = object => {\n  // The object must pass a brand check or toStringTag will return undefined.\n  const tag = apply(getTypedArrayToStringTag, object, []);\n  return tag !== undefined;\n};\n\n/**\n * @template T\n * @param {ArrayLike<T>} array\n */\nconst freezeTypedArray = array => {\n  const descs = getOwnPropertyDescriptors(array);\n\n  preventExtensions(array);\n\n  // Downgrade writable expandos to readonly, even if non-configurable.\n  arrayForEach(ownKeys(descs), (/** @type {string | symbol} */ name) => {\n    const desc = descs[/** @type {string} */ (name)];\n    // The numbered properties are writable and non-configurable,\n    // and cannot be made non-writable by defineProperty.\n    // This is a strange behavior intrinsic to TypedArrays, but no more harmful\n    // than the mutability of properties of a hardened Map or Set,\n    // so we carve out this exceptional behavior.\n    //\n    // TypedArrays are integer-indexed exotic objects, so indexed properties\n    // outside the range of 0 to the typed array's length are disallowed.\n    // Assignment to these indexes silently fails and defining an indexed\n    // property throws an error.\n    // So, we only need to make non-index properties non-writable and\n    // non-configurable.\n    // https://tc39.es/ecma262/#sec-integer-indexed-exotic-objects\n    const number = +String(name);\n    if (!isInteger(number)) {\n      defineProperty(array, name, {\n        ...desc,\n        writable: false,\n        configurable: false,\n      });\n    }\n  });\n};\n\n/**\n * Create a `harden` function.\n *\n * @returns {Harden}\n */\nexport const makeHardener = () => {\n  const hardened = new WeakSet();\n\n  const { harden } = {\n    /**\n     * @template T\n     * @param {T} root\n     * @returns {T}\n     */\n    harden(root) {\n      const toFreeze = new Set();\n      const paths = new WeakMap();\n\n      // If val is something we should be freezing but aren't yet,\n      // add it to toFreeze.\n      /**\n       * @param {any} val\n       * @param {string} [path]\n       */\n      function enqueue(val, path = undefined) {\n        if (!isObject(val)) {\n          // ignore primitives\n          return;\n        }\n        const type = typeof val;\n        if (type !== 'object' && type !== 'function') {\n          // future proof: break until someone figures out what it should do\n          throw new TypeError(`Unexpected typeof: ${type}`);\n        }\n        if (weaksetHas(hardened, val) || setHas(toFreeze, val)) {\n          // Ignore if this is an exit, or we've already visited it\n          return;\n        }\n        // console.warn(`adding ${val} to toFreeze`, val);\n        setAdd(toFreeze, val);\n        weakmapSet(paths, val, path);\n      }\n\n      /**\n       * @param {any} obj\n       */\n      function freezeAndTraverse(obj) {\n        // Now freeze the object to ensure reactive\n        // objects such as proxies won't add properties\n        // during traversal, before they get frozen.\n\n        // Object are verified before being enqueued,\n        // therefore this is a valid candidate.\n        // Throws if this fails (strict mode).\n        // Also throws if the object is an ArrayBuffer or any TypedArray.\n        if (isTypedArray(obj)) {\n          freezeTypedArray(obj);\n        } else {\n          freeze(obj);\n        }\n\n        // we rely upon certain commitments of Object.freeze and proxies here\n\n        // get stable/immutable outbound links before a Proxy has a chance to do\n        // something sneaky.\n        const path = weakmapGet(paths, obj) || 'unknown';\n        const descs = getOwnPropertyDescriptors(obj);\n        const proto = getPrototypeOf(obj);\n        enqueue(proto, `${path}.__proto__`);\n\n        arrayForEach(ownKeys(descs), (/** @type {string | symbol} */ name) => {\n          const pathname = `${path}.${String(name)}`;\n          // The 'name' may be a symbol, and TypeScript doesn't like us to\n          // index arbitrary symbols on objects, so we pretend they're just\n          // strings.\n          const desc = descs[/** @type {string} */ (name)];\n          // getOwnPropertyDescriptors is guaranteed to return well-formed\n          // descriptors, but they still inherit from Object.prototype. If\n          // someone has poisoned Object.prototype to add 'value' or 'get'\n          // properties, then a simple 'if (\"value\" in desc)' or 'desc.value'\n          // test could be confused. We use hasOwnProperty to be sure about\n          // whether 'value' is present or not, which tells us for sure that\n          // this is a data property.\n          if (objectHasOwnProperty(desc, 'value')) {\n            enqueue(desc.value, `${pathname}`);\n          } else {\n            enqueue(desc.get, `${pathname}(get)`);\n            enqueue(desc.set, `${pathname}(set)`);\n          }\n        });\n      }\n\n      function dequeue() {\n        // New values added before forEach() has finished will be visited.\n        setForEach(toFreeze, freezeAndTraverse);\n      }\n\n      /** @param {any} value */\n      function markHardened(value) {\n        weaksetAdd(hardened, value);\n      }\n\n      function commit() {\n        setForEach(toFreeze, markHardened);\n      }\n\n      enqueue(root);\n      dequeue();\n      // console.warn(\"toFreeze set:\", toFreeze);\n      commit();\n\n      return root;\n    },\n  };\n\n  return harden;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}