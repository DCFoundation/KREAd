{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { assert } from '@agoric/assert';\nimport { makePromiseKit } from '@endo/promise-kit';\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makeAsyncIterableFromNotifier } from './asyncIterableAdaptor.js';\nimport './types.js';\n/**\n * @template T\n * @param {ERef<BaseNotifier<T> | NotifierInternals<T>>} sharableInternalsP\n * @returns {AsyncIterable<T> & SharableNotifier<T>}\n */\n\nexport const makeNotifier = sharableInternalsP => {\n  const asyncIterable = makeAsyncIterableFromNotifier(sharableInternalsP);\n  return Far('notifier', { ...asyncIterable,\n\n    /**\n     * Use this to distribute a Notifier efficiently over the network,\n     * by obtaining this from the Notifier to be replicated, and applying\n     * `makeNotifier` to it at the new site to get an equivalent local\n     * Notifier at that site.\n     */\n    getSharableNotifierInternals: () => sharableInternalsP\n  });\n};\n/**\n * Produces a pair of objects, which allow a service to produce a stream of\n * update promises.\n *\n * The initial state argument has to be truly optional even though it can\n * be any first class value including `undefined`. We need to distinguish the\n * presence vs the absence of it, which we cannot do with the optional argument\n * syntax. Rather we use the arity of the `args` array.\n *\n * If no initial state is provided to `makeNotifierKit`, then it starts without\n * an initial state. Its initial state will instead be the state of the first\n * update.\n *\n * @template T\n * @param {[] | [T]} args the first state to be returned\n * @returns {NotifierRecord<T>} the notifier and updater\n */\n\nexport const makeNotifierKit = function () {\n  /** @type {PromiseRecord<UpdateRecord<T>>|undefined} */\n  let optNextPromiseKit;\n  /** @type {UpdateCount} */\n\n  let currentUpdateCount = 1; // avoid falsy numbers\n\n  /** @type {UpdateRecord<T>|undefined} */\n\n  let currentResponse;\n\n  const hasState = () => currentResponse !== undefined;\n\n  const final = () => currentUpdateCount === undefined;\n\n  const baseNotifier = Far('baseNotifier', {\n    // NaN matches nothing\n    getUpdateSince() {\n      let updateCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;\n\n      if (hasState() && (final() || currentResponse && currentResponse.updateCount !== updateCount)) {\n        // If hasState() and either it is final() or it is\n        // not the state of updateCount, return the current state.\n        assert(currentResponse !== undefined);\n        return Promise.resolve(currentResponse);\n      } // otherwise return a promise for the next state.\n\n\n      if (!optNextPromiseKit) {\n        optNextPromiseKit = makePromiseKit();\n      }\n\n      return optNextPromiseKit.promise;\n    }\n\n  });\n  const notifier = Far('notifier', { ...makeNotifier(baseNotifier),\n    ...baseNotifier\n  });\n  const updater = Far('updater', {\n    updateState(state) {\n      if (final()) {\n        throw new Error('Cannot update state after termination.');\n      } // become hasState() && !final()\n\n\n      assert(currentUpdateCount);\n      currentUpdateCount += 1;\n      currentResponse = harden({\n        value: state,\n        updateCount: currentUpdateCount\n      });\n\n      if (optNextPromiseKit) {\n        optNextPromiseKit.resolve(currentResponse);\n        optNextPromiseKit = undefined;\n      }\n    },\n\n    finish(finalState) {\n      if (final()) {\n        throw new Error('Cannot finish after termination.');\n      } // become hasState() && final()\n\n\n      currentUpdateCount = undefined;\n      currentResponse = harden({\n        value: finalState,\n        updateCount: currentUpdateCount\n      });\n\n      if (optNextPromiseKit) {\n        optNextPromiseKit.resolve(currentResponse);\n        optNextPromiseKit = undefined;\n      }\n    },\n\n    fail(reason) {\n      if (final()) {\n        throw new Error('Cannot fail after termination.');\n      } // become !hasState() && final()\n\n\n      currentUpdateCount = undefined;\n      currentResponse = undefined;\n\n      if (!optNextPromiseKit) {\n        optNextPromiseKit = makePromiseKit();\n      } // Don't trigger Node.js's UnhandledPromiseRejectionWarning\n\n\n      optNextPromiseKit.promise.catch(_ => {});\n      optNextPromiseKit.reject(reason);\n    }\n\n  });\n\n  if (arguments.length >= 1) {\n    updater.updateState(arguments.length <= 0 ? undefined : arguments[0]);\n  } // notifier facet is separate so it can be handed out while updater\n  // is tightly held\n\n\n  return harden({\n    notifier,\n    updater\n  });\n};\n/**\n * Adaptor from async iterable to notifier.\n *\n * @template T\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @returns {Notifier<T>}\n */\n\nexport const makeNotifierFromAsyncIterable = asyncIterableP => {\n  const iteratorP = E(asyncIterableP)[Symbol.asyncIterator]();\n  /** @type {Promise<UpdateRecord<T>>|undefined} */\n\n  let optNextPromise;\n  /** @type {UpdateCount} */\n\n  let currentUpdateCount = 1; // avoid falsy numbers\n\n  /** @type {UpdateRecord<T>|undefined} */\n\n  let currentResponse;\n\n  const hasState = () => currentResponse !== undefined;\n\n  const final = () => currentUpdateCount === undefined;\n  /**\n   * @template T\n   * @type {BaseNotifier<T>}\n   */\n\n\n  const baseNotifier = Far('baseNotifier', {\n    // NaN matches nothing\n    getUpdateSince() {\n      let updateCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : NaN;\n\n      if (hasState() && (final() || currentResponse && currentResponse.updateCount !== updateCount)) {\n        // If hasState() and either it is final() or it is\n        // not the state of updateCount, return the current state.\n        assert(currentResponse !== undefined);\n        return Promise.resolve(currentResponse);\n      } // otherwise return a promise for the next state.\n\n\n      if (!optNextPromise) {\n        const nextIterResultP = E(iteratorP).next();\n        optNextPromise = E.when(nextIterResultP, _ref => {\n          let {\n            done,\n            value\n          } = _ref;\n          assert(currentUpdateCount);\n          currentUpdateCount = done ? undefined : currentUpdateCount + 1;\n          currentResponse = harden({\n            value,\n            updateCount: currentUpdateCount\n          });\n          optNextPromise = undefined;\n          return currentResponse;\n        }, _reason => {\n          currentUpdateCount = undefined;\n          currentResponse = undefined; // We know that nextIterResultP is rejected, and we just need any\n          // promise rejected by that reason.\n\n          return (\n            /** @type {Promise<UpdateRecord<T>>} */\n            nextIterResultP\n          );\n        });\n      }\n\n      return optNextPromise;\n    }\n\n  });\n  return Far('notifier', { // Don't leak the original asyncIterableP since it may be remote and we also\n    // want the same semantics for this exposed iterable and the baseNotifier.\n    ...makeAsyncIterableFromNotifier(baseNotifier),\n    ...baseNotifier,\n\n    /**\n     * Use this to distribute a Notifier efficiently over the network,\n     * by obtaining this from the Notifier to be replicated, and applying\n     * `makeNotifier` to it at the new site to get an equivalent local\n     * Notifier at that site.\n     */\n    getSharableNotifierInternals: () => baseNotifier\n  });\n};\nharden(makeNotifierFromAsyncIterable);","map":{"version":3,"names":["assert","makePromiseKit","E","Far","makeAsyncIterableFromNotifier","makeNotifier","sharableInternalsP","asyncIterable","getSharableNotifierInternals","makeNotifierKit","optNextPromiseKit","currentUpdateCount","currentResponse","hasState","undefined","final","baseNotifier","getUpdateSince","updateCount","NaN","Promise","resolve","promise","notifier","updater","updateState","state","Error","harden","value","finish","finalState","fail","reason","catch","_","reject","length","makeNotifierFromAsyncIterable","asyncIterableP","iteratorP","Symbol","asyncIterator","optNextPromise","nextIterResultP","next","when","done","_reason"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@agoric/notifier/src/notifier.js"],"sourcesContent":["// @ts-check\n/// <reference types=\"ses\"/>\n\nimport { assert } from '@agoric/assert';\nimport { makePromiseKit } from '@endo/promise-kit';\nimport { E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makeAsyncIterableFromNotifier } from './asyncIterableAdaptor.js';\n\nimport './types.js';\n\n/**\n * @template T\n * @param {ERef<BaseNotifier<T> | NotifierInternals<T>>} sharableInternalsP\n * @returns {AsyncIterable<T> & SharableNotifier<T>}\n */\nexport const makeNotifier = sharableInternalsP => {\n  const asyncIterable = makeAsyncIterableFromNotifier(sharableInternalsP);\n\n  return Far('notifier', {\n    ...asyncIterable,\n\n    /**\n     * Use this to distribute a Notifier efficiently over the network,\n     * by obtaining this from the Notifier to be replicated, and applying\n     * `makeNotifier` to it at the new site to get an equivalent local\n     * Notifier at that site.\n     */\n    getSharableNotifierInternals: () => sharableInternalsP,\n  });\n};\n\n/**\n * Produces a pair of objects, which allow a service to produce a stream of\n * update promises.\n *\n * The initial state argument has to be truly optional even though it can\n * be any first class value including `undefined`. We need to distinguish the\n * presence vs the absence of it, which we cannot do with the optional argument\n * syntax. Rather we use the arity of the `args` array.\n *\n * If no initial state is provided to `makeNotifierKit`, then it starts without\n * an initial state. Its initial state will instead be the state of the first\n * update.\n *\n * @template T\n * @param {[] | [T]} args the first state to be returned\n * @returns {NotifierRecord<T>} the notifier and updater\n */\nexport const makeNotifierKit = (...args) => {\n  /** @type {PromiseRecord<UpdateRecord<T>>|undefined} */\n  let optNextPromiseKit;\n  /** @type {UpdateCount} */\n  let currentUpdateCount = 1; // avoid falsy numbers\n  /** @type {UpdateRecord<T>|undefined} */\n  let currentResponse;\n\n  const hasState = () => currentResponse !== undefined;\n\n  const final = () => currentUpdateCount === undefined;\n\n  const baseNotifier = Far('baseNotifier', {\n    // NaN matches nothing\n    getUpdateSince(updateCount = NaN) {\n      if (\n        hasState() &&\n        (final() ||\n          (currentResponse && currentResponse.updateCount !== updateCount))\n      ) {\n        // If hasState() and either it is final() or it is\n        // not the state of updateCount, return the current state.\n        assert(currentResponse !== undefined);\n        return Promise.resolve(currentResponse);\n      }\n      // otherwise return a promise for the next state.\n      if (!optNextPromiseKit) {\n        optNextPromiseKit = makePromiseKit();\n      }\n      return optNextPromiseKit.promise;\n    },\n  });\n\n  const notifier = Far('notifier', {\n    ...makeNotifier(baseNotifier),\n    ...baseNotifier,\n  });\n\n  const updater = Far('updater', {\n    updateState(state) {\n      if (final()) {\n        throw new Error('Cannot update state after termination.');\n      }\n\n      // become hasState() && !final()\n      assert(currentUpdateCount);\n      currentUpdateCount += 1;\n      currentResponse = harden({\n        value: state,\n        updateCount: currentUpdateCount,\n      });\n      if (optNextPromiseKit) {\n        optNextPromiseKit.resolve(currentResponse);\n        optNextPromiseKit = undefined;\n      }\n    },\n\n    finish(finalState) {\n      if (final()) {\n        throw new Error('Cannot finish after termination.');\n      }\n\n      // become hasState() && final()\n      currentUpdateCount = undefined;\n      currentResponse = harden({\n        value: finalState,\n        updateCount: currentUpdateCount,\n      });\n      if (optNextPromiseKit) {\n        optNextPromiseKit.resolve(currentResponse);\n        optNextPromiseKit = undefined;\n      }\n    },\n\n    fail(reason) {\n      if (final()) {\n        throw new Error('Cannot fail after termination.');\n      }\n\n      // become !hasState() && final()\n      currentUpdateCount = undefined;\n      currentResponse = undefined;\n      if (!optNextPromiseKit) {\n        optNextPromiseKit = makePromiseKit();\n      }\n      // Don't trigger Node.js's UnhandledPromiseRejectionWarning\n      optNextPromiseKit.promise.catch(_ => {});\n      optNextPromiseKit.reject(reason);\n    },\n  });\n\n  if (args.length >= 1) {\n    updater.updateState(args[0]);\n  }\n\n  // notifier facet is separate so it can be handed out while updater\n  // is tightly held\n  return harden({ notifier, updater });\n};\n\n/**\n * Adaptor from async iterable to notifier.\n *\n * @template T\n * @param {ERef<AsyncIterable<T>>} asyncIterableP\n * @returns {Notifier<T>}\n */\nexport const makeNotifierFromAsyncIterable = asyncIterableP => {\n  const iteratorP = E(asyncIterableP)[Symbol.asyncIterator]();\n\n  /** @type {Promise<UpdateRecord<T>>|undefined} */\n  let optNextPromise;\n  /** @type {UpdateCount} */\n  let currentUpdateCount = 1; // avoid falsy numbers\n  /** @type {UpdateRecord<T>|undefined} */\n  let currentResponse;\n\n  const hasState = () => currentResponse !== undefined;\n\n  const final = () => currentUpdateCount === undefined;\n\n  /**\n   * @template T\n   * @type {BaseNotifier<T>}\n   */\n  const baseNotifier = Far('baseNotifier', {\n    // NaN matches nothing\n    getUpdateSince(updateCount = NaN) {\n      if (\n        hasState() &&\n        (final() ||\n          (currentResponse && currentResponse.updateCount !== updateCount))\n      ) {\n        // If hasState() and either it is final() or it is\n        // not the state of updateCount, return the current state.\n        assert(currentResponse !== undefined);\n        return Promise.resolve(currentResponse);\n      }\n\n      // otherwise return a promise for the next state.\n      if (!optNextPromise) {\n        const nextIterResultP = E(iteratorP).next();\n        optNextPromise = E.when(\n          nextIterResultP,\n          ({ done, value }) => {\n            assert(currentUpdateCount);\n            currentUpdateCount = done ? undefined : currentUpdateCount + 1;\n            currentResponse = harden({\n              value,\n              updateCount: currentUpdateCount,\n            });\n            optNextPromise = undefined;\n            return currentResponse;\n          },\n          _reason => {\n            currentUpdateCount = undefined;\n            currentResponse = undefined;\n            // We know that nextIterResultP is rejected, and we just need any\n            // promise rejected by that reason.\n            return /** @type {Promise<UpdateRecord<T>>} */ (nextIterResultP);\n          },\n        );\n      }\n      return optNextPromise;\n    },\n  });\n\n  return Far('notifier', {\n    // Don't leak the original asyncIterableP since it may be remote and we also\n    // want the same semantics for this exposed iterable and the baseNotifier.\n    ...makeAsyncIterableFromNotifier(baseNotifier),\n    ...baseNotifier,\n\n    /**\n     * Use this to distribute a Notifier efficiently over the network,\n     * by obtaining this from the Notifier to be replicated, and applying\n     * `makeNotifier` to it at the new site to get an equivalent local\n     * Notifier at that site.\n     */\n    getSharableNotifierInternals: () => baseNotifier,\n  });\n};\nharden(makeNotifierFromAsyncIterable);\n"],"mappings":"AAAA;AACA;AAEA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,cAAT,QAA+B,mBAA/B;AACA,SAASC,CAAT,QAAkB,qBAAlB;AACA,SAASC,GAAT,QAAoB,eAApB;AACA,SAASC,6BAAT,QAA8C,2BAA9C;AAEA,OAAO,YAAP;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,YAAY,GAAGC,kBAAkB,IAAI;EAChD,MAAMC,aAAa,GAAGH,6BAA6B,CAACE,kBAAD,CAAnD;EAEA,OAAOH,GAAG,CAAC,UAAD,EAAa,EACrB,GAAGI,aADkB;;IAGrB;AACJ;AACA;AACA;AACA;AACA;IACIC,4BAA4B,EAAE,MAAMF;EATf,CAAb,CAAV;AAWD,CAdM;AAgBP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMG,eAAe,GAAG,YAAa;EAC1C;EACA,IAAIC,iBAAJ;EACA;;EACA,IAAIC,kBAAkB,GAAG,CAAzB,CAJ0C,CAId;;EAC5B;;EACA,IAAIC,eAAJ;;EAEA,MAAMC,QAAQ,GAAG,MAAMD,eAAe,KAAKE,SAA3C;;EAEA,MAAMC,KAAK,GAAG,MAAMJ,kBAAkB,KAAKG,SAA3C;;EAEA,MAAME,YAAY,GAAGb,GAAG,CAAC,cAAD,EAAiB;IACvC;IACAc,cAAc,GAAoB;MAAA,IAAnBC,WAAmB,uEAALC,GAAK;;MAChC,IACEN,QAAQ,OACPE,KAAK,MACHH,eAAe,IAAIA,eAAe,CAACM,WAAhB,KAAgCA,WAF9C,CADV,EAIE;QACA;QACA;QACAlB,MAAM,CAACY,eAAe,KAAKE,SAArB,CAAN;QACA,OAAOM,OAAO,CAACC,OAAR,CAAgBT,eAAhB,CAAP;MACD,CAV+B,CAWhC;;;MACA,IAAI,CAACF,iBAAL,EAAwB;QACtBA,iBAAiB,GAAGT,cAAc,EAAlC;MACD;;MACD,OAAOS,iBAAiB,CAACY,OAAzB;IACD;;EAlBsC,CAAjB,CAAxB;EAqBA,MAAMC,QAAQ,GAAGpB,GAAG,CAAC,UAAD,EAAa,EAC/B,GAAGE,YAAY,CAACW,YAAD,CADgB;IAE/B,GAAGA;EAF4B,CAAb,CAApB;EAKA,MAAMQ,OAAO,GAAGrB,GAAG,CAAC,SAAD,EAAY;IAC7BsB,WAAW,CAACC,KAAD,EAAQ;MACjB,IAAIX,KAAK,EAAT,EAAa;QACX,MAAM,IAAIY,KAAJ,CAAU,wCAAV,CAAN;MACD,CAHgB,CAKjB;;;MACA3B,MAAM,CAACW,kBAAD,CAAN;MACAA,kBAAkB,IAAI,CAAtB;MACAC,eAAe,GAAGgB,MAAM,CAAC;QACvBC,KAAK,EAAEH,KADgB;QAEvBR,WAAW,EAAEP;MAFU,CAAD,CAAxB;;MAIA,IAAID,iBAAJ,EAAuB;QACrBA,iBAAiB,CAACW,OAAlB,CAA0BT,eAA1B;QACAF,iBAAiB,GAAGI,SAApB;MACD;IACF,CAjB4B;;IAmB7BgB,MAAM,CAACC,UAAD,EAAa;MACjB,IAAIhB,KAAK,EAAT,EAAa;QACX,MAAM,IAAIY,KAAJ,CAAU,kCAAV,CAAN;MACD,CAHgB,CAKjB;;;MACAhB,kBAAkB,GAAGG,SAArB;MACAF,eAAe,GAAGgB,MAAM,CAAC;QACvBC,KAAK,EAAEE,UADgB;QAEvBb,WAAW,EAAEP;MAFU,CAAD,CAAxB;;MAIA,IAAID,iBAAJ,EAAuB;QACrBA,iBAAiB,CAACW,OAAlB,CAA0BT,eAA1B;QACAF,iBAAiB,GAAGI,SAApB;MACD;IACF,CAlC4B;;IAoC7BkB,IAAI,CAACC,MAAD,EAAS;MACX,IAAIlB,KAAK,EAAT,EAAa;QACX,MAAM,IAAIY,KAAJ,CAAU,gCAAV,CAAN;MACD,CAHU,CAKX;;;MACAhB,kBAAkB,GAAGG,SAArB;MACAF,eAAe,GAAGE,SAAlB;;MACA,IAAI,CAACJ,iBAAL,EAAwB;QACtBA,iBAAiB,GAAGT,cAAc,EAAlC;MACD,CAVU,CAWX;;;MACAS,iBAAiB,CAACY,OAAlB,CAA0BY,KAA1B,CAAgCC,CAAC,IAAI,CAAE,CAAvC;MACAzB,iBAAiB,CAAC0B,MAAlB,CAAyBH,MAAzB;IACD;;EAlD4B,CAAZ,CAAnB;;EAqDA,IAAI,UAAKI,MAAL,IAAe,CAAnB,EAAsB;IACpBb,OAAO,CAACC,WAAR;EACD,CA7FyC,CA+F1C;EACA;;;EACA,OAAOG,MAAM,CAAC;IAAEL,QAAF;IAAYC;EAAZ,CAAD,CAAb;AACD,CAlGM;AAoGP;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMc,6BAA6B,GAAGC,cAAc,IAAI;EAC7D,MAAMC,SAAS,GAAGtC,CAAC,CAACqC,cAAD,CAAD,CAAkBE,MAAM,CAACC,aAAzB,GAAlB;EAEA;;EACA,IAAIC,cAAJ;EACA;;EACA,IAAIhC,kBAAkB,GAAG,CAAzB,CAN6D,CAMjC;;EAC5B;;EACA,IAAIC,eAAJ;;EAEA,MAAMC,QAAQ,GAAG,MAAMD,eAAe,KAAKE,SAA3C;;EAEA,MAAMC,KAAK,GAAG,MAAMJ,kBAAkB,KAAKG,SAA3C;EAEA;AACF;AACA;AACA;;;EACE,MAAME,YAAY,GAAGb,GAAG,CAAC,cAAD,EAAiB;IACvC;IACAc,cAAc,GAAoB;MAAA,IAAnBC,WAAmB,uEAALC,GAAK;;MAChC,IACEN,QAAQ,OACPE,KAAK,MACHH,eAAe,IAAIA,eAAe,CAACM,WAAhB,KAAgCA,WAF9C,CADV,EAIE;QACA;QACA;QACAlB,MAAM,CAACY,eAAe,KAAKE,SAArB,CAAN;QACA,OAAOM,OAAO,CAACC,OAAR,CAAgBT,eAAhB,CAAP;MACD,CAV+B,CAYhC;;;MACA,IAAI,CAAC+B,cAAL,EAAqB;QACnB,MAAMC,eAAe,GAAG1C,CAAC,CAACsC,SAAD,CAAD,CAAaK,IAAb,EAAxB;QACAF,cAAc,GAAGzC,CAAC,CAAC4C,IAAF,CACfF,eADe,EAEf,QAAqB;UAAA,IAApB;YAAEG,IAAF;YAAQlB;UAAR,CAAoB;UACnB7B,MAAM,CAACW,kBAAD,CAAN;UACAA,kBAAkB,GAAGoC,IAAI,GAAGjC,SAAH,GAAeH,kBAAkB,GAAG,CAA7D;UACAC,eAAe,GAAGgB,MAAM,CAAC;YACvBC,KADuB;YAEvBX,WAAW,EAAEP;UAFU,CAAD,CAAxB;UAIAgC,cAAc,GAAG7B,SAAjB;UACA,OAAOF,eAAP;QACD,CAXc,EAYfoC,OAAO,IAAI;UACTrC,kBAAkB,GAAGG,SAArB;UACAF,eAAe,GAAGE,SAAlB,CAFS,CAGT;UACA;;UACA;YAAO;YAAyC8B;UAAhD;QACD,CAlBc,CAAjB;MAoBD;;MACD,OAAOD,cAAP;IACD;;EAvCsC,CAAjB,CAAxB;EA0CA,OAAOxC,GAAG,CAAC,UAAD,EAAa,EACrB;IACA;IACA,GAAGC,6BAA6B,CAACY,YAAD,CAHX;IAIrB,GAAGA,YAJkB;;IAMrB;AACJ;AACA;AACA;AACA;AACA;IACIR,4BAA4B,EAAE,MAAMQ;EAZf,CAAb,CAAV;AAcD,CA1EM;AA2EPY,MAAM,CAACU,6BAAD,CAAN"},"metadata":{},"sourceType":"module"}