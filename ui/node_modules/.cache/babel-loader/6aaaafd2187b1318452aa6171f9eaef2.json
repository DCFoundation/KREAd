{"ast":null,"code":"import { FERAL_FUNCTION, arrayJoin, arrayPop, defineProperties, getPrototypeOf } from './commons.js';\nimport { assert } from './error/assert.js';\n/*\n * makeFunctionConstructor()\n * A safe version of the native Function which relies on\n * the safety of safeEvaluate for confinement.\n */\n\nexport const makeFunctionConstructor = safeEvaluate => {\n  // Define an unused parameter to ensure Function.length === 1\n  const newFunction = function Function(_body) {\n    // Sanitize all parameters at the entry point.\n    // eslint-disable-next-line prefer-rest-params\n    const bodyText = `${arrayPop(arguments) || ''}`; // eslint-disable-next-line prefer-rest-params\n\n    const parameters = `${arrayJoin(arguments, ',')}`; // Are parameters and bodyText valid code, or is someone\n    // attempting an injection attack? This will throw a SyntaxError if:\n    // - parameters doesn't parse as parameters\n    // - bodyText doesn't parse as a function body\n    // - either contain a call to super() or references a super property.\n    //\n    // It seems that XS may still be vulnerable to the attack explained at\n    // https://github.com/tc39/ecma262/pull/2374#issuecomment-813769710\n    // where `new Function('/*', '*/ ) {')` would incorrectly validate.\n    // Before we worried about this, we check the parameters and bodyText\n    // together in one call\n    // ```js\n    // new FERAL_FUNCTION(parameters, bodyTest);\n    // ```\n    // However, this check is vulnerable to that bug. Aside from that case,\n    // all engines do seem to validate the parameters, taken by themselves,\n    // correctly. And all engines do seem to validate the bodyText, taken\n    // by itself correctly. So with the following two checks, SES builds a\n    // correct safe `Function` constructor by composing two calls to an\n    // original unsafe `Function` constructor that may suffer from this bug\n    // but is otherwise correctly validating.\n    //\n    // eslint-disable-next-line no-new\n\n    new FERAL_FUNCTION(parameters, ''); // eslint-disable-next-line no-new\n\n    new FERAL_FUNCTION(bodyText); // Safe to be combined. Defeat potential trailing comments.\n    // TODO: since we create an anonymous function, the 'this' value\n    // isn't bound to the global object as per specs, but set as undefined.\n\n    const src = `(function anonymous(${parameters}\\n) {\\n${bodyText}\\n})`;\n    return safeEvaluate(src);\n  };\n\n  defineProperties(newFunction, {\n    // Ensure that any function created in any evaluator in a realm is an\n    // instance of Function in any evaluator of the same realm.\n    prototype: {\n      value: FERAL_FUNCTION.prototype,\n      writable: false,\n      enumerable: false,\n      configurable: false\n    }\n  }); // Assert identity of Function.__proto__ accross all compartments\n\n  assert(getPrototypeOf(FERAL_FUNCTION) === FERAL_FUNCTION.prototype, 'Function prototype is the same accross compartments');\n  assert(getPrototypeOf(newFunction) === FERAL_FUNCTION.prototype, 'Function constructor prototype is the same accross compartments');\n  return newFunction;\n};","map":{"version":3,"names":["FERAL_FUNCTION","arrayJoin","arrayPop","defineProperties","getPrototypeOf","assert","makeFunctionConstructor","safeEvaluate","newFunction","Function","_body","bodyText","arguments","parameters","src","prototype","value","writable","enumerable","configurable"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/make-function-constructor.js"],"sourcesContent":["import {\n  FERAL_FUNCTION,\n  arrayJoin,\n  arrayPop,\n  defineProperties,\n  getPrototypeOf,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\n/*\n * makeFunctionConstructor()\n * A safe version of the native Function which relies on\n * the safety of safeEvaluate for confinement.\n */\nexport const makeFunctionConstructor = safeEvaluate => {\n  // Define an unused parameter to ensure Function.length === 1\n  const newFunction = function Function(_body) {\n    // Sanitize all parameters at the entry point.\n    // eslint-disable-next-line prefer-rest-params\n    const bodyText = `${arrayPop(arguments) || ''}`;\n    // eslint-disable-next-line prefer-rest-params\n    const parameters = `${arrayJoin(arguments, ',')}`;\n\n    // Are parameters and bodyText valid code, or is someone\n    // attempting an injection attack? This will throw a SyntaxError if:\n    // - parameters doesn't parse as parameters\n    // - bodyText doesn't parse as a function body\n    // - either contain a call to super() or references a super property.\n    //\n    // It seems that XS may still be vulnerable to the attack explained at\n    // https://github.com/tc39/ecma262/pull/2374#issuecomment-813769710\n    // where `new Function('/*', '*/ ) {')` would incorrectly validate.\n    // Before we worried about this, we check the parameters and bodyText\n    // together in one call\n    // ```js\n    // new FERAL_FUNCTION(parameters, bodyTest);\n    // ```\n    // However, this check is vulnerable to that bug. Aside from that case,\n    // all engines do seem to validate the parameters, taken by themselves,\n    // correctly. And all engines do seem to validate the bodyText, taken\n    // by itself correctly. So with the following two checks, SES builds a\n    // correct safe `Function` constructor by composing two calls to an\n    // original unsafe `Function` constructor that may suffer from this bug\n    // but is otherwise correctly validating.\n    //\n    // eslint-disable-next-line no-new\n    new FERAL_FUNCTION(parameters, '');\n    // eslint-disable-next-line no-new\n    new FERAL_FUNCTION(bodyText);\n\n    // Safe to be combined. Defeat potential trailing comments.\n    // TODO: since we create an anonymous function, the 'this' value\n    // isn't bound to the global object as per specs, but set as undefined.\n    const src = `(function anonymous(${parameters}\\n) {\\n${bodyText}\\n})`;\n    return safeEvaluate(src);\n  };\n\n  defineProperties(newFunction, {\n    // Ensure that any function created in any evaluator in a realm is an\n    // instance of Function in any evaluator of the same realm.\n    prototype: {\n      value: FERAL_FUNCTION.prototype,\n      writable: false,\n      enumerable: false,\n      configurable: false,\n    },\n  });\n\n  // Assert identity of Function.__proto__ accross all compartments\n  assert(\n    getPrototypeOf(FERAL_FUNCTION) === FERAL_FUNCTION.prototype,\n    'Function prototype is the same accross compartments',\n  );\n  assert(\n    getPrototypeOf(newFunction) === FERAL_FUNCTION.prototype,\n    'Function constructor prototype is the same accross compartments',\n  );\n\n  return newFunction;\n};\n"],"mappings":"AAAA,SACEA,cADF,EAEEC,SAFF,EAGEC,QAHF,EAIEC,gBAJF,EAKEC,cALF,QAMO,cANP;AAOA,SAASC,MAAT,QAAuB,mBAAvB;AAEA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,uBAAuB,GAAGC,YAAY,IAAI;EACrD;EACA,MAAMC,WAAW,GAAG,SAASC,QAAT,CAAkBC,KAAlB,EAAyB;IAC3C;IACA;IACA,MAAMC,QAAQ,GAAI,GAAET,QAAQ,CAACU,SAAD,CAAR,IAAuB,EAAG,EAA9C,CAH2C,CAI3C;;IACA,MAAMC,UAAU,GAAI,GAAEZ,SAAS,CAACW,SAAD,EAAY,GAAZ,CAAiB,EAAhD,CAL2C,CAO3C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IACA,IAAIZ,cAAJ,CAAmBa,UAAnB,EAA+B,EAA/B,EA9B2C,CA+B3C;;IACA,IAAIb,cAAJ,CAAmBW,QAAnB,EAhC2C,CAkC3C;IACA;IACA;;IACA,MAAMG,GAAG,GAAI,uBAAsBD,UAAW,UAASF,QAAS,MAAhE;IACA,OAAOJ,YAAY,CAACO,GAAD,CAAnB;EACD,CAvCD;;EAyCAX,gBAAgB,CAACK,WAAD,EAAc;IAC5B;IACA;IACAO,SAAS,EAAE;MACTC,KAAK,EAAEhB,cAAc,CAACe,SADb;MAETE,QAAQ,EAAE,KAFD;MAGTC,UAAU,EAAE,KAHH;MAITC,YAAY,EAAE;IAJL;EAHiB,CAAd,CAAhB,CA3CqD,CAsDrD;;EACAd,MAAM,CACJD,cAAc,CAACJ,cAAD,CAAd,KAAmCA,cAAc,CAACe,SAD9C,EAEJ,qDAFI,CAAN;EAIAV,MAAM,CACJD,cAAc,CAACI,WAAD,CAAd,KAAgCR,cAAc,CAACe,SAD3C,EAEJ,iEAFI,CAAN;EAKA,OAAOP,WAAP;AACD,CAjEM"},"metadata":{},"sourceType":"module"}