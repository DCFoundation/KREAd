{"ast":null,"code":"// Copyright (C) 2018 Agoric\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// @ts-check\nimport { FERAL_FUNCTION, FERAL_EVAL, TypeError, arrayFilter, arrayMap, globalThis, is, ownKeys, stringSplit, noEvalEvaluate } from './commons.js';\nimport { enJoin } from './error/stringify-utils.js';\nimport { makeHardener } from './make-hardener.js';\nimport { makeIntrinsicsCollector } from './intrinsics.js';\nimport whitelistIntrinsics from './whitelist-intrinsics.js';\nimport tameFunctionConstructors from './tame-function-constructors.js';\nimport tameDateConstructor from './tame-date-constructor.js';\nimport tameMathObject from './tame-math-object.js';\nimport tameRegExpConstructor from './tame-regexp-constructor.js';\nimport enablePropertyOverrides from './enable-property-overrides.js';\nimport tameLocaleMethods from './tame-locale-methods.js';\nimport { setGlobalObjectConstantProperties, setGlobalObjectMutableProperties, setGlobalObjectEvaluators } from './global-object.js';\nimport { makeSafeEvaluator } from './make-safe-evaluator.js';\nimport { initialGlobalPropertyNames } from './whitelist.js';\nimport { tameFunctionToString } from './tame-function-tostring.js';\nimport { tameDomains } from './tame-domains.js';\nimport { tameConsole } from './error/tame-console.js';\nimport tameErrorConstructor from './error/tame-error-constructor.js';\nimport { assert, makeAssert } from './error/assert.js';\nimport { makeEnvironmentCaptor } from './environment-options.js';\nimport { getAnonymousIntrinsics } from './get-anonymous-intrinsics.js';\nimport { makeCompartmentConstructor } from './compartment-shim.js';\n/** @typedef {import('../index.js').LockdownOptions} LockdownOptions */\n\nconst {\n  details: d,\n  quote: q\n} = assert;\n/** @type {Error=} */\n\nlet priorLockdown; // Build a harden() with an empty fringe.\n// Gate it on lockdown.\n\n/**\n * @template T\n * @param {T} ref\n * @returns {T}\n */\n\nconst harden = makeHardener();\n/**\n * @callback Transform\n * @param {string} source\n * @returns {string}\n */\n\n/**\n * @callback CompartmentConstructor\n * @param {Object} endowments\n * @param {Object} moduleMap\n * @param {Object} [options]\n * @param {Array<Transform>} [options.transforms]\n * @param {Array<Transform>} [options.__shimTransforms__]\n * @param {Object} [options.globalLexicals]\n */\n// TODO https://github.com/endojs/endo/issues/814\n// Lockdown currently allows multiple calls provided that the specified options\n// of every call agree.  With experience, we have observed that lockdown should\n// only ever need to be called once and that simplifying lockdown will improve\n// the quality of audits.\n\nconst assertDirectEvalAvailable = () => {\n  let allowed = false;\n\n  try {\n    allowed = FERAL_FUNCTION('eval', 'SES_changed', `\\\n        eval(\"SES_changed = true\");\n        return SES_changed;\n      `)(FERAL_EVAL, false); // If we get here and SES_changed stayed false, that means the eval was sloppy\n    // and indirect, which generally creates a new global.\n    // We are going to throw an exception for failing to initialize SES, but\n    // good neighbors clean up.\n\n    if (!allowed) {\n      delete globalThis.SES_changed;\n    }\n  } catch (_error) {\n    // We reach here if eval is outright forbidden by a Content Security Policy.\n    // We allow this for SES usage that delegates the responsibility to isolate\n    // guest code to production code generation.\n    allowed = true;\n  }\n\n  if (!allowed) {\n    throw new TypeError(`SES cannot initialize unless 'eval' is the original intrinsic 'eval', suitable for direct-eval (dynamically scoped eval) (SES_DIRECT_EVAL)`);\n  }\n};\n/**\n * @param {LockdownOptions} [options]\n * @returns {() => void} repairIntrinsics\n */\n\n\nexport const repairIntrinsics = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // First time, absent options default to 'safe'.\n  // Subsequent times, absent options default to first options.\n  // Thus, all present options must agree with first options.\n  // Reconstructing `option` here also ensures that it is a well\n  // behaved record, with only own data properties.\n  //\n  // The `overrideTaming` is not a safety issue. Rather it is a tradeoff\n  // between code compatibility, which is better with the `'moderate'`\n  // setting, and tool compatibility, which is better with the `'min'`\n  // setting. See\n  // https://github.com/Agoric/SES-shim/blob/master/packages/ses/README.md#enabling-override-by-assignment)\n  // for an explanation of when to use which.\n  //\n  // The `stackFiltering` is not a safety issue. Rather it is a tradeoff\n  // between relevance and completeness of the stack frames shown on the\n  // console. Setting`stackFiltering` to `'verbose'` applies no filters, providing\n  // the raw stack frames that can be quite versbose. Setting\n  // `stackFrameFiltering` to`'concise'` limits the display to the stack frame\n  // information most likely to be relevant, eliminating distracting frames\n  // such as those from the infrastructure. However, the bug you're trying to\n  // track down might be in the infrastrure, in which case the `'verbose'` setting\n  // is useful. See\n  // [`stackFiltering` options](https://github.com/Agoric/SES-shim/blob/master/packages/ses/lockdown-options.md#stackfiltering-options)\n  // for an explanation.\n  const {\n    getEnvironmentOption: getenv,\n    getCapturedEnvironmentOptionNames\n  } = makeEnvironmentCaptor(globalThis);\n  const {\n    errorTaming = getenv('LOCKDOWN_ERROR_TAMING', 'safe'),\n    errorTrapping = getenv('LOCKDOWN_ERROR_TRAPPING', 'platform'),\n    regExpTaming = getenv('LOCKDOWN_REGEXP_TAMING', 'safe'),\n    localeTaming = getenv('LOCKDOWN_LOCALE_TAMING', 'safe'),\n    consoleTaming = getenv('LOCKDOWN_CONSOLE_TAMING', 'safe'),\n    overrideTaming = getenv('LOCKDOWN_OVERRIDE_TAMING', 'moderate'),\n    stackFiltering = getenv('LOCKDOWN_STACK_FILTERING', 'concise'),\n    domainTaming = getenv('LOCKDOWN_DOMAIN_TAMING', 'safe'),\n    evalTaming = getenv('LOCKDOWN_EVAL_TAMING', 'safeEval'),\n    overrideDebug = arrayFilter(stringSplit(getenv('LOCKDOWN_OVERRIDE_DEBUG', ''), ','),\n    /** @param {string} debugName */\n    debugName => debugName !== ''),\n    __allowUnsafeMonkeyPatching__ = getenv('__LOCKDOWN_ALLOW_UNSAFE_MONKEY_PATCHING__', 'safe'),\n    dateTaming = 'safe',\n    // deprecated\n    mathTaming = 'safe',\n    // deprecated\n    ...extraOptions\n  } = options;\n  const capturedEnvironmentOptionNames = getCapturedEnvironmentOptionNames();\n\n  if (capturedEnvironmentOptionNames.length > 0) {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    console.warn(`SES Lockdown using options from environment variables ${enJoin(arrayMap(capturedEnvironmentOptionNames, q), 'and')}`);\n  }\n\n  assert(evalTaming === 'unsafeEval' || evalTaming === 'safeEval' || evalTaming === 'noEval', d`lockdown(): non supported option evalTaming: ${q(evalTaming)}`); // Assert that only supported options were passed.\n  // Use Reflect.ownKeys to reject symbol-named properties as well.\n\n  const extraOptionsNames = ownKeys(extraOptions);\n  assert(extraOptionsNames.length === 0, d`lockdown(): non supported option ${q(extraOptionsNames)}`);\n  assert(priorLockdown === undefined, `Already locked down at ${priorLockdown} (SES_ALREADY_LOCKED_DOWN)`, TypeError);\n  priorLockdown = new TypeError('Prior lockdown (SES_ALREADY_LOCKED_DOWN)'); // Tease V8 to generate the stack string and release the closures the stack\n  // trace retained:\n\n  priorLockdown.stack;\n  assertDirectEvalAvailable();\n  /**\n   * Because of packagers and bundlers, etc, multiple invocations of lockdown\n   * might happen in separate instantiations of the source of this module.\n   * In that case, each one sees its own `firstOptions` variable, so the test\n   * above will not detect that lockdown has already happened. We\n   * unreliably test some telltale signs that lockdown has run, to avoid\n   * trying to lock down a locked down environment. Although the test is\n   * unreliable, this is consistent with the SES threat model. SES provides\n   * security only if it runs first in a given realm, or if everything that\n   * runs before it is SES-aware and cooperative. Neither SES nor anything\n   * can protect itself from corrupting code that runs first. For these\n   * purposes, code that turns a realm into something that passes these\n   * tests without actually locking down counts as corrupting code.\n   *\n   * The specifics of what this tests for may change over time, but it\n   * should be consistent with any setting of the lockdown options.\n   */\n\n  const seemsToBeLockedDown = () => {\n    return globalThis.Function.prototype.constructor !== globalThis.Function && // @ts-ignore harden is absent on globalThis type def.\n    typeof globalThis.harden === 'function' && // @ts-ignore lockdown is absent on globalThis type def.\n    typeof globalThis.lockdown === 'function' && globalThis.Date.prototype.constructor !== globalThis.Date && typeof globalThis.Date.now === 'function' && // @ts-ignore does not recognize that Date constructor is a special\n    // Function.\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    is(globalThis.Date.prototype.constructor.now(), NaN);\n  };\n\n  if (seemsToBeLockedDown()) {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    throw new TypeError(`Already locked down but not by this SES instance (SES_MULTIPLE_INSTANCES)`);\n  }\n  /**\n   * 1. TAME powers & gather intrinsics first.\n   */\n\n\n  tameDomains(domainTaming);\n  const {\n    addIntrinsics,\n    completePrototypes,\n    finalIntrinsics\n  } = makeIntrinsicsCollector();\n  addIntrinsics({\n    harden\n  });\n  addIntrinsics(tameFunctionConstructors());\n  addIntrinsics(tameDateConstructor(dateTaming));\n  addIntrinsics(tameErrorConstructor(errorTaming, stackFiltering));\n  addIntrinsics(tameMathObject(mathTaming));\n  addIntrinsics(tameRegExpConstructor(regExpTaming));\n  addIntrinsics(getAnonymousIntrinsics());\n  completePrototypes();\n  const intrinsics = finalIntrinsics(); // Wrap console unless suppressed.\n  // At the moment, the console is considered a host power in the start\n  // compartment, and not a primordial. Hence it is absent from the whilelist\n  // and bypasses the intrinsicsCollector.\n\n  let optGetStackString;\n\n  if (errorTaming !== 'unsafe') {\n    optGetStackString = intrinsics['%InitialGetStackString%'];\n  }\n\n  const consoleRecord = tameConsole( // @ts-ignore tameConsole does its own input validation\n  consoleTaming, errorTrapping, optGetStackString);\n  globalThis.console =\n  /** @type {Console} */\n  consoleRecord.console; // @ts-ignore assert is absent on globalThis type def.\n\n  if (errorTaming === 'unsafe' && globalThis.assert === assert) {\n    // If errorTaming is 'unsafe' we replace the global assert with\n    // one whose `details` template literal tag does not redact\n    // unmarked substitution values. IOW, it blabs information that\n    // was supposed to be secret from callers, as an aid to debugging\n    // at a further cost in safety.\n    // @ts-ignore assert is absent on globalThis type def.\n    globalThis.assert = makeAssert(undefined, true);\n  } // Replace *Locale* methods with their non-locale equivalents\n\n\n  tameLocaleMethods(intrinsics, localeTaming); // Replace Function.prototype.toString with one that recognizes\n  // shimmed functions as honorary native functions.\n\n  const markVirtualizedNativeFunction = tameFunctionToString();\n  /**\n   * 2. WHITELIST to standardize the environment.\n   */\n  // Remove non-standard properties.\n  // All remaining function encountered during whitelisting are\n  // branded as honorary native functions.\n\n  whitelistIntrinsics(intrinsics, markVirtualizedNativeFunction); // Initialize the powerful initial global, i.e., the global of the\n  // start compartment, from the intrinsics.\n\n  setGlobalObjectConstantProperties(globalThis);\n  setGlobalObjectMutableProperties(globalThis, {\n    intrinsics,\n    newGlobalPropertyNames: initialGlobalPropertyNames,\n    makeCompartmentConstructor,\n    markVirtualizedNativeFunction\n  });\n\n  if (evalTaming === 'noEval') {\n    setGlobalObjectEvaluators(globalThis, noEvalEvaluate, markVirtualizedNativeFunction);\n  } else if (evalTaming === 'safeEval') {\n    const {\n      safeEvaluate\n    } = makeSafeEvaluator({\n      globalObject: globalThis\n    });\n    setGlobalObjectEvaluators(globalThis, safeEvaluate, markVirtualizedNativeFunction);\n  } else if (evalTaming === 'unsafeEval') {// Leave eval function and Function constructor of the initial compartment in-tact.\n    // Other compartments will not have access to these evaluators unless a guest program\n    // escapes containment.\n  }\n  /**\n   * 3. HARDEN to share the intrinsics.\n   *\n   * We define hardenIntrinsics here so that options are in scope, but return\n   * it to the caller because we intend to eventually allow vetted shims to run\n   * between repairs and the hardening of intrinsics and so we can benchmark\n   * repair separately from hardening.\n   */\n\n\n  function hardenIntrinsics() {\n    // Circumvent the override mistake.\n    // TODO consider moving this to the end of the repair phase, and\n    // therefore before vetted shims rather than afterwards. It is not\n    // clear yet which is better.\n    // @ts-ignore enablePropertyOverrides does its own input validation\n    enablePropertyOverrides(intrinsics, overrideTaming, overrideDebug);\n\n    if (__allowUnsafeMonkeyPatching__ !== 'unsafe') {\n      // Finally register and optionally freeze all the intrinsics. This\n      // must be the operation that modifies the intrinsics.\n      harden(intrinsics);\n    } // Reveal harden after lockdown.\n    // Harden is dangerous before lockdown because hardening just\n    // about anything will inadvertently render intrinsics irreparable.\n    // Also, for modules that must work both before or after lockdown (code\n    // that is portable between JS and SES), the existence of harden in global\n    // scope signals whether such code should attempt to use harden in the\n    // defense of its own API.\n    // @ts-ignore harden not yet recognized on globalThis.\n\n\n    globalThis.harden = harden; // Returning `true` indicates that this is a JS to SES transition.\n\n    return true;\n  }\n\n  return hardenIntrinsics;\n};\n/**\n * @param {LockdownOptions} [options]\n */\n\nexport const lockdown = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hardenIntrinsics = repairIntrinsics(options);\n  hardenIntrinsics();\n};","map":{"version":3,"names":["FERAL_FUNCTION","FERAL_EVAL","TypeError","arrayFilter","arrayMap","globalThis","is","ownKeys","stringSplit","noEvalEvaluate","enJoin","makeHardener","makeIntrinsicsCollector","whitelistIntrinsics","tameFunctionConstructors","tameDateConstructor","tameMathObject","tameRegExpConstructor","enablePropertyOverrides","tameLocaleMethods","setGlobalObjectConstantProperties","setGlobalObjectMutableProperties","setGlobalObjectEvaluators","makeSafeEvaluator","initialGlobalPropertyNames","tameFunctionToString","tameDomains","tameConsole","tameErrorConstructor","assert","makeAssert","makeEnvironmentCaptor","getAnonymousIntrinsics","makeCompartmentConstructor","details","d","quote","q","priorLockdown","harden","assertDirectEvalAvailable","allowed","SES_changed","_error","repairIntrinsics","options","getEnvironmentOption","getenv","getCapturedEnvironmentOptionNames","errorTaming","errorTrapping","regExpTaming","localeTaming","consoleTaming","overrideTaming","stackFiltering","domainTaming","evalTaming","overrideDebug","debugName","__allowUnsafeMonkeyPatching__","dateTaming","mathTaming","extraOptions","capturedEnvironmentOptionNames","length","console","warn","extraOptionsNames","undefined","stack","seemsToBeLockedDown","Function","prototype","constructor","lockdown","Date","now","NaN","addIntrinsics","completePrototypes","finalIntrinsics","intrinsics","optGetStackString","consoleRecord","markVirtualizedNativeFunction","newGlobalPropertyNames","safeEvaluate","globalObject","hardenIntrinsics"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/lockdown-shim.js"],"sourcesContent":["// Copyright (C) 2018 Agoric\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// @ts-check\n\nimport {\n  FERAL_FUNCTION,\n  FERAL_EVAL,\n  TypeError,\n  arrayFilter,\n  arrayMap,\n  globalThis,\n  is,\n  ownKeys,\n  stringSplit,\n  noEvalEvaluate,\n} from './commons.js';\nimport { enJoin } from './error/stringify-utils.js';\nimport { makeHardener } from './make-hardener.js';\nimport { makeIntrinsicsCollector } from './intrinsics.js';\nimport whitelistIntrinsics from './whitelist-intrinsics.js';\nimport tameFunctionConstructors from './tame-function-constructors.js';\nimport tameDateConstructor from './tame-date-constructor.js';\nimport tameMathObject from './tame-math-object.js';\nimport tameRegExpConstructor from './tame-regexp-constructor.js';\nimport enablePropertyOverrides from './enable-property-overrides.js';\nimport tameLocaleMethods from './tame-locale-methods.js';\nimport {\n  setGlobalObjectConstantProperties,\n  setGlobalObjectMutableProperties,\n  setGlobalObjectEvaluators,\n} from './global-object.js';\nimport { makeSafeEvaluator } from './make-safe-evaluator.js';\nimport { initialGlobalPropertyNames } from './whitelist.js';\nimport { tameFunctionToString } from './tame-function-tostring.js';\nimport { tameDomains } from './tame-domains.js';\n\nimport { tameConsole } from './error/tame-console.js';\nimport tameErrorConstructor from './error/tame-error-constructor.js';\nimport { assert, makeAssert } from './error/assert.js';\nimport { makeEnvironmentCaptor } from './environment-options.js';\nimport { getAnonymousIntrinsics } from './get-anonymous-intrinsics.js';\nimport { makeCompartmentConstructor } from './compartment-shim.js';\n\n/** @typedef {import('../index.js').LockdownOptions} LockdownOptions */\n\nconst { details: d, quote: q } = assert;\n\n/** @type {Error=} */\nlet priorLockdown;\n\n// Build a harden() with an empty fringe.\n// Gate it on lockdown.\n/**\n * @template T\n * @param {T} ref\n * @returns {T}\n */\nconst harden = makeHardener();\n\n/**\n * @callback Transform\n * @param {string} source\n * @returns {string}\n */\n\n/**\n * @callback CompartmentConstructor\n * @param {Object} endowments\n * @param {Object} moduleMap\n * @param {Object} [options]\n * @param {Array<Transform>} [options.transforms]\n * @param {Array<Transform>} [options.__shimTransforms__]\n * @param {Object} [options.globalLexicals]\n */\n\n// TODO https://github.com/endojs/endo/issues/814\n// Lockdown currently allows multiple calls provided that the specified options\n// of every call agree.  With experience, we have observed that lockdown should\n// only ever need to be called once and that simplifying lockdown will improve\n// the quality of audits.\n\nconst assertDirectEvalAvailable = () => {\n  let allowed = false;\n  try {\n    allowed = FERAL_FUNCTION(\n      'eval',\n      'SES_changed',\n      `\\\n        eval(\"SES_changed = true\");\n        return SES_changed;\n      `,\n    )(FERAL_EVAL, false);\n    // If we get here and SES_changed stayed false, that means the eval was sloppy\n    // and indirect, which generally creates a new global.\n    // We are going to throw an exception for failing to initialize SES, but\n    // good neighbors clean up.\n    if (!allowed) {\n      delete globalThis.SES_changed;\n    }\n  } catch (_error) {\n    // We reach here if eval is outright forbidden by a Content Security Policy.\n    // We allow this for SES usage that delegates the responsibility to isolate\n    // guest code to production code generation.\n    allowed = true;\n  }\n  if (!allowed) {\n    throw new TypeError(\n      `SES cannot initialize unless 'eval' is the original intrinsic 'eval', suitable for direct-eval (dynamically scoped eval) (SES_DIRECT_EVAL)`,\n    );\n  }\n};\n\n/**\n * @param {LockdownOptions} [options]\n * @returns {() => void} repairIntrinsics\n */\nexport const repairIntrinsics = (options = {}) => {\n  // First time, absent options default to 'safe'.\n  // Subsequent times, absent options default to first options.\n  // Thus, all present options must agree with first options.\n  // Reconstructing `option` here also ensures that it is a well\n  // behaved record, with only own data properties.\n  //\n  // The `overrideTaming` is not a safety issue. Rather it is a tradeoff\n  // between code compatibility, which is better with the `'moderate'`\n  // setting, and tool compatibility, which is better with the `'min'`\n  // setting. See\n  // https://github.com/Agoric/SES-shim/blob/master/packages/ses/README.md#enabling-override-by-assignment)\n  // for an explanation of when to use which.\n  //\n  // The `stackFiltering` is not a safety issue. Rather it is a tradeoff\n  // between relevance and completeness of the stack frames shown on the\n  // console. Setting`stackFiltering` to `'verbose'` applies no filters, providing\n  // the raw stack frames that can be quite versbose. Setting\n  // `stackFrameFiltering` to`'concise'` limits the display to the stack frame\n  // information most likely to be relevant, eliminating distracting frames\n  // such as those from the infrastructure. However, the bug you're trying to\n  // track down might be in the infrastrure, in which case the `'verbose'` setting\n  // is useful. See\n  // [`stackFiltering` options](https://github.com/Agoric/SES-shim/blob/master/packages/ses/lockdown-options.md#stackfiltering-options)\n  // for an explanation.\n\n  const {\n    getEnvironmentOption: getenv,\n    getCapturedEnvironmentOptionNames,\n  } = makeEnvironmentCaptor(globalThis);\n\n  const {\n    errorTaming = getenv('LOCKDOWN_ERROR_TAMING', 'safe'),\n    errorTrapping = getenv('LOCKDOWN_ERROR_TRAPPING', 'platform'),\n    regExpTaming = getenv('LOCKDOWN_REGEXP_TAMING', 'safe'),\n    localeTaming = getenv('LOCKDOWN_LOCALE_TAMING', 'safe'),\n    consoleTaming = getenv('LOCKDOWN_CONSOLE_TAMING', 'safe'),\n    overrideTaming = getenv('LOCKDOWN_OVERRIDE_TAMING', 'moderate'),\n    stackFiltering = getenv('LOCKDOWN_STACK_FILTERING', 'concise'),\n    domainTaming = getenv('LOCKDOWN_DOMAIN_TAMING', 'safe'),\n    evalTaming = getenv('LOCKDOWN_EVAL_TAMING', 'safeEval'),\n    overrideDebug = arrayFilter(\n      stringSplit(getenv('LOCKDOWN_OVERRIDE_DEBUG', ''), ','),\n      /** @param {string} debugName */\n      debugName => debugName !== '',\n    ),\n    __allowUnsafeMonkeyPatching__ = getenv(\n      '__LOCKDOWN_ALLOW_UNSAFE_MONKEY_PATCHING__',\n      'safe',\n    ),\n    dateTaming = 'safe', // deprecated\n    mathTaming = 'safe', // deprecated\n    ...extraOptions\n  } = options;\n\n  const capturedEnvironmentOptionNames = getCapturedEnvironmentOptionNames();\n  if (capturedEnvironmentOptionNames.length > 0) {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    console.warn(\n      `SES Lockdown using options from environment variables ${enJoin(\n        arrayMap(capturedEnvironmentOptionNames, q),\n        'and',\n      )}`,\n    );\n  }\n\n  assert(\n    evalTaming === 'unsafeEval' ||\n      evalTaming === 'safeEval' ||\n      evalTaming === 'noEval',\n    d`lockdown(): non supported option evalTaming: ${q(evalTaming)}`,\n  );\n\n  // Assert that only supported options were passed.\n  // Use Reflect.ownKeys to reject symbol-named properties as well.\n  const extraOptionsNames = ownKeys(extraOptions);\n  assert(\n    extraOptionsNames.length === 0,\n    d`lockdown(): non supported option ${q(extraOptionsNames)}`,\n  );\n\n  assert(\n    priorLockdown === undefined,\n    `Already locked down at ${priorLockdown} (SES_ALREADY_LOCKED_DOWN)`,\n    TypeError,\n  );\n  priorLockdown = new TypeError('Prior lockdown (SES_ALREADY_LOCKED_DOWN)');\n  // Tease V8 to generate the stack string and release the closures the stack\n  // trace retained:\n  priorLockdown.stack;\n\n  assertDirectEvalAvailable();\n\n  /**\n   * Because of packagers and bundlers, etc, multiple invocations of lockdown\n   * might happen in separate instantiations of the source of this module.\n   * In that case, each one sees its own `firstOptions` variable, so the test\n   * above will not detect that lockdown has already happened. We\n   * unreliably test some telltale signs that lockdown has run, to avoid\n   * trying to lock down a locked down environment. Although the test is\n   * unreliable, this is consistent with the SES threat model. SES provides\n   * security only if it runs first in a given realm, or if everything that\n   * runs before it is SES-aware and cooperative. Neither SES nor anything\n   * can protect itself from corrupting code that runs first. For these\n   * purposes, code that turns a realm into something that passes these\n   * tests without actually locking down counts as corrupting code.\n   *\n   * The specifics of what this tests for may change over time, but it\n   * should be consistent with any setting of the lockdown options.\n   */\n  const seemsToBeLockedDown = () => {\n    return (\n      globalThis.Function.prototype.constructor !== globalThis.Function &&\n      // @ts-ignore harden is absent on globalThis type def.\n      typeof globalThis.harden === 'function' &&\n      // @ts-ignore lockdown is absent on globalThis type def.\n      typeof globalThis.lockdown === 'function' &&\n      globalThis.Date.prototype.constructor !== globalThis.Date &&\n      typeof globalThis.Date.now === 'function' &&\n      // @ts-ignore does not recognize that Date constructor is a special\n      // Function.\n      // eslint-disable-next-line @endo/no-polymorphic-call\n      is(globalThis.Date.prototype.constructor.now(), NaN)\n    );\n  };\n\n  if (seemsToBeLockedDown()) {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    throw new TypeError(\n      `Already locked down but not by this SES instance (SES_MULTIPLE_INSTANCES)`,\n    );\n  }\n\n  /**\n   * 1. TAME powers & gather intrinsics first.\n   */\n\n  tameDomains(domainTaming);\n\n  const {\n    addIntrinsics,\n    completePrototypes,\n    finalIntrinsics,\n  } = makeIntrinsicsCollector();\n\n  addIntrinsics({ harden });\n\n  addIntrinsics(tameFunctionConstructors());\n\n  addIntrinsics(tameDateConstructor(dateTaming));\n  addIntrinsics(tameErrorConstructor(errorTaming, stackFiltering));\n  addIntrinsics(tameMathObject(mathTaming));\n  addIntrinsics(tameRegExpConstructor(regExpTaming));\n\n  addIntrinsics(getAnonymousIntrinsics());\n\n  completePrototypes();\n\n  const intrinsics = finalIntrinsics();\n\n  // Wrap console unless suppressed.\n  // At the moment, the console is considered a host power in the start\n  // compartment, and not a primordial. Hence it is absent from the whilelist\n  // and bypasses the intrinsicsCollector.\n  let optGetStackString;\n  if (errorTaming !== 'unsafe') {\n    optGetStackString = intrinsics['%InitialGetStackString%'];\n  }\n  const consoleRecord = tameConsole(\n    // @ts-ignore tameConsole does its own input validation\n    consoleTaming,\n    errorTrapping,\n    optGetStackString,\n  );\n  globalThis.console = /** @type {Console} */ (consoleRecord.console);\n\n  // @ts-ignore assert is absent on globalThis type def.\n  if (errorTaming === 'unsafe' && globalThis.assert === assert) {\n    // If errorTaming is 'unsafe' we replace the global assert with\n    // one whose `details` template literal tag does not redact\n    // unmarked substitution values. IOW, it blabs information that\n    // was supposed to be secret from callers, as an aid to debugging\n    // at a further cost in safety.\n    // @ts-ignore assert is absent on globalThis type def.\n    globalThis.assert = makeAssert(undefined, true);\n  }\n\n  // Replace *Locale* methods with their non-locale equivalents\n  tameLocaleMethods(intrinsics, localeTaming);\n\n  // Replace Function.prototype.toString with one that recognizes\n  // shimmed functions as honorary native functions.\n  const markVirtualizedNativeFunction = tameFunctionToString();\n\n  /**\n   * 2. WHITELIST to standardize the environment.\n   */\n\n  // Remove non-standard properties.\n  // All remaining function encountered during whitelisting are\n  // branded as honorary native functions.\n  whitelistIntrinsics(intrinsics, markVirtualizedNativeFunction);\n\n  // Initialize the powerful initial global, i.e., the global of the\n  // start compartment, from the intrinsics.\n\n  setGlobalObjectConstantProperties(globalThis);\n\n  setGlobalObjectMutableProperties(globalThis, {\n    intrinsics,\n    newGlobalPropertyNames: initialGlobalPropertyNames,\n    makeCompartmentConstructor,\n    markVirtualizedNativeFunction,\n  });\n\n  if (evalTaming === 'noEval') {\n    setGlobalObjectEvaluators(\n      globalThis,\n      noEvalEvaluate,\n      markVirtualizedNativeFunction,\n    );\n  } else if (evalTaming === 'safeEval') {\n    const { safeEvaluate } = makeSafeEvaluator({ globalObject: globalThis });\n    setGlobalObjectEvaluators(\n      globalThis,\n      safeEvaluate,\n      markVirtualizedNativeFunction,\n    );\n  } else if (evalTaming === 'unsafeEval') {\n    // Leave eval function and Function constructor of the initial compartment in-tact.\n    // Other compartments will not have access to these evaluators unless a guest program\n    // escapes containment.\n  }\n\n  /**\n   * 3. HARDEN to share the intrinsics.\n   *\n   * We define hardenIntrinsics here so that options are in scope, but return\n   * it to the caller because we intend to eventually allow vetted shims to run\n   * between repairs and the hardening of intrinsics and so we can benchmark\n   * repair separately from hardening.\n   */\n\n  function hardenIntrinsics() {\n    // Circumvent the override mistake.\n    // TODO consider moving this to the end of the repair phase, and\n    // therefore before vetted shims rather than afterwards. It is not\n    // clear yet which is better.\n    // @ts-ignore enablePropertyOverrides does its own input validation\n    enablePropertyOverrides(intrinsics, overrideTaming, overrideDebug);\n\n    if (__allowUnsafeMonkeyPatching__ !== 'unsafe') {\n      // Finally register and optionally freeze all the intrinsics. This\n      // must be the operation that modifies the intrinsics.\n      harden(intrinsics);\n    }\n\n    // Reveal harden after lockdown.\n    // Harden is dangerous before lockdown because hardening just\n    // about anything will inadvertently render intrinsics irreparable.\n    // Also, for modules that must work both before or after lockdown (code\n    // that is portable between JS and SES), the existence of harden in global\n    // scope signals whether such code should attempt to use harden in the\n    // defense of its own API.\n    // @ts-ignore harden not yet recognized on globalThis.\n    globalThis.harden = harden;\n\n    // Returning `true` indicates that this is a JS to SES transition.\n    return true;\n  }\n\n  return hardenIntrinsics;\n};\n\n/**\n * @param {LockdownOptions} [options]\n */\nexport const lockdown = (options = {}) => {\n  const hardenIntrinsics = repairIntrinsics(options);\n  hardenIntrinsics();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}