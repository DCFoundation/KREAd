{"ast":null,"code":"// @ts-check\n// environment-options needs to be imported quite early, and so should\n// avoid importing from anything but commons.js and assert.js\nimport { arrayPush, arraySlice, freeze } from './commons.js';\nimport { assert } from './error/assert.js';\nconst {\n  details: X,\n  quote: q\n} = assert;\n/**\n * JavaScript module semantics resists attempts to parameterize a module's\n * initialization behavior. A module initializes in order according to\n * the path by which it is first imported, and then the initialized module\n * is reused by all the other times it is imported. Compartments give us\n * the opportunity to bind the same import name to different imported\n * modules, depending on the package/compartment doing the import. Compartments\n * also address the difficulty of parameterizing a module's initialization\n * logic, but not in a pleasant manner.\n *\n * A pleasant parameterization would be for a static module to be function-like\n * with explicit parameters, and for the parameterization to be like\n * calling the static module with parameters in order to derive from it a\n * module instance. Compartments instead lets us parameterize the meaning\n * of a module instance derived from a static module according to the\n * three namespaces provided by the JavaScript semantics, affecting the\n * meaning of a module instance.\n *    * The global variable namespaces.\n *       * The global scope, aliased to properties of the global object.\n *         This is necessarily compartment-wide, and therefore in our\n *         recommened usage pattern, package-wide.\n *       * The global lexical scope. The SES-shim compartments support\n *         these both compartment-wide as well as per-module. But it is\n *         not yet clear what we will propose in the Compartment proposal.\n *    * The import namespace.\n *    * The host hooks.\n *\n * This `environment-options.js` module looks for a setting of an\n * `optionName` parameter rooted in the global scope. If follows the Node\n * precedent for finding Unix environment variable settings, looking for a\n * global `process` object holding an `env` object,\n * optionally holding a property named for the `optionName` whose value is the\n * configuration setting of that option. For example, for the optionName\n * `FOO_BAR` it would look in\n * `globalThis.process.env.FOO_BAR`.\n *\n * If setting is either absent or `undefined`, that indicates that\n * this configuration option should have its default behavior, whatever that is.\n * Otherwise, reflecting Unix environment variables, the setting must be a\n * string. This also helps ensure that this channel is used only to pass data,\n * not authority beyond the ability to read this global state.\n */\n\n/**\n * makeEnvironmentCaptor provides a mechanism for getting environment\n * variables, if they are needed, and a way to catalog the names of all\n * the environment variables that were captured.\n *\n * @param {Object} aGlobal\n */\n\nexport const makeEnvironmentCaptor = aGlobal => {\n  const capturedEnvironmentOptionNames = [];\n  /**\n   * Gets an environment option by name and returns the option value or the\n   * given default.\n   *\n   * @param {string} optionName\n   * @param {string} defaultSetting\n   * @returns {string}\n   */\n\n  const getEnvironmentOption = (optionName, defaultSetting) => {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.typeof(optionName, 'string', X`Environment option name ${q(optionName)} must be a string.`); // eslint-disable-next-line @endo/no-polymorphic-call\n\n    assert.typeof(defaultSetting, 'string', X`Environment option default setting ${q(defaultSetting)} must be a string.`);\n    /** @type {string} */\n\n    let setting = defaultSetting;\n    const globalProcess = aGlobal.process;\n\n    if (globalProcess && typeof globalProcess === 'object') {\n      const globalEnv = globalProcess.env;\n\n      if (globalEnv && typeof globalEnv === 'object') {\n        if (optionName in globalEnv) {\n          arrayPush(capturedEnvironmentOptionNames, optionName);\n          const optionValue = globalEnv[optionName]; // eslint-disable-next-line @endo/no-polymorphic-call\n\n          assert.typeof(optionValue, 'string', X`Environment option named ${q(optionName)}, if present, must have a corresponding string value, got ${q(optionValue)}`);\n          setting = optionValue;\n        }\n      }\n    }\n\n    assert(setting === undefined || typeof setting === 'string', X`Environment option value ${q(setting)}, if present, must be a string.`);\n    return setting;\n  };\n\n  freeze(getEnvironmentOption);\n\n  const getCapturedEnvironmentOptionNames = () => {\n    return freeze(arraySlice(capturedEnvironmentOptionNames));\n  };\n\n  freeze(getCapturedEnvironmentOptionNames);\n  return {\n    getEnvironmentOption,\n    getCapturedEnvironmentOptionNames\n  };\n};\nfreeze(makeEnvironmentCaptor);","map":{"version":3,"names":["arrayPush","arraySlice","freeze","assert","details","X","quote","q","makeEnvironmentCaptor","aGlobal","capturedEnvironmentOptionNames","getEnvironmentOption","optionName","defaultSetting","typeof","setting","globalProcess","process","globalEnv","env","optionValue","undefined","getCapturedEnvironmentOptionNames"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/environment-options.js"],"sourcesContent":["// @ts-check\n\n// environment-options needs to be imported quite early, and so should\n// avoid importing from anything but commons.js and assert.js\nimport { arrayPush, arraySlice, freeze } from './commons.js';\nimport { assert } from './error/assert.js';\n\nconst { details: X, quote: q } = assert;\n\n/**\n * JavaScript module semantics resists attempts to parameterize a module's\n * initialization behavior. A module initializes in order according to\n * the path by which it is first imported, and then the initialized module\n * is reused by all the other times it is imported. Compartments give us\n * the opportunity to bind the same import name to different imported\n * modules, depending on the package/compartment doing the import. Compartments\n * also address the difficulty of parameterizing a module's initialization\n * logic, but not in a pleasant manner.\n *\n * A pleasant parameterization would be for a static module to be function-like\n * with explicit parameters, and for the parameterization to be like\n * calling the static module with parameters in order to derive from it a\n * module instance. Compartments instead lets us parameterize the meaning\n * of a module instance derived from a static module according to the\n * three namespaces provided by the JavaScript semantics, affecting the\n * meaning of a module instance.\n *    * The global variable namespaces.\n *       * The global scope, aliased to properties of the global object.\n *         This is necessarily compartment-wide, and therefore in our\n *         recommened usage pattern, package-wide.\n *       * The global lexical scope. The SES-shim compartments support\n *         these both compartment-wide as well as per-module. But it is\n *         not yet clear what we will propose in the Compartment proposal.\n *    * The import namespace.\n *    * The host hooks.\n *\n * This `environment-options.js` module looks for a setting of an\n * `optionName` parameter rooted in the global scope. If follows the Node\n * precedent for finding Unix environment variable settings, looking for a\n * global `process` object holding an `env` object,\n * optionally holding a property named for the `optionName` whose value is the\n * configuration setting of that option. For example, for the optionName\n * `FOO_BAR` it would look in\n * `globalThis.process.env.FOO_BAR`.\n *\n * If setting is either absent or `undefined`, that indicates that\n * this configuration option should have its default behavior, whatever that is.\n * Otherwise, reflecting Unix environment variables, the setting must be a\n * string. This also helps ensure that this channel is used only to pass data,\n * not authority beyond the ability to read this global state.\n */\n\n/**\n * makeEnvironmentCaptor provides a mechanism for getting environment\n * variables, if they are needed, and a way to catalog the names of all\n * the environment variables that were captured.\n *\n * @param {Object} aGlobal\n */\nexport const makeEnvironmentCaptor = aGlobal => {\n  const capturedEnvironmentOptionNames = [];\n\n  /**\n   * Gets an environment option by name and returns the option value or the\n   * given default.\n   *\n   * @param {string} optionName\n   * @param {string} defaultSetting\n   * @returns {string}\n   */\n  const getEnvironmentOption = (optionName, defaultSetting) => {\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.typeof(\n      optionName,\n      'string',\n      X`Environment option name ${q(optionName)} must be a string.`,\n    );\n    // eslint-disable-next-line @endo/no-polymorphic-call\n    assert.typeof(\n      defaultSetting,\n      'string',\n      X`Environment option default setting ${q(\n        defaultSetting,\n      )} must be a string.`,\n    );\n\n    /** @type {string} */\n    let setting = defaultSetting;\n    const globalProcess = aGlobal.process;\n    if (globalProcess && typeof globalProcess === 'object') {\n      const globalEnv = globalProcess.env;\n      if (globalEnv && typeof globalEnv === 'object') {\n        if (optionName in globalEnv) {\n          arrayPush(capturedEnvironmentOptionNames, optionName);\n          const optionValue = globalEnv[optionName];\n          // eslint-disable-next-line @endo/no-polymorphic-call\n          assert.typeof(\n            optionValue,\n            'string',\n            X`Environment option named ${q(\n              optionName,\n            )}, if present, must have a corresponding string value, got ${q(\n              optionValue,\n            )}`,\n          );\n          setting = optionValue;\n        }\n      }\n    }\n    assert(\n      setting === undefined || typeof setting === 'string',\n      X`Environment option value ${q(setting)}, if present, must be a string.`,\n    );\n    return setting;\n  };\n  freeze(getEnvironmentOption);\n\n  const getCapturedEnvironmentOptionNames = () => {\n    return freeze(arraySlice(capturedEnvironmentOptionNames));\n  };\n  freeze(getCapturedEnvironmentOptionNames);\n\n  return { getEnvironmentOption, getCapturedEnvironmentOptionNames };\n};\nfreeze(makeEnvironmentCaptor);\n"],"mappings":"AAAA;AAEA;AACA;AACA,SAASA,SAAT,EAAoBC,UAApB,EAAgCC,MAAhC,QAA8C,cAA9C;AACA,SAASC,MAAT,QAAuB,mBAAvB;AAEA,MAAM;EAAEC,OAAO,EAAEC,CAAX;EAAcC,KAAK,EAAEC;AAArB,IAA2BJ,MAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMK,qBAAqB,GAAGC,OAAO,IAAI;EAC9C,MAAMC,8BAA8B,GAAG,EAAvC;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,MAAMC,oBAAoB,GAAG,CAACC,UAAD,EAAaC,cAAb,KAAgC;IAC3D;IACAV,MAAM,CAACW,MAAP,CACEF,UADF,EAEE,QAFF,EAGEP,CAAE,2BAA0BE,CAAC,CAACK,UAAD,CAAa,oBAH5C,EAF2D,CAO3D;;IACAT,MAAM,CAACW,MAAP,CACED,cADF,EAEE,QAFF,EAGER,CAAE,sCAAqCE,CAAC,CACtCM,cADsC,CAEtC,oBALJ;IAQA;;IACA,IAAIE,OAAO,GAAGF,cAAd;IACA,MAAMG,aAAa,GAAGP,OAAO,CAACQ,OAA9B;;IACA,IAAID,aAAa,IAAI,OAAOA,aAAP,KAAyB,QAA9C,EAAwD;MACtD,MAAME,SAAS,GAAGF,aAAa,CAACG,GAAhC;;MACA,IAAID,SAAS,IAAI,OAAOA,SAAP,KAAqB,QAAtC,EAAgD;QAC9C,IAAIN,UAAU,IAAIM,SAAlB,EAA6B;UAC3BlB,SAAS,CAACU,8BAAD,EAAiCE,UAAjC,CAAT;UACA,MAAMQ,WAAW,GAAGF,SAAS,CAACN,UAAD,CAA7B,CAF2B,CAG3B;;UACAT,MAAM,CAACW,MAAP,CACEM,WADF,EAEE,QAFF,EAGEf,CAAE,4BAA2BE,CAAC,CAC5BK,UAD4B,CAE5B,6DAA4DL,CAAC,CAC7Da,WAD6D,CAE7D,EAPJ;UASAL,OAAO,GAAGK,WAAV;QACD;MACF;IACF;;IACDjB,MAAM,CACJY,OAAO,KAAKM,SAAZ,IAAyB,OAAON,OAAP,KAAmB,QADxC,EAEJV,CAAE,4BAA2BE,CAAC,CAACQ,OAAD,CAAU,iCAFpC,CAAN;IAIA,OAAOA,OAAP;EACD,CA5CD;;EA6CAb,MAAM,CAACS,oBAAD,CAAN;;EAEA,MAAMW,iCAAiC,GAAG,MAAM;IAC9C,OAAOpB,MAAM,CAACD,UAAU,CAACS,8BAAD,CAAX,CAAb;EACD,CAFD;;EAGAR,MAAM,CAACoB,iCAAD,CAAN;EAEA,OAAO;IAAEX,oBAAF;IAAwBW;EAAxB,CAAP;AACD,CAhEM;AAiEPpB,MAAM,CAACM,qBAAD,CAAN"},"metadata":{},"sourceType":"module"}