{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { assertChecker, canBeMethod, hasOwnPropertyOf, PASS_STYLE, checkTagRecord, isObject, getTag } from './passStyle-helpers.js';\n/** @typedef {import('../types.js').Checker} Checker */\n\n/** @typedef {import('../types.js').InterfaceSpec} InterfaceSpec */\n\n/** @typedef {import('../types.js').MarshalGetInterfaceOf} MarshalGetInterfaceOf */\n\n/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */\n\n/** @typedef {import('../types.js').Remotable} Remotable */\n\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  ownKeys\n} = Reflect;\nconst {\n  prototype: functionPrototype\n} = Function;\nconst {\n  isArray\n} = Array;\nconst {\n  getPrototypeOf,\n  isFrozen,\n  prototype: objectPrototype,\n  getOwnPropertyDescriptors\n} = Object;\n/**\n * @param {InterfaceSpec} iface\n * @param {Checker=} check\n */\n\nconst checkIface = function (iface) {\n  let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n  return (// TODO other possible ifaces, once we have third party veracity\n    check(typeof iface === 'string', X`For now, interface ${iface} must be a string; unimplemented`) && check(iface === 'Remotable' || iface.startsWith('Alleged: '), X`For now, iface ${q(iface)} must be \"Remotable\" or begin with \"Alleged: \"; unimplemented`)\n  );\n};\n/**\n * An `iface` must be pure. Right now it must be a string, which is pure.\n * Later we expect to include some other values that qualify as `PureData`,\n * which is a pass-by-copy superstructure ending only in primitives or\n * empty pass-by-copy composites. No remotables, promises, or errors.\n * We *assume* for now that the pass-by-copy superstructure contains no\n * proxies.\n *\n * @param {InterfaceSpec} iface\n */\n\n\nexport const assertIface = iface => checkIface(iface, assertChecker);\nharden(assertIface);\n/**\n * @param {any} original\n * @param {Checker} [check]\n * @returns {boolean}\n */\n\nconst checkRemotableProtoOf = function (original) {\n  let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  /**\n   * TODO: It would be nice to typedef this shape, but we can't declare a type\n   * with PASS_STYLE from JSDoc.\n   *\n   * @type {{ [PASS_STYLE]: string,\n   *          [Symbol.toStringTag]: string,\n   *        }}\n   */\n  const proto = getPrototypeOf(original);\n\n  if (!(check( // Since we're working with TypeScript's unsound type system, mostly\n  // to catch accidents and to provide IDE support, we type arguments\n  // like `val` according to what they are supposed to be. The following\n  // tests for a particular violation. However, TypeScript complains\n  // because *if the declared type were accurate*, then the condition\n  // would always return true.\n  // @ts-ignore TypeScript assumes what we're trying to check\n  proto !== objectPrototype, X`Remotables must be explicitly declared: ${q(original)}`) && checkTagRecord(proto, 'remotable', check))) {\n    return false;\n  }\n\n  const protoProto = getPrototypeOf(proto);\n\n  if (typeof original === 'object') {\n    if (!check(protoProto === objectPrototype || protoProto === null, X`The Remotable Proto marker cannot inherit from anything unusual`)) {\n      return false;\n    }\n  } else if (typeof original === 'function') {\n    if (!check(protoProto === functionPrototype || getPrototypeOf(protoProto) === functionPrototype, X`For far functions, the Remotable Proto marker must inherit from Function.prototype, in ${original}`)) {\n      return false;\n    }\n  } else {\n    assert.fail(X`unrecognized typeof ${original}`);\n  }\n\n  const {\n    [PASS_STYLE]: _passStyle,\n    [Symbol.toStringTag]: iface,\n    ...rest\n  } = proto;\n  return check(ownKeys(rest).length === 0, X`Unexpected properties on Remotable Proto ${ownKeys(rest)}`) && checkIface(iface, check);\n};\n/**\n * @param {Remotable} val\n * @param {Checker} [check]\n * @returns {boolean}\n */\n\n\nconst checkRemotable = function (val) {\n  let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n  const not = (cond, details) => !check(cond, details);\n\n  if (not(isFrozen(val), X`cannot serialize non-frozen objects like ${val}`)) {\n    return false;\n  } // eslint-disable-next-line no-use-before-define\n\n\n  if (!RemotableHelper.canBeValid(val, check)) {\n    return false;\n  }\n\n  return checkRemotableProtoOf(val, check);\n};\n/** @type {MarshalGetInterfaceOf} */\n\n\nexport const getInterfaceOf = val => {\n  const typestr = typeof val;\n\n  if (typestr !== 'object' && typestr !== 'function' || val === null || val[PASS_STYLE] !== 'remotable' || !checkRemotable(val)) {\n    return undefined;\n  }\n\n  return getTag(val);\n};\nharden(getInterfaceOf);\n/**\n *\n * @type {PassStyleHelper}\n */\n\nexport const RemotableHelper = harden({\n  styleName: 'remotable',\n  canBeValid: function (candidate) {\n    let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n    if (!(check(isObject(candidate), X`cannot serialize non-objects like ${candidate}`) && check(!isArray(candidate), X`Arrays cannot be pass-by-remote`))) {\n      return false;\n    }\n\n    const descs = getOwnPropertyDescriptors(candidate);\n\n    if (typeof candidate === 'object') {\n      const keys = ownKeys(descs); // enumerable-and-not, string-or-Symbol\n\n      return keys.every(key => // Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863\n      check(hasOwnPropertyOf(descs[\n      /** @type {string} */\n      key], 'value'), X`cannot serialize Remotables with accessors like ${q(String(key))} in ${candidate}`) && check(canBeMethod(candidate[key]), X`cannot serialize Remotables with non-methods like ${q(String(key))} in ${candidate}`) && check(key !== PASS_STYLE, X`A pass-by-remote cannot shadow ${q(PASS_STYLE)}`));\n    } else if (typeof candidate === 'function') {\n      // Far functions cannot be methods, and cannot have methods.\n      // They must have exactly expected `.name` and `.length` properties\n      const {\n        name: nameDesc,\n        length: lengthDesc,\n        ...restDescs\n      } = descs;\n      const restKeys = ownKeys(restDescs);\n      return check(nameDesc && typeof nameDesc.value === 'string', X`Far function name must be a string, in ${candidate}`) && check(lengthDesc && typeof lengthDesc.value === 'number', X`Far function length must be a number, in ${candidate}`) && check(restKeys.length === 0, X`Far functions unexpected properties besides .name and .length ${restKeys}`);\n    } else {\n      return check(false, X`unrecognized typeof ${candidate}`);\n    }\n  },\n  assertValid: candidate => {\n    RemotableHelper.canBeValid(candidate, assertChecker);\n    checkRemotable(candidate, assertChecker);\n  },\n  every: (_passable, _fn) => true\n});","map":{"version":3,"names":["assertChecker","canBeMethod","hasOwnPropertyOf","PASS_STYLE","checkTagRecord","isObject","getTag","details","X","quote","q","assert","ownKeys","Reflect","prototype","functionPrototype","Function","isArray","Array","getPrototypeOf","isFrozen","objectPrototype","getOwnPropertyDescriptors","Object","checkIface","iface","check","x","startsWith","assertIface","harden","checkRemotableProtoOf","original","proto","protoProto","fail","_passStyle","Symbol","toStringTag","rest","length","checkRemotable","val","not","cond","RemotableHelper","canBeValid","getInterfaceOf","typestr","undefined","styleName","candidate","descs","keys","every","key","String","name","nameDesc","lengthDesc","restDescs","restKeys","value","assertValid","_passable","_fn"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/helpers/remotable.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport {\n  assertChecker,\n  canBeMethod,\n  hasOwnPropertyOf,\n  PASS_STYLE,\n  checkTagRecord,\n  isObject,\n  getTag,\n} from './passStyle-helpers.js';\n\n/** @typedef {import('../types.js').Checker} Checker */\n/** @typedef {import('../types.js').InterfaceSpec} InterfaceSpec */\n/** @typedef {import('../types.js').MarshalGetInterfaceOf} MarshalGetInterfaceOf */\n/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */\n/** @typedef {import('../types.js').Remotable} Remotable */\n\nconst { details: X, quote: q } = assert;\nconst { ownKeys } = Reflect;\nconst { prototype: functionPrototype } = Function;\nconst { isArray } = Array;\nconst {\n  getPrototypeOf,\n  isFrozen,\n  prototype: objectPrototype,\n  getOwnPropertyDescriptors,\n} = Object;\n\n/**\n * @param {InterfaceSpec} iface\n * @param {Checker=} check\n */\nconst checkIface = (iface, check = x => x) => {\n  return (\n    // TODO other possible ifaces, once we have third party veracity\n    check(\n      typeof iface === 'string',\n      X`For now, interface ${iface} must be a string; unimplemented`,\n    ) &&\n    check(\n      iface === 'Remotable' || iface.startsWith('Alleged: '),\n      X`For now, iface ${q(\n        iface,\n      )} must be \"Remotable\" or begin with \"Alleged: \"; unimplemented`,\n    )\n  );\n};\n\n/**\n * An `iface` must be pure. Right now it must be a string, which is pure.\n * Later we expect to include some other values that qualify as `PureData`,\n * which is a pass-by-copy superstructure ending only in primitives or\n * empty pass-by-copy composites. No remotables, promises, or errors.\n * We *assume* for now that the pass-by-copy superstructure contains no\n * proxies.\n *\n * @param {InterfaceSpec} iface\n */\nexport const assertIface = iface => checkIface(iface, assertChecker);\nharden(assertIface);\n\n/**\n * @param {any} original\n * @param {Checker} [check]\n * @returns {boolean}\n */\nconst checkRemotableProtoOf = (original, check = x => x) => {\n  /**\n   * TODO: It would be nice to typedef this shape, but we can't declare a type\n   * with PASS_STYLE from JSDoc.\n   *\n   * @type {{ [PASS_STYLE]: string,\n   *          [Symbol.toStringTag]: string,\n   *        }}\n   */\n  const proto = getPrototypeOf(original);\n  if (\n    !(\n      check(\n        // Since we're working with TypeScript's unsound type system, mostly\n        // to catch accidents and to provide IDE support, we type arguments\n        // like `val` according to what they are supposed to be. The following\n        // tests for a particular violation. However, TypeScript complains\n        // because *if the declared type were accurate*, then the condition\n        // would always return true.\n        // @ts-ignore TypeScript assumes what we're trying to check\n        proto !== objectPrototype,\n        X`Remotables must be explicitly declared: ${q(original)}`,\n      ) && checkTagRecord(proto, 'remotable', check)\n    )\n  ) {\n    return false;\n  }\n\n  const protoProto = getPrototypeOf(proto);\n\n  if (typeof original === 'object') {\n    if (\n      !check(\n        protoProto === objectPrototype || protoProto === null,\n        X`The Remotable Proto marker cannot inherit from anything unusual`,\n      )\n    ) {\n      return false;\n    }\n  } else if (typeof original === 'function') {\n    if (\n      !check(\n        protoProto === functionPrototype ||\n          getPrototypeOf(protoProto) === functionPrototype,\n        X`For far functions, the Remotable Proto marker must inherit from Function.prototype, in ${original}`,\n      )\n    ) {\n      return false;\n    }\n  } else {\n    assert.fail(X`unrecognized typeof ${original}`);\n  }\n\n  const {\n    [PASS_STYLE]: _passStyle,\n    [Symbol.toStringTag]: iface,\n    ...rest\n  } = proto;\n\n  return (\n    check(\n      ownKeys(rest).length === 0,\n      X`Unexpected properties on Remotable Proto ${ownKeys(rest)}`,\n    ) && checkIface(iface, check)\n  );\n};\n\n/**\n * @param {Remotable} val\n * @param {Checker} [check]\n * @returns {boolean}\n */\nconst checkRemotable = (val, check = x => x) => {\n  const not = (cond, details) => !check(cond, details);\n  if (not(isFrozen(val), X`cannot serialize non-frozen objects like ${val}`)) {\n    return false;\n  }\n  // eslint-disable-next-line no-use-before-define\n  if (!RemotableHelper.canBeValid(val, check)) {\n    return false;\n  }\n  return checkRemotableProtoOf(val, check);\n};\n\n/** @type {MarshalGetInterfaceOf} */\nexport const getInterfaceOf = val => {\n  const typestr = typeof val;\n  if (\n    (typestr !== 'object' && typestr !== 'function') ||\n    val === null ||\n    val[PASS_STYLE] !== 'remotable' ||\n    !checkRemotable(val)\n  ) {\n    return undefined;\n  }\n  return getTag(val);\n};\nharden(getInterfaceOf);\n\n/**\n *\n * @type {PassStyleHelper}\n */\nexport const RemotableHelper = harden({\n  styleName: 'remotable',\n\n  canBeValid: (candidate, check = x => x) => {\n    if (\n      !(\n        check(\n          isObject(candidate),\n          X`cannot serialize non-objects like ${candidate}`,\n        ) && check(!isArray(candidate), X`Arrays cannot be pass-by-remote`)\n      )\n    ) {\n      return false;\n    }\n\n    const descs = getOwnPropertyDescriptors(candidate);\n    if (typeof candidate === 'object') {\n      const keys = ownKeys(descs); // enumerable-and-not, string-or-Symbol\n      return keys.every(\n        key =>\n          // Typecast needed due to https://github.com/microsoft/TypeScript/issues/1863\n          check(\n            hasOwnPropertyOf(descs[/** @type {string} */ (key)], 'value'),\n            X`cannot serialize Remotables with accessors like ${q(\n              String(key),\n            )} in ${candidate}`,\n          ) &&\n          check(\n            canBeMethod(candidate[key]),\n            X`cannot serialize Remotables with non-methods like ${q(\n              String(key),\n            )} in ${candidate}`,\n          ) &&\n          check(\n            key !== PASS_STYLE,\n            X`A pass-by-remote cannot shadow ${q(PASS_STYLE)}`,\n          ),\n      );\n    } else if (typeof candidate === 'function') {\n      // Far functions cannot be methods, and cannot have methods.\n      // They must have exactly expected `.name` and `.length` properties\n      const { name: nameDesc, length: lengthDesc, ...restDescs } = descs;\n      const restKeys = ownKeys(restDescs);\n      return (\n        (check(\n          nameDesc && typeof nameDesc.value === 'string',\n          X`Far function name must be a string, in ${candidate}`,\n        ) &&\n        check(\n          lengthDesc && typeof lengthDesc.value === 'number',\n          X`Far function length must be a number, in ${candidate}`,\n        ) &&\n        check(\n          restKeys.length === 0,\n          X`Far functions unexpected properties besides .name and .length ${restKeys}`,\n        ))\n      );\n    } else {\n      return check(false, X`unrecognized typeof ${candidate}`);\n    }\n  },\n\n  assertValid: candidate => {\n    RemotableHelper.canBeValid(candidate, assertChecker);\n    checkRemotable(candidate, assertChecker);\n  },\n\n  every: (_passable, _fn) => true,\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}