{"ast":null,"code":"import { FERAL_REG_EXP, regexpExec, stringSlice } from './commons.js'; // Captures a key and value of the form #key=value or @key=value\n\nconst sourceMetaEntryRegExp = '\\\\s*[@#]\\\\s*([a-zA-Z][a-zA-Z0-9]*)\\\\s*=\\\\s*([^\\\\s\\\\*]*)'; // Captures either a one-line or multi-line comment containing\n// one #key=value or @key=value.\n// Produces two pairs of capture groups, but the initial two may be undefined.\n// On account of the mechanics of regular expressions, scanning from the end\n// does not allow us to capture every pair, so getSourceURL must capture and\n// trim until there are no matching comments.\n\nconst sourceMetaEntriesRegExp = new FERAL_REG_EXP(`(?:\\\\s*//${sourceMetaEntryRegExp}|/\\\\*${sourceMetaEntryRegExp}\\\\s*\\\\*/)\\\\s*$`);\nexport const getSourceURL = src => {\n  let sourceURL = '<unknown>'; // Our regular expression matches the last one or two comments with key value\n  // pairs at the end of the source, avoiding a scan over the entire length of\n  // the string, but at the expense of being able to capture all the (key,\n  // value) pair meta comments at the end of the source, which may include\n  // sourceMapURL in addition to sourceURL.\n  // So, we sublimate the comments out of the source until no source or no\n  // comments remain.\n\n  while (src.length > 0) {\n    const match = regexpExec(sourceMetaEntriesRegExp, src);\n\n    if (match === null) {\n      break;\n    }\n\n    src = stringSlice(src, 0, src.length - match[0].length); // We skip $0 since it contains the entire match.\n    // The match contains four capture groups,\n    // two (key, value) pairs, the first of which\n    // may be undefined.\n    // On the off-chance someone put two sourceURL comments in their code with\n    // different commenting conventions, the latter has precedence.\n\n    if (match[3] === 'sourceURL') {\n      sourceURL = match[4];\n    } else if (match[1] === 'sourceURL') {\n      sourceURL = match[2];\n    }\n  }\n\n  return sourceURL;\n};","map":{"version":3,"names":["FERAL_REG_EXP","regexpExec","stringSlice","sourceMetaEntryRegExp","sourceMetaEntriesRegExp","getSourceURL","src","sourceURL","length","match"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/get-source-url.js"],"sourcesContent":["import { FERAL_REG_EXP, regexpExec, stringSlice } from './commons.js';\n\n// Captures a key and value of the form #key=value or @key=value\nconst sourceMetaEntryRegExp =\n  '\\\\s*[@#]\\\\s*([a-zA-Z][a-zA-Z0-9]*)\\\\s*=\\\\s*([^\\\\s\\\\*]*)';\n// Captures either a one-line or multi-line comment containing\n// one #key=value or @key=value.\n// Produces two pairs of capture groups, but the initial two may be undefined.\n// On account of the mechanics of regular expressions, scanning from the end\n// does not allow us to capture every pair, so getSourceURL must capture and\n// trim until there are no matching comments.\nconst sourceMetaEntriesRegExp = new FERAL_REG_EXP(\n  `(?:\\\\s*//${sourceMetaEntryRegExp}|/\\\\*${sourceMetaEntryRegExp}\\\\s*\\\\*/)\\\\s*$`,\n);\n\nexport const getSourceURL = src => {\n  let sourceURL = '<unknown>';\n\n  // Our regular expression matches the last one or two comments with key value\n  // pairs at the end of the source, avoiding a scan over the entire length of\n  // the string, but at the expense of being able to capture all the (key,\n  // value) pair meta comments at the end of the source, which may include\n  // sourceMapURL in addition to sourceURL.\n  // So, we sublimate the comments out of the source until no source or no\n  // comments remain.\n  while (src.length > 0) {\n    const match = regexpExec(sourceMetaEntriesRegExp, src);\n    if (match === null) {\n      break;\n    }\n    src = stringSlice(src, 0, src.length - match[0].length);\n\n    // We skip $0 since it contains the entire match.\n    // The match contains four capture groups,\n    // two (key, value) pairs, the first of which\n    // may be undefined.\n    // On the off-chance someone put two sourceURL comments in their code with\n    // different commenting conventions, the latter has precedence.\n    if (match[3] === 'sourceURL') {\n      sourceURL = match[4];\n    } else if (match[1] === 'sourceURL') {\n      sourceURL = match[2];\n    }\n  }\n\n  return sourceURL;\n};\n"],"mappings":"AAAA,SAASA,aAAT,EAAwBC,UAAxB,EAAoCC,WAApC,QAAuD,cAAvD,C,CAEA;;AACA,MAAMC,qBAAqB,GACzB,yDADF,C,CAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,uBAAuB,GAAG,IAAIJ,aAAJ,CAC7B,YAAWG,qBAAsB,QAAOA,qBAAsB,gBADjC,CAAhC;AAIA,OAAO,MAAME,YAAY,GAAGC,GAAG,IAAI;EACjC,IAAIC,SAAS,GAAG,WAAhB,CADiC,CAGjC;EACA;EACA;EACA;EACA;EACA;EACA;;EACA,OAAOD,GAAG,CAACE,MAAJ,GAAa,CAApB,EAAuB;IACrB,MAAMC,KAAK,GAAGR,UAAU,CAACG,uBAAD,EAA0BE,GAA1B,CAAxB;;IACA,IAAIG,KAAK,KAAK,IAAd,EAAoB;MAClB;IACD;;IACDH,GAAG,GAAGJ,WAAW,CAACI,GAAD,EAAM,CAAN,EAASA,GAAG,CAACE,MAAJ,GAAaC,KAAK,CAAC,CAAD,CAAL,CAASD,MAA/B,CAAjB,CALqB,CAOrB;IACA;IACA;IACA;IACA;IACA;;IACA,IAAIC,KAAK,CAAC,CAAD,CAAL,KAAa,WAAjB,EAA8B;MAC5BF,SAAS,GAAGE,KAAK,CAAC,CAAD,CAAjB;IACD,CAFD,MAEO,IAAIA,KAAK,CAAC,CAAD,CAAL,KAAa,WAAjB,EAA8B;MACnCF,SAAS,GAAGE,KAAK,CAAC,CAAD,CAAjB;IACD;EACF;;EAED,OAAOF,SAAP;AACD,CA/BM"},"metadata":{},"sourceType":"module"}