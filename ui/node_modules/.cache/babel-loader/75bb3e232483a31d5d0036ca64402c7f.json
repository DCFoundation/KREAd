{"ast":null,"code":"import { TypeError, WeakSet, arrayFilter, defineProperty, entries, freeze, getOwnPropertyDescriptor, getOwnPropertyDescriptors, globalThis, is, isObject, objectHasOwnProperty, values, weaksetHas } from './commons.js';\nimport { constantProperties, sharedGlobalPropertyNames, universalPropertyNames, whitelist } from './whitelist.js';\n\nconst isFunction = obj => typeof obj === 'function'; // Like defineProperty, but throws if it would modify an existing property.\n// We use this to ensure that two conflicting attempts to define the same\n// property throws, causing SES initialization to fail. Otherwise, a\n// conflict between, for example, two of SES's internal whitelists might\n// get masked as one overwrites the other. Accordingly, the thrown error\n// complains of a \"Conflicting definition\".\n\n\nfunction initProperty(obj, name, desc) {\n  if (objectHasOwnProperty(obj, name)) {\n    const preDesc = getOwnPropertyDescriptor(obj, name);\n\n    if (!is(preDesc.value, desc.value) || preDesc.get !== desc.get || preDesc.set !== desc.set || preDesc.writable !== desc.writable || preDesc.enumerable !== desc.enumerable || preDesc.configurable !== desc.configurable) {\n      throw new TypeError(`Conflicting definitions of ${name}`);\n    }\n  }\n\n  defineProperty(obj, name, desc);\n} // Like defineProperties, but throws if it would modify an existing property.\n// This ensures that the intrinsics added to the intrinsics collector object\n// graph do not overlap.\n\n\nfunction initProperties(obj, descs) {\n  for (const [name, desc] of entries(descs)) {\n    initProperty(obj, name, desc);\n  }\n} // sampleGlobals creates an intrinsics object, suitable for\n// interinsicsCollector.addIntrinsics, from the named properties of a global\n// object.\n\n\nfunction sampleGlobals(globalObject, newPropertyNames) {\n  const newIntrinsics = {\n    __proto__: null\n  };\n\n  for (const [globalName, intrinsicName] of entries(newPropertyNames)) {\n    if (objectHasOwnProperty(globalObject, globalName)) {\n      newIntrinsics[intrinsicName] = globalObject[globalName];\n    }\n  }\n\n  return newIntrinsics;\n}\n\nexport const makeIntrinsicsCollector = () => {\n  const intrinsics = {\n    __proto__: null\n  };\n  let pseudoNatives;\n\n  const addIntrinsics = newIntrinsics => {\n    initProperties(intrinsics, getOwnPropertyDescriptors(newIntrinsics));\n  };\n\n  freeze(addIntrinsics); // For each intrinsic, if it has a `.prototype` property, use the\n  // whitelist to find out the intrinsic name for that prototype and add it\n  // to the intrinsics.\n\n  const completePrototypes = () => {\n    for (const [name, intrinsic] of entries(intrinsics)) {\n      if (!isObject(intrinsic)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (!objectHasOwnProperty(intrinsic, 'prototype')) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      const permit = whitelist[name];\n\n      if (typeof permit !== 'object') {\n        throw new TypeError(`Expected permit object at whitelist.${name}`);\n      }\n\n      const namePrototype = permit.prototype;\n\n      if (!namePrototype) {\n        throw new TypeError(`${name}.prototype property not whitelisted`);\n      }\n\n      if (typeof namePrototype !== 'string' || !objectHasOwnProperty(whitelist, namePrototype)) {\n        throw new TypeError(`Unrecognized ${name}.prototype whitelist entry`);\n      }\n\n      const intrinsicPrototype = intrinsic.prototype;\n\n      if (objectHasOwnProperty(intrinsics, namePrototype)) {\n        if (intrinsics[namePrototype] !== intrinsicPrototype) {\n          throw new TypeError(`Conflicting bindings of ${namePrototype}`);\n        } // eslint-disable-next-line no-continue\n\n\n        continue;\n      }\n\n      intrinsics[namePrototype] = intrinsicPrototype;\n    }\n  };\n\n  freeze(completePrototypes);\n\n  const finalIntrinsics = () => {\n    freeze(intrinsics);\n    pseudoNatives = new WeakSet(arrayFilter(values(intrinsics), isFunction));\n    return intrinsics;\n  };\n\n  freeze(finalIntrinsics);\n\n  const isPseudoNative = obj => {\n    if (!pseudoNatives) {\n      throw new TypeError('isPseudoNative can only be called after finalIntrinsics');\n    }\n\n    return weaksetHas(pseudoNatives, obj);\n  };\n\n  freeze(isPseudoNative);\n  const intrinsicsCollector = {\n    addIntrinsics,\n    completePrototypes,\n    finalIntrinsics,\n    isPseudoNative\n  };\n  freeze(intrinsicsCollector);\n  addIntrinsics(constantProperties);\n  addIntrinsics(sampleGlobals(globalThis, universalPropertyNames));\n  return intrinsicsCollector;\n};\n/**\n * getGlobalIntrinsics()\n * Doesn't tame, delete, or modify anything. Samples globalObject to create an\n * intrinsics record containing only the whitelisted global variables, listed\n * by the intrinsic names appropriate for new globals, i.e., the globals of\n * newly constructed compartments.\n *\n * WARNING:\n * If run before lockdown, the returned intrinsics record will carry the\n * *original* unsafe (feral, untamed) bindings of these global variables.\n *\n * @param {Object} globalObject\n */\n\nexport const getGlobalIntrinsics = globalObject => {\n  const {\n    addIntrinsics,\n    finalIntrinsics\n  } = makeIntrinsicsCollector();\n  addIntrinsics(sampleGlobals(globalObject, sharedGlobalPropertyNames));\n  return finalIntrinsics();\n};","map":{"version":3,"names":["TypeError","WeakSet","arrayFilter","defineProperty","entries","freeze","getOwnPropertyDescriptor","getOwnPropertyDescriptors","globalThis","is","isObject","objectHasOwnProperty","values","weaksetHas","constantProperties","sharedGlobalPropertyNames","universalPropertyNames","whitelist","isFunction","obj","initProperty","name","desc","preDesc","value","get","set","writable","enumerable","configurable","initProperties","descs","sampleGlobals","globalObject","newPropertyNames","newIntrinsics","__proto__","globalName","intrinsicName","makeIntrinsicsCollector","intrinsics","pseudoNatives","addIntrinsics","completePrototypes","intrinsic","permit","namePrototype","prototype","intrinsicPrototype","finalIntrinsics","isPseudoNative","intrinsicsCollector","getGlobalIntrinsics"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/intrinsics.js"],"sourcesContent":["import {\n  TypeError,\n  WeakSet,\n  arrayFilter,\n  defineProperty,\n  entries,\n  freeze,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  globalThis,\n  is,\n  isObject,\n  objectHasOwnProperty,\n  values,\n  weaksetHas,\n} from './commons.js';\n\nimport {\n  constantProperties,\n  sharedGlobalPropertyNames,\n  universalPropertyNames,\n  whitelist,\n} from './whitelist.js';\n\nconst isFunction = obj => typeof obj === 'function';\n\n// Like defineProperty, but throws if it would modify an existing property.\n// We use this to ensure that two conflicting attempts to define the same\n// property throws, causing SES initialization to fail. Otherwise, a\n// conflict between, for example, two of SES's internal whitelists might\n// get masked as one overwrites the other. Accordingly, the thrown error\n// complains of a \"Conflicting definition\".\nfunction initProperty(obj, name, desc) {\n  if (objectHasOwnProperty(obj, name)) {\n    const preDesc = getOwnPropertyDescriptor(obj, name);\n    if (\n      !is(preDesc.value, desc.value) ||\n      preDesc.get !== desc.get ||\n      preDesc.set !== desc.set ||\n      preDesc.writable !== desc.writable ||\n      preDesc.enumerable !== desc.enumerable ||\n      preDesc.configurable !== desc.configurable\n    ) {\n      throw new TypeError(`Conflicting definitions of ${name}`);\n    }\n  }\n  defineProperty(obj, name, desc);\n}\n\n// Like defineProperties, but throws if it would modify an existing property.\n// This ensures that the intrinsics added to the intrinsics collector object\n// graph do not overlap.\nfunction initProperties(obj, descs) {\n  for (const [name, desc] of entries(descs)) {\n    initProperty(obj, name, desc);\n  }\n}\n\n// sampleGlobals creates an intrinsics object, suitable for\n// interinsicsCollector.addIntrinsics, from the named properties of a global\n// object.\nfunction sampleGlobals(globalObject, newPropertyNames) {\n  const newIntrinsics = { __proto__: null };\n  for (const [globalName, intrinsicName] of entries(newPropertyNames)) {\n    if (objectHasOwnProperty(globalObject, globalName)) {\n      newIntrinsics[intrinsicName] = globalObject[globalName];\n    }\n  }\n  return newIntrinsics;\n}\n\nexport const makeIntrinsicsCollector = () => {\n  const intrinsics = { __proto__: null };\n  let pseudoNatives;\n\n  const addIntrinsics = newIntrinsics => {\n    initProperties(intrinsics, getOwnPropertyDescriptors(newIntrinsics));\n  };\n  freeze(addIntrinsics);\n\n  // For each intrinsic, if it has a `.prototype` property, use the\n  // whitelist to find out the intrinsic name for that prototype and add it\n  // to the intrinsics.\n  const completePrototypes = () => {\n    for (const [name, intrinsic] of entries(intrinsics)) {\n      if (!isObject(intrinsic)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      if (!objectHasOwnProperty(intrinsic, 'prototype')) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const permit = whitelist[name];\n      if (typeof permit !== 'object') {\n        throw new TypeError(`Expected permit object at whitelist.${name}`);\n      }\n      const namePrototype = permit.prototype;\n      if (!namePrototype) {\n        throw new TypeError(`${name}.prototype property not whitelisted`);\n      }\n      if (\n        typeof namePrototype !== 'string' ||\n        !objectHasOwnProperty(whitelist, namePrototype)\n      ) {\n        throw new TypeError(`Unrecognized ${name}.prototype whitelist entry`);\n      }\n      const intrinsicPrototype = intrinsic.prototype;\n      if (objectHasOwnProperty(intrinsics, namePrototype)) {\n        if (intrinsics[namePrototype] !== intrinsicPrototype) {\n          throw new TypeError(`Conflicting bindings of ${namePrototype}`);\n        }\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      intrinsics[namePrototype] = intrinsicPrototype;\n    }\n  };\n  freeze(completePrototypes);\n\n  const finalIntrinsics = () => {\n    freeze(intrinsics);\n    pseudoNatives = new WeakSet(arrayFilter(values(intrinsics), isFunction));\n    return intrinsics;\n  };\n  freeze(finalIntrinsics);\n\n  const isPseudoNative = obj => {\n    if (!pseudoNatives) {\n      throw new TypeError(\n        'isPseudoNative can only be called after finalIntrinsics',\n      );\n    }\n    return weaksetHas(pseudoNatives, obj);\n  };\n  freeze(isPseudoNative);\n\n  const intrinsicsCollector = {\n    addIntrinsics,\n    completePrototypes,\n    finalIntrinsics,\n    isPseudoNative,\n  };\n  freeze(intrinsicsCollector);\n\n  addIntrinsics(constantProperties);\n  addIntrinsics(sampleGlobals(globalThis, universalPropertyNames));\n\n  return intrinsicsCollector;\n};\n\n/**\n * getGlobalIntrinsics()\n * Doesn't tame, delete, or modify anything. Samples globalObject to create an\n * intrinsics record containing only the whitelisted global variables, listed\n * by the intrinsic names appropriate for new globals, i.e., the globals of\n * newly constructed compartments.\n *\n * WARNING:\n * If run before lockdown, the returned intrinsics record will carry the\n * *original* unsafe (feral, untamed) bindings of these global variables.\n *\n * @param {Object} globalObject\n */\nexport const getGlobalIntrinsics = globalObject => {\n  const { addIntrinsics, finalIntrinsics } = makeIntrinsicsCollector();\n\n  addIntrinsics(sampleGlobals(globalObject, sharedGlobalPropertyNames));\n\n  return finalIntrinsics();\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}