{"ast":null,"code":"// Compartments need a mechanism to link a module from one compartment\n// to another.\n// The procedure is to use `compartment.module(specifier)` to obtain the module\n// exports namespace from one compartment, possibly before importing or even\n// merely loading module, and threading it into the module map of another\n// compartment.\n// For this to be possible, it is necessary to model the module exports\n// namespace as a proxy that will treat all access to those exported properties\n// as reference errors until the properties of the actual module are known.\n// This provides the mechanism for modeling the public exports proxy\n// and eventually connecting it to to the proxied exports.\nimport { makeAlias } from './module-load.js';\nimport { Proxy, TypeError, create, freeze, mapGet, mapHas, mapSet, ownKeys, reflectGet, reflectGetOwnPropertyDescriptor, reflectHas, reflectIsExtensible, reflectPreventExtensions, weakmapSet } from './commons.js';\nimport { assert } from './error/assert.js';\nconst {\n  quote: q\n} = assert; // `deferExports` creates a module's exports proxy, proxied exports, and\n// activator.\n// A `Compartment` can create a module for any module specifier, regardless of\n// whether it is loadable or executable, and use that object as a token that\n// can be fed into another compartment's module map.\n// Only after the specified module has been analyzed is it possible for the\n// module namespace proxy to behave properly, so it throws exceptions until\n// after the compartment has begun executing the module.\n// The module instance must freeze the proxied exports and activate the exports\n// proxy before executing the module.\n//\n// The module exports proxy's behavior differs from the ECMAScript 262\n// specification for \"module namespace exotic objects\" only in that according\n// to the specification value property descriptors have a non-writable \"value\"\n// and this implementation models all properties with accessors.\n//\n// https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n//\n\nexport const deferExports = () => {\n  let active = false;\n  const proxiedExports = create(null);\n  return freeze({\n    activate() {\n      active = true;\n    },\n\n    proxiedExports,\n    exportsProxy: new Proxy(proxiedExports, {\n      get(_target, name, receiver) {\n        if (!active) {\n          throw new TypeError(`Cannot get property ${q(name)} of module exports namespace, the module has not yet begun to execute`);\n        }\n\n        return reflectGet(proxiedExports, name, receiver);\n      },\n\n      set(_target, name, _value) {\n        throw new TypeError(`Cannot set property ${q(name)} of module exports namespace`);\n      },\n\n      has(_target, name) {\n        if (!active) {\n          throw new TypeError(`Cannot check property ${q(name)}, the module has not yet begun to execute`);\n        }\n\n        return reflectHas(proxiedExports, name);\n      },\n\n      deleteProperty(_target, name) {\n        throw new TypeError(`Cannot delete property ${q(name)}s of module exports namespace`);\n      },\n\n      ownKeys(_target) {\n        if (!active) {\n          throw new TypeError('Cannot enumerate keys, the module has not yet begun to execute');\n        }\n\n        return ownKeys(proxiedExports);\n      },\n\n      getOwnPropertyDescriptor(_target, name) {\n        if (!active) {\n          throw new TypeError(`Cannot get own property descriptor ${q(name)}, the module has not yet begun to execute`);\n        }\n\n        return reflectGetOwnPropertyDescriptor(proxiedExports, name);\n      },\n\n      preventExtensions(_target) {\n        if (!active) {\n          throw new TypeError('Cannot prevent extensions of module exports namespace, the module has not yet begun to execute');\n        }\n\n        return reflectPreventExtensions(proxiedExports);\n      },\n\n      isExtensible() {\n        if (!active) {\n          throw new TypeError('Cannot check extensibility of module exports namespace, the module has not yet begun to execute');\n        }\n\n        return reflectIsExtensible(proxiedExports);\n      },\n\n      getPrototypeOf(_target) {\n        return null;\n      },\n\n      setPrototypeOf(_target, _proto) {\n        throw new TypeError('Cannot set prototype of module exports namespace');\n      },\n\n      defineProperty(_target, name, _descriptor) {\n        throw new TypeError(`Cannot define property ${q(name)} of module exports namespace`);\n      },\n\n      apply(_target, _thisArg, _args) {\n        throw new TypeError('Cannot call module exports namespace, it is not a function');\n      },\n\n      construct(_target, _args) {\n        throw new TypeError('Cannot construct module exports namespace, it is not a constructor');\n      }\n\n    })\n  });\n}; // `getDeferredExports` memoizes the creation of a deferred module exports\n// namespace proxy for any abritrary full specifier in a compartment.\n// It also records the compartment and specifier affiliated with that module\n// exports namespace proxy so it can be used as an alias into another\n// compartment when threaded through a compartment's `moduleMap` argument.\n\nexport const getDeferredExports = (compartment, compartmentPrivateFields, moduleAliases, specifier) => {\n  const {\n    deferredExports\n  } = compartmentPrivateFields;\n\n  if (!mapHas(deferredExports, specifier)) {\n    const deferred = deferExports();\n    weakmapSet(moduleAliases, deferred.exportsProxy, makeAlias(compartment, specifier));\n    mapSet(deferredExports, specifier, deferred);\n  }\n\n  return mapGet(deferredExports, specifier);\n};","map":{"version":3,"names":["makeAlias","Proxy","TypeError","create","freeze","mapGet","mapHas","mapSet","ownKeys","reflectGet","reflectGetOwnPropertyDescriptor","reflectHas","reflectIsExtensible","reflectPreventExtensions","weakmapSet","assert","quote","q","deferExports","active","proxiedExports","activate","exportsProxy","get","_target","name","receiver","set","_value","has","deleteProperty","getOwnPropertyDescriptor","preventExtensions","isExtensible","getPrototypeOf","setPrototypeOf","_proto","defineProperty","_descriptor","apply","_thisArg","_args","construct","getDeferredExports","compartment","compartmentPrivateFields","moduleAliases","specifier","deferredExports","deferred"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/module-proxy.js"],"sourcesContent":["// Compartments need a mechanism to link a module from one compartment\n// to another.\n// The procedure is to use `compartment.module(specifier)` to obtain the module\n// exports namespace from one compartment, possibly before importing or even\n// merely loading module, and threading it into the module map of another\n// compartment.\n// For this to be possible, it is necessary to model the module exports\n// namespace as a proxy that will treat all access to those exported properties\n// as reference errors until the properties of the actual module are known.\n// This provides the mechanism for modeling the public exports proxy\n// and eventually connecting it to to the proxied exports.\n\nimport { makeAlias } from './module-load.js';\nimport {\n  Proxy,\n  TypeError,\n  create,\n  freeze,\n  mapGet,\n  mapHas,\n  mapSet,\n  ownKeys,\n  reflectGet,\n  reflectGetOwnPropertyDescriptor,\n  reflectHas,\n  reflectIsExtensible,\n  reflectPreventExtensions,\n  weakmapSet,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\nconst { quote: q } = assert;\n\n// `deferExports` creates a module's exports proxy, proxied exports, and\n// activator.\n// A `Compartment` can create a module for any module specifier, regardless of\n// whether it is loadable or executable, and use that object as a token that\n// can be fed into another compartment's module map.\n// Only after the specified module has been analyzed is it possible for the\n// module namespace proxy to behave properly, so it throws exceptions until\n// after the compartment has begun executing the module.\n// The module instance must freeze the proxied exports and activate the exports\n// proxy before executing the module.\n//\n// The module exports proxy's behavior differs from the ECMAScript 262\n// specification for \"module namespace exotic objects\" only in that according\n// to the specification value property descriptors have a non-writable \"value\"\n// and this implementation models all properties with accessors.\n//\n// https://tc39.es/ecma262/#sec-module-namespace-exotic-objects\n//\nexport const deferExports = () => {\n  let active = false;\n  const proxiedExports = create(null);\n  return freeze({\n    activate() {\n      active = true;\n    },\n    proxiedExports,\n    exportsProxy: new Proxy(proxiedExports, {\n      get(_target, name, receiver) {\n        if (!active) {\n          throw new TypeError(\n            `Cannot get property ${q(\n              name,\n            )} of module exports namespace, the module has not yet begun to execute`,\n          );\n        }\n        return reflectGet(proxiedExports, name, receiver);\n      },\n      set(_target, name, _value) {\n        throw new TypeError(\n          `Cannot set property ${q(name)} of module exports namespace`,\n        );\n      },\n      has(_target, name) {\n        if (!active) {\n          throw new TypeError(\n            `Cannot check property ${q(\n              name,\n            )}, the module has not yet begun to execute`,\n          );\n        }\n        return reflectHas(proxiedExports, name);\n      },\n      deleteProperty(_target, name) {\n        throw new TypeError(\n          `Cannot delete property ${q(name)}s of module exports namespace`,\n        );\n      },\n      ownKeys(_target) {\n        if (!active) {\n          throw new TypeError(\n            'Cannot enumerate keys, the module has not yet begun to execute',\n          );\n        }\n        return ownKeys(proxiedExports);\n      },\n      getOwnPropertyDescriptor(_target, name) {\n        if (!active) {\n          throw new TypeError(\n            `Cannot get own property descriptor ${q(\n              name,\n            )}, the module has not yet begun to execute`,\n          );\n        }\n        return reflectGetOwnPropertyDescriptor(proxiedExports, name);\n      },\n      preventExtensions(_target) {\n        if (!active) {\n          throw new TypeError(\n            'Cannot prevent extensions of module exports namespace, the module has not yet begun to execute',\n          );\n        }\n        return reflectPreventExtensions(proxiedExports);\n      },\n      isExtensible() {\n        if (!active) {\n          throw new TypeError(\n            'Cannot check extensibility of module exports namespace, the module has not yet begun to execute',\n          );\n        }\n        return reflectIsExtensible(proxiedExports);\n      },\n      getPrototypeOf(_target) {\n        return null;\n      },\n      setPrototypeOf(_target, _proto) {\n        throw new TypeError('Cannot set prototype of module exports namespace');\n      },\n      defineProperty(_target, name, _descriptor) {\n        throw new TypeError(\n          `Cannot define property ${q(name)} of module exports namespace`,\n        );\n      },\n      apply(_target, _thisArg, _args) {\n        throw new TypeError(\n          'Cannot call module exports namespace, it is not a function',\n        );\n      },\n      construct(_target, _args) {\n        throw new TypeError(\n          'Cannot construct module exports namespace, it is not a constructor',\n        );\n      },\n    }),\n  });\n};\n\n// `getDeferredExports` memoizes the creation of a deferred module exports\n// namespace proxy for any abritrary full specifier in a compartment.\n// It also records the compartment and specifier affiliated with that module\n// exports namespace proxy so it can be used as an alias into another\n// compartment when threaded through a compartment's `moduleMap` argument.\nexport const getDeferredExports = (\n  compartment,\n  compartmentPrivateFields,\n  moduleAliases,\n  specifier,\n) => {\n  const { deferredExports } = compartmentPrivateFields;\n  if (!mapHas(deferredExports, specifier)) {\n    const deferred = deferExports();\n    weakmapSet(\n      moduleAliases,\n      deferred.exportsProxy,\n      makeAlias(compartment, specifier),\n    );\n    mapSet(deferredExports, specifier, deferred);\n  }\n  return mapGet(deferredExports, specifier);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}