{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\n// @ts-check\n/// <reference types=\"ses\"/>\nimport { HandledPromise, E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makePromiseKit } from '@endo/promise-kit';\nimport './types.js';\n/**\n * @template T\n * @param {ERef<SubscriptionInternals<T>>} sharableInternalsP\n * @returns {Subscription<T>}\n */\n\nconst makeSubscription = sharableInternalsP => {\n  return Far('Subscription', {\n    // eslint-disable-next-line no-use-before-define\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(sharableInternalsP),\n\n    /**\n     * Use this to distribute a Subscription efficiently over the network,\n     * by obtaining this from the Subscription to be replicated, and applying\n     * `makeSubscription` to it at the new site to get an equivalent local\n     * Subscription at that site.\n     *\n     * @returns {ERef<SubscriptionInternals<T>>}\n     */\n    getSharableSubscriptionInternals: () => sharableInternalsP\n  });\n};\n\nharden(makeSubscription);\nexport { makeSubscription };\n/**\n * @template T\n * @param {ERef<SubscriptionInternals<T>>} tailP\n * @returns {SubscriptionIterator<T>}\n */\n\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    subscribe: () => makeSubscription(tailP),\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(tailP),\n    next: () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    }\n  });\n};\n/**\n * Makes a `{ publication, subscription }` for doing lossless efficient\n * distributed pub/sub.\n *\n * @template T\n * @returns {SubscriptionRecord<T>}\n */\n\n\nconst makeSubscriptionKit = () => {\n  /** @type {((internals: ERef<SubscriptionInternals<T>>) => void) | undefined} */\n  let rear;\n  const hp = new HandledPromise(r => rear = r);\n  const subscription = makeSubscription(hp);\n  /** @type {IterationObserver<T>} */\n\n  const publication = Far('publication', {\n    updateState: value => {\n      if (rear === undefined) {\n        throw new Error('Cannot update state after termination.');\n      }\n\n      const {\n        promise: nextTailE,\n        resolve: nextRear\n      } = makePromiseKit();\n      rear(harden({\n        head: {\n          value,\n          done: false\n        },\n        tail: nextTailE\n      }));\n      rear = nextRear;\n    },\n    finish: finalValue => {\n      if (rear === undefined) {\n        throw new Error('Cannot finish after termination.');\n      }\n\n      const readComplaint = HandledPromise.reject(new Error('cannot read past end of iteration'));\n      readComplaint.catch(_ => {}); // suppress unhandled rejection error\n\n      rear({\n        head: {\n          value: finalValue,\n          done: true\n        },\n        tail: readComplaint\n      });\n      rear = undefined;\n    },\n    fail: reason => {\n      if (rear === undefined) {\n        throw new Error('Cannot fail after termination.');\n      }\n      /** @type {Promise<SubscriptionInternals<T>>} */\n\n\n      const rejection = HandledPromise.reject(reason);\n      rear(rejection);\n      rear = undefined;\n    }\n  });\n  return harden({\n    publication,\n    subscription\n  });\n};\n\nharden(makeSubscriptionKit);\nexport { makeSubscriptionKit };","map":{"version":3,"names":["HandledPromise","E","Far","makePromiseKit","makeSubscription","sharableInternalsP","Symbol","asyncIterator","makeSubscriptionIterator","getSharableSubscriptionInternals","harden","tailP","subscribe","next","resultP","get","head","tail","makeSubscriptionKit","rear","hp","r","subscription","publication","updateState","value","undefined","Error","promise","nextTailE","resolve","nextRear","done","finish","finalValue","readComplaint","reject","catch","_","fail","reason","rejection"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@agoric/notifier/src/subscriber.js"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\n// @ts-check\n/// <reference types=\"ses\"/>\n\nimport { HandledPromise, E } from '@endo/eventual-send';\nimport { Far } from '@endo/marshal';\nimport { makePromiseKit } from '@endo/promise-kit';\n\nimport './types.js';\n\n/**\n * @template T\n * @param {ERef<SubscriptionInternals<T>>} sharableInternalsP\n * @returns {Subscription<T>}\n */\nconst makeSubscription = sharableInternalsP => {\n  return Far('Subscription', {\n    // eslint-disable-next-line no-use-before-define\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(sharableInternalsP),\n\n    /**\n     * Use this to distribute a Subscription efficiently over the network,\n     * by obtaining this from the Subscription to be replicated, and applying\n     * `makeSubscription` to it at the new site to get an equivalent local\n     * Subscription at that site.\n     *\n     * @returns {ERef<SubscriptionInternals<T>>}\n     */\n    getSharableSubscriptionInternals: () => sharableInternalsP,\n  });\n};\nharden(makeSubscription);\nexport { makeSubscription };\n\n/**\n * @template T\n * @param {ERef<SubscriptionInternals<T>>} tailP\n * @returns {SubscriptionIterator<T>}\n */\nconst makeSubscriptionIterator = tailP => {\n  // To understand the implementation, start with\n  // https://web.archive.org/web/20160404122250/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency#infinite_queue\n  return Far('SubscriptionIterator', {\n    subscribe: () => makeSubscription(tailP),\n    [Symbol.asyncIterator]: () => makeSubscriptionIterator(tailP),\n    next: () => {\n      const resultP = E.get(tailP).head;\n      tailP = E.get(tailP).tail;\n      return resultP;\n    },\n  });\n};\n\n/**\n * Makes a `{ publication, subscription }` for doing lossless efficient\n * distributed pub/sub.\n *\n * @template T\n * @returns {SubscriptionRecord<T>}\n */\nconst makeSubscriptionKit = () => {\n  /** @type {((internals: ERef<SubscriptionInternals<T>>) => void) | undefined} */\n  let rear;\n  const hp = new HandledPromise(r => (rear = r));\n  const subscription = makeSubscription(hp);\n\n  /** @type {IterationObserver<T>} */\n  const publication = Far('publication', {\n    updateState: value => {\n      if (rear === undefined) {\n        throw new Error('Cannot update state after termination.');\n      }\n      const { promise: nextTailE, resolve: nextRear } = makePromiseKit();\n      rear(harden({ head: { value, done: false }, tail: nextTailE }));\n      rear = nextRear;\n    },\n    finish: finalValue => {\n      if (rear === undefined) {\n        throw new Error('Cannot finish after termination.');\n      }\n      const readComplaint = HandledPromise.reject(\n        new Error('cannot read past end of iteration'),\n      );\n      readComplaint.catch(_ => {}); // suppress unhandled rejection error\n      rear({ head: { value: finalValue, done: true }, tail: readComplaint });\n      rear = undefined;\n    },\n    fail: reason => {\n      if (rear === undefined) {\n        throw new Error('Cannot fail after termination.');\n      }\n      /** @type {Promise<SubscriptionInternals<T>>} */\n      const rejection = HandledPromise.reject(reason);\n      rear(rejection);\n      rear = undefined;\n    },\n  });\n  return harden({ publication, subscription });\n};\nharden(makeSubscriptionKit);\nexport { makeSubscriptionKit };\n"],"mappings":"AAAA;AACA;AACA;AAEA,SAASA,cAAT,EAAyBC,CAAzB,QAAkC,qBAAlC;AACA,SAASC,GAAT,QAAoB,eAApB;AACA,SAASC,cAAT,QAA+B,mBAA/B;AAEA,OAAO,YAAP;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMC,gBAAgB,GAAGC,kBAAkB,IAAI;EAC7C,OAAOH,GAAG,CAAC,cAAD,EAAiB;IACzB;IACA,CAACI,MAAM,CAACC,aAAR,GAAwB,MAAMC,wBAAwB,CAACH,kBAAD,CAF7B;;IAIzB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;IACII,gCAAgC,EAAE,MAAMJ;EAZf,CAAjB,CAAV;AAcD,CAfD;;AAgBAK,MAAM,CAACN,gBAAD,CAAN;AACA,SAASA,gBAAT;AAEA;AACA;AACA;AACA;AACA;;AACA,MAAMI,wBAAwB,GAAGG,KAAK,IAAI;EACxC;EACA;EACA,OAAOT,GAAG,CAAC,sBAAD,EAAyB;IACjCU,SAAS,EAAE,MAAMR,gBAAgB,CAACO,KAAD,CADA;IAEjC,CAACL,MAAM,CAACC,aAAR,GAAwB,MAAMC,wBAAwB,CAACG,KAAD,CAFrB;IAGjCE,IAAI,EAAE,MAAM;MACV,MAAMC,OAAO,GAAGb,CAAC,CAACc,GAAF,CAAMJ,KAAN,EAAaK,IAA7B;MACAL,KAAK,GAAGV,CAAC,CAACc,GAAF,CAAMJ,KAAN,EAAaM,IAArB;MACA,OAAOH,OAAP;IACD;EAPgC,CAAzB,CAAV;AASD,CAZD;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMI,mBAAmB,GAAG,MAAM;EAChC;EACA,IAAIC,IAAJ;EACA,MAAMC,EAAE,GAAG,IAAIpB,cAAJ,CAAmBqB,CAAC,IAAKF,IAAI,GAAGE,CAAhC,CAAX;EACA,MAAMC,YAAY,GAAGlB,gBAAgB,CAACgB,EAAD,CAArC;EAEA;;EACA,MAAMG,WAAW,GAAGrB,GAAG,CAAC,aAAD,EAAgB;IACrCsB,WAAW,EAAEC,KAAK,IAAI;MACpB,IAAIN,IAAI,KAAKO,SAAb,EAAwB;QACtB,MAAM,IAAIC,KAAJ,CAAU,wCAAV,CAAN;MACD;;MACD,MAAM;QAAEC,OAAO,EAAEC,SAAX;QAAsBC,OAAO,EAAEC;MAA/B,IAA4C5B,cAAc,EAAhE;MACAgB,IAAI,CAACT,MAAM,CAAC;QAAEM,IAAI,EAAE;UAAES,KAAF;UAASO,IAAI,EAAE;QAAf,CAAR;QAAgCf,IAAI,EAAEY;MAAtC,CAAD,CAAP,CAAJ;MACAV,IAAI,GAAGY,QAAP;IACD,CARoC;IASrCE,MAAM,EAAEC,UAAU,IAAI;MACpB,IAAIf,IAAI,KAAKO,SAAb,EAAwB;QACtB,MAAM,IAAIC,KAAJ,CAAU,kCAAV,CAAN;MACD;;MACD,MAAMQ,aAAa,GAAGnC,cAAc,CAACoC,MAAf,CACpB,IAAIT,KAAJ,CAAU,mCAAV,CADoB,CAAtB;MAGAQ,aAAa,CAACE,KAAd,CAAoBC,CAAC,IAAI,CAAE,CAA3B,EAPoB,CAOU;;MAC9BnB,IAAI,CAAC;QAAEH,IAAI,EAAE;UAAES,KAAK,EAAES,UAAT;UAAqBF,IAAI,EAAE;QAA3B,CAAR;QAA2Cf,IAAI,EAAEkB;MAAjD,CAAD,CAAJ;MACAhB,IAAI,GAAGO,SAAP;IACD,CAnBoC;IAoBrCa,IAAI,EAAEC,MAAM,IAAI;MACd,IAAIrB,IAAI,KAAKO,SAAb,EAAwB;QACtB,MAAM,IAAIC,KAAJ,CAAU,gCAAV,CAAN;MACD;MACD;;;MACA,MAAMc,SAAS,GAAGzC,cAAc,CAACoC,MAAf,CAAsBI,MAAtB,CAAlB;MACArB,IAAI,CAACsB,SAAD,CAAJ;MACAtB,IAAI,GAAGO,SAAP;IACD;EA5BoC,CAAhB,CAAvB;EA8BA,OAAOhB,MAAM,CAAC;IAAEa,WAAF;IAAeD;EAAf,CAAD,CAAb;AACD,CAtCD;;AAuCAZ,MAAM,CAACQ,mBAAD,CAAN;AACA,SAASA,mBAAT"},"metadata":{},"sourceType":"module"}