{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\n\n/** @typedef {import('../types.js').Checker} Checker */\n\n/** @typedef {import('../types.js').PassStyle} PassStyle */\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  getOwnPropertyDescriptor,\n  hasOwnProperty: objectHasOwnProperty\n} = Object;\nconst {\n  apply\n} = Reflect;\nconst {\n  isArray\n} = Array;\nexport const hasOwnPropertyOf = (obj, prop) => apply(objectHasOwnProperty, obj, [prop]);\nharden(hasOwnPropertyOf);\nexport const isObject = val => Object(val) === val;\nharden(isObject);\nexport const PASS_STYLE = Symbol.for('passStyle');\n/**\n * For a function to be a valid method, it must not be passable.\n * Otherwise, we risk confusing pass-by-copy data carrying\n * far functions with attempts at far objects with methods.\n *\n * TODO HAZARD Because we check this on the way to hardening a remotable,\n * we cannot yet check that `func` is hardened. However, without\n * doing so, it's inheritance might change after the `PASS_STYLE`\n * check below.\n *\n * @param {any} func\n * @returns {boolean}\n */\n\nexport const canBeMethod = func => typeof func === 'function' && !(PASS_STYLE in func);\nharden(canBeMethod);\n/**\n * Below we have a series of predicate functions and their (curried) assertion\n * functions. The semantics of the assertion function is just to assert that\n * the corresponding predicate function would have returned true. But it\n * reproduces the internal tests so failures can give a better error message.\n *\n * @type {Checker}\n */\n\nexport const assertChecker = (cond, details) => {\n  assert(cond, details);\n  return true;\n};\nharden(assertChecker);\n/**\n * @param {Object} candidate\n * @param {string|number|symbol} propertyName\n * @param {string=} nameType\n * @param {boolean=} shouldBeEnumerable\n * @param {Checker=} check\n * @returns {boolean}\n */\n\nexport const checkNormalProperty = function (candidate, propertyName) {\n  let nameType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let shouldBeEnumerable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  let check = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : x => x;\n  const desc = getOwnPropertyDescriptor(candidate, propertyName);\n\n  if (desc === undefined) {\n    return check(false, X`${q(propertyName)} property expected: ${candidate}`);\n  }\n\n  return check( // eslint-disable-next-line valid-typeof\n  nameType === undefined || typeof propertyName === nameType, X`${q(propertyName)} must be a ${q(nameType)}-named property: ${candidate}`) && check(hasOwnPropertyOf(desc, 'value'), X`${q(propertyName)} must not be an accessor property: ${candidate}`) && (shouldBeEnumerable ? check(!!desc.enumerable, X`${q(propertyName)} must be an enumerable property: ${candidate}`) : check(!desc.enumerable, X`${q(propertyName)} must not be an enumerable property: ${candidate}`));\n};\nharden(checkNormalProperty);\nexport const getTag = tagRecord => tagRecord[Symbol.toStringTag];\nharden(getTag);\n/**\n * @param {{ [PASS_STYLE]: string }} tagRecord\n * @param {PassStyle} passStyle\n * @param {Checker} [check]\n * @returns {boolean}\n */\n\nexport const checkTagRecord = function (tagRecord, passStyle) {\n  let check = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x => x;\n  return check(typeof tagRecord === 'object', X`A non-object cannot be a tagRecord: ${tagRecord}`) && check(!isArray(tagRecord), X`An array cannot be a tagRecords: ${tagRecord}`) && check(tagRecord !== null, X`null cannot be a tagRecord`) && checkNormalProperty(tagRecord, PASS_STYLE, 'symbol', false, check) && check(tagRecord[PASS_STYLE] === passStyle, X`Expected ${q(passStyle)}, not ${q(tagRecord[PASS_STYLE])}: ${tagRecord}`) && checkNormalProperty(tagRecord, Symbol.toStringTag, 'symbol', false, check) && check(typeof getTag(tagRecord) === 'string', X`A [Symbol.toString]-named property must be a string: ${tagRecord}`);\n};\nharden(checkTagRecord);","map":{"version":3,"names":["details","X","quote","q","assert","getOwnPropertyDescriptor","hasOwnProperty","objectHasOwnProperty","Object","apply","Reflect","isArray","Array","hasOwnPropertyOf","obj","prop","harden","isObject","val","PASS_STYLE","Symbol","for","canBeMethod","func","assertChecker","cond","checkNormalProperty","candidate","propertyName","nameType","undefined","shouldBeEnumerable","check","x","desc","enumerable","getTag","tagRecord","toStringTag","checkTagRecord","passStyle"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/helpers/passStyle-helpers.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\n/** @typedef {import('../types.js').Checker} Checker */\n/** @typedef {import('../types.js').PassStyle} PassStyle */\n\nconst { details: X, quote: q } = assert;\nconst {\n  getOwnPropertyDescriptor,\n  hasOwnProperty: objectHasOwnProperty,\n} = Object;\nconst { apply } = Reflect;\nconst { isArray } = Array;\n\nexport const hasOwnPropertyOf = (obj, prop) =>\n  apply(objectHasOwnProperty, obj, [prop]);\nharden(hasOwnPropertyOf);\n\nexport const isObject = val => Object(val) === val;\nharden(isObject);\n\nexport const PASS_STYLE = Symbol.for('passStyle');\n\n/**\n * For a function to be a valid method, it must not be passable.\n * Otherwise, we risk confusing pass-by-copy data carrying\n * far functions with attempts at far objects with methods.\n *\n * TODO HAZARD Because we check this on the way to hardening a remotable,\n * we cannot yet check that `func` is hardened. However, without\n * doing so, it's inheritance might change after the `PASS_STYLE`\n * check below.\n *\n * @param {any} func\n * @returns {boolean}\n */\nexport const canBeMethod = func =>\n  typeof func === 'function' && !(PASS_STYLE in func);\nharden(canBeMethod);\n\n/**\n * Below we have a series of predicate functions and their (curried) assertion\n * functions. The semantics of the assertion function is just to assert that\n * the corresponding predicate function would have returned true. But it\n * reproduces the internal tests so failures can give a better error message.\n *\n * @type {Checker}\n */\nexport const assertChecker = (cond, details) => {\n  assert(cond, details);\n  return true;\n};\nharden(assertChecker);\n\n/**\n * @param {Object} candidate\n * @param {string|number|symbol} propertyName\n * @param {string=} nameType\n * @param {boolean=} shouldBeEnumerable\n * @param {Checker=} check\n * @returns {boolean}\n */\nexport const checkNormalProperty = (\n  candidate,\n  propertyName,\n  nameType = undefined,\n  shouldBeEnumerable = true,\n  check = x => x,\n) => {\n  const desc = getOwnPropertyDescriptor(candidate, propertyName);\n  if (desc === undefined) {\n    return check(false, X`${q(propertyName)} property expected: ${candidate}`);\n  }\n  return (\n    check(\n      // eslint-disable-next-line valid-typeof\n      nameType === undefined || typeof propertyName === nameType,\n      X`${q(propertyName)} must be a ${q(\n        nameType,\n      )}-named property: ${candidate}`,\n    ) &&\n    check(\n      hasOwnPropertyOf(desc, 'value'),\n      X`${q(propertyName)} must not be an accessor property: ${candidate}`,\n    ) &&\n    (shouldBeEnumerable\n      ? check(\n          !!desc.enumerable,\n          X`${q(propertyName)} must be an enumerable property: ${candidate}`,\n        )\n      : check(\n          !desc.enumerable,\n          X`${q(\n            propertyName,\n          )} must not be an enumerable property: ${candidate}`,\n        ))\n  );\n};\nharden(checkNormalProperty);\n\nexport const getTag = tagRecord => tagRecord[Symbol.toStringTag];\nharden(getTag);\n\n/**\n * @param {{ [PASS_STYLE]: string }} tagRecord\n * @param {PassStyle} passStyle\n * @param {Checker} [check]\n * @returns {boolean}\n */\nexport const checkTagRecord = (tagRecord, passStyle, check = x => x) => {\n  return (\n    check(\n      typeof tagRecord === 'object',\n      X`A non-object cannot be a tagRecord: ${tagRecord}`,\n    ) &&\n    check(\n      !isArray(tagRecord),\n      X`An array cannot be a tagRecords: ${tagRecord}`,\n    ) &&\n    check(tagRecord !== null, X`null cannot be a tagRecord`) &&\n    checkNormalProperty(tagRecord, PASS_STYLE, 'symbol', false, check) &&\n    check(\n      tagRecord[PASS_STYLE] === passStyle,\n      X`Expected ${q(passStyle)}, not ${q(\n        tagRecord[PASS_STYLE],\n      )}: ${tagRecord}`,\n    ) &&\n    checkNormalProperty(\n      tagRecord,\n      Symbol.toStringTag,\n      'symbol',\n      false,\n      check,\n    ) &&\n    check(\n      typeof getTag(tagRecord) === 'string',\n      X`A [Symbol.toString]-named property must be a string: ${tagRecord}`,\n    )\n  );\n};\nharden(checkTagRecord);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}