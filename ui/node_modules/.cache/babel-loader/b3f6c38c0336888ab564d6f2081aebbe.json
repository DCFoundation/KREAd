{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\" />\nimport { trackTurns } from './track-turns.js';\nimport { localApplyFunction, localApplyMethod, localGet, sortedOwnKeys } from './local.js';\nimport { makePostponedHandler } from './postponed.js';\nconst {\n  details: X,\n  quote: q\n} = assert;\n/**\n * @template T\n * @typedef {import('.').EHandler<T>} EHandler\n */\n\n/** @typedef {import('.').HandledPromiseConstructor} HandledPromiseConstructor */\n\nconst {\n  create,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  defineProperties,\n  getPrototypeOf,\n  setPrototypeOf,\n  isFrozen\n} = Object;\nconst {\n  apply,\n  construct\n} = Reflect;\nconst SEND_ONLY_RE = /^(.*)SendOnly$/;\n/**\n * Coerce to an object property (string or symbol).\n *\n * @param {any} specimen\n * @returns {string | symbol}\n */\n\nconst coerceToObjectProperty = specimen => {\n  if (typeof specimen === 'symbol') {\n    return specimen;\n  }\n\n  return String(specimen);\n}; // the following method (makeHandledPromise) is part\n// of the shim, and will not be exported by the module once the feature\n// becomes a part of standard javascript\n\n/**\n * Create a HandledPromise class to have it support eventual send\n * (wavy-dot) operations.\n *\n * Based heavily on nanoq\n * https://github.com/drses/nanoq/blob/master/src/nanoq.js\n *\n * Original spec for the infix-bang (predecessor to wavy-dot) desugaring:\n * https://web.archive.org/web/20161026162206/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency\n *\n * @returns {HandledPromiseConstructor} Handled promise\n */\n\n\nexport const makeHandledPromise = () => {\n  const presenceToHandler = new WeakMap();\n  /** @type {WeakMap<any, any>} */\n\n  const presenceToPromise = new WeakMap();\n  const promiseToPendingHandler = new WeakMap();\n  const promiseToPresence = new WeakMap();\n  const forwardedPromiseToPromise = new WeakMap(); // forwarding, union-find-ish\n\n  /**\n   * You can imagine a forest of trees in which the roots of each tree is an\n   * unresolved HandledPromise or a non-Promise, and each node's parent is the\n   * HandledPromise to which it was forwarded.  We maintain that mapping of\n   * forwarded HandledPromise to its resolution in forwardedPromiseToPromise.\n   *\n   * We use something like the description of \"Find\" with \"Path splitting\"\n   * to propagate changes down to the children efficiently:\n   * https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n   *\n   * @param {*} target Any value.\n   * @returns {*} If the target was a HandledPromise, the most-resolved parent\n   * of it, otherwise the target.\n   */\n\n  const shorten = target => {\n    let p = target; // Find the most-resolved value for p.\n\n    while (forwardedPromiseToPromise.has(p)) {\n      p = forwardedPromiseToPromise.get(p);\n    }\n\n    const presence = promiseToPresence.get(p);\n\n    if (presence) {\n      // Presences are final, so it is ok to propagate\n      // this upstream.\n      while (target !== p) {\n        const parent = forwardedPromiseToPromise.get(target);\n        forwardedPromiseToPromise.delete(target);\n        promiseToPendingHandler.delete(target);\n        promiseToPresence.set(target, presence);\n        target = parent;\n      }\n    } else {\n      // We propagate p and remove all other pending handlers\n      // upstream.\n      // Note that everything except presences is covered here.\n      while (target !== p) {\n        const parent = forwardedPromiseToPromise.get(target);\n        forwardedPromiseToPromise.set(target, p);\n        promiseToPendingHandler.delete(target);\n        target = parent;\n      }\n    }\n\n    return target;\n  };\n  /**\n   * This special handler accepts Promises, and forwards\n   * handled Promises to their corresponding fulfilledHandler.\n   *\n   * @type {Required<EHandler<any>>}\n   */\n\n\n  let forwardingHandler;\n  let handle;\n  /**\n   * @param {string} handlerName\n   * @param {EHandler<any>} handler\n   * @param {string} operation\n   * @param {any} o\n   * @param {any[]} opArgs\n   * @param {Promise<unknown>} [returnedP]\n   * @returns {any}\n   */\n\n  const dispatchToHandler = (handlerName, handler, operation, o, opArgs, returnedP) => {\n    let actualOp = operation;\n    const matchSendOnly = SEND_ONLY_RE.exec(actualOp);\n\n    const makeResult = result => matchSendOnly ? undefined : result;\n\n    if (matchSendOnly) {\n      // We don't specify the resulting promise if it is sendonly.\n      returnedP = undefined;\n    }\n\n    if (matchSendOnly && typeof handler[actualOp] !== 'function') {\n      // Substitute for sendonly with the corresponding non-sendonly operation.\n      actualOp = matchSendOnly[1];\n    } // Fast path: just call the actual operation.\n\n\n    const hfn = handler[actualOp];\n\n    if (typeof hfn === 'function') {\n      const result = apply(hfn, handler, [o, ...opArgs, returnedP]);\n      return makeResult(result);\n    }\n\n    if (actualOp === 'applyMethod') {\n      // Compose a missing applyMethod by get followed by applyFunction.\n      const [prop, args] = opArgs;\n      const getResultP = handle(o, 'get', // The argument to 'get' is a string or symbol.\n      [coerceToObjectProperty(prop)], undefined);\n      return makeResult(handle(getResultP, 'applyFunction', [args], returnedP));\n    } // BASE CASE: applyFunction bottoms out into applyMethod, if it exists.\n\n\n    if (actualOp === 'applyFunction') {\n      const amfn = handler.applyMethod;\n\n      if (typeof amfn === 'function') {\n        // Downlevel a missing applyFunction to applyMethod with undefined name.\n        const [args] = opArgs;\n        const result = apply(amfn, handler, [o, undefined, [args], returnedP]);\n        return makeResult(result);\n      }\n    }\n\n    assert.fail(X`${q(handlerName)} is defined but has no methods needed for ${q(operation)} (has ${q(sortedOwnKeys(handler))})`, TypeError);\n  };\n  /** @type {HandledPromiseConstructor} */\n\n\n  let HandledPromise;\n  /**\n   * This *needs* to be a `function X` so that we can use it as a constructor.\n   *\n   * @template R\n   * @param {import('.').HandledExecutor<R>} executor\n   * @param {EHandler<Promise<R>>} [pendingHandler]\n   * @returns {Promise<R>}\n   */\n\n  function baseHandledPromise(executor) {\n    let pendingHandler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    assert(new.target, X`must be invoked with \"new\"`);\n    let handledResolve;\n    let handledReject;\n    let resolved = false;\n    let resolvedTarget = null;\n    let handledP;\n\n    let continueForwarding = () => {};\n\n    const superExecutor = (superResolve, superReject) => {\n      handledResolve = value => {\n        if (resolved) {\n          return;\n        }\n\n        assert(!forwardedPromiseToPromise.has(handledP), X`internal: already forwarded`, TypeError);\n        value = shorten(value);\n        let targetP;\n\n        if (promiseToPendingHandler.has(value) || promiseToPresence.has(value)) {\n          targetP = value;\n        } else {\n          // We're resolving to a non-promise, so remove our handler.\n          promiseToPendingHandler.delete(handledP);\n          targetP = presenceToPromise.get(value);\n        } // Ensure our data structure is a proper tree (avoid cycles).\n\n\n        if (targetP && targetP !== handledP) {\n          forwardedPromiseToPromise.set(handledP, targetP);\n        } else {\n          forwardedPromiseToPromise.delete(handledP);\n        } // Remove stale pending handlers, set to canonical form.\n\n\n        shorten(handledP); // Ensure our pendingHandler is cleaned up if not already.\n\n        if (promiseToPendingHandler.has(handledP)) {\n          handledP.then(_ => promiseToPendingHandler.delete(handledP));\n        } // Finish the resolution.\n\n\n        superResolve(value);\n        resolved = true;\n        resolvedTarget = value; // We're resolved, so forward any postponed operations to us.\n\n        continueForwarding();\n      };\n\n      handledReject = err => {\n        if (resolved) {\n          return;\n        }\n\n        assert(!forwardedPromiseToPromise.has(handledP), X`internal: already forwarded`, TypeError);\n        promiseToPendingHandler.delete(handledP);\n        resolved = true;\n        superReject(err);\n        continueForwarding();\n      };\n    };\n\n    handledP = harden(construct(Promise, [superExecutor], new.target));\n\n    if (!pendingHandler) {\n      // This is insufficient for actual remote handled Promises\n      // (too many round-trips), but is an easy way to create a\n      // local handled Promise.\n      [pendingHandler, continueForwarding] = makePostponedHandler(HandledPromise);\n    }\n\n    const validateHandler = h => {\n      assert(Object(h) === h, X`Handler ${h} cannot be a primitive`, TypeError);\n    };\n\n    validateHandler(pendingHandler); // Until the handled promise is resolved, we use the pendingHandler.\n\n    promiseToPendingHandler.set(handledP, pendingHandler);\n\n    const rejectHandled = reason => {\n      if (resolved) {\n        return;\n      }\n\n      assert(!forwardedPromiseToPromise.has(handledP), X`internal: already forwarded`, TypeError);\n      handledReject(reason);\n    };\n\n    const resolveWithPresence = function (presenceHandler) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (resolved) {\n        return resolvedTarget;\n      }\n\n      assert(!forwardedPromiseToPromise.has(handledP), X`internal: already forwarded`, TypeError);\n\n      try {\n        // Sanity checks.\n        validateHandler(presenceHandler);\n        const {\n          proxy: proxyOpts\n        } = options;\n        let presence;\n\n        if (proxyOpts) {\n          const {\n            handler: proxyHandler,\n            target: proxyTarget,\n            revokerCallback\n          } = proxyOpts;\n\n          if (revokerCallback) {\n            // Create a proxy and its revoke function.\n            const {\n              proxy,\n              revoke\n            } = Proxy.revocable(proxyTarget, proxyHandler);\n            presence = proxy;\n            revokerCallback(revoke);\n          } else {\n            presence = new Proxy(proxyTarget, proxyHandler);\n          }\n        } else {\n          // Default presence.\n          presence = create(null);\n        } // Validate and install our mapped target (i.e. presence).\n\n\n        resolvedTarget = presence; // Create table entries for the presence mapped to the\n        // fulfilledHandler.\n\n        presenceToPromise.set(resolvedTarget, handledP);\n        promiseToPresence.set(handledP, resolvedTarget);\n        presenceToHandler.set(resolvedTarget, presenceHandler); // We committed to this presence, so resolve.\n\n        handledResolve(resolvedTarget);\n        return resolvedTarget;\n      } catch (e) {\n        assert.note(e, X`during resolveWithPresence`);\n        handledReject(e);\n        throw e;\n      }\n    };\n\n    const resolveHandled = target => {\n      if (resolved) {\n        return;\n      }\n\n      assert(!forwardedPromiseToPromise.has(handledP), X`internal: already forwarded`, TypeError);\n\n      try {\n        // Resolve the target.\n        handledResolve(target);\n      } catch (e) {\n        handledReject(e);\n      }\n    }; // Invoke the callback to let the user resolve/reject.\n\n\n    executor(resolveHandled, rejectHandled, resolveWithPresence);\n    return handledP;\n  }\n\n  const isFrozenPromiseThen = p => {\n    return isFrozen(p) && getPrototypeOf(p) === Promise.prototype && Promise.resolve(p) === p && getOwnPropertyDescriptor(p, 'then') === undefined;\n  };\n  /** @type {import('.').HandledPromiseStaticMethods & Pick<PromiseConstructor, 'resolve'>} */\n\n\n  const staticMethods = {\n    get(target, prop) {\n      prop = coerceToObjectProperty(prop);\n      return handle(target, 'get', [prop]);\n    },\n\n    getSendOnly(target, prop) {\n      prop = coerceToObjectProperty(prop);\n      handle(target, 'getSendOnly', [prop]);\n    },\n\n    applyFunction(target, args) {\n      // Ensure args is an array.\n      args = [...args];\n      return handle(target, 'applyFunction', [args]);\n    },\n\n    applyFunctionSendOnly(target, args) {\n      // Ensure args is an array.\n      args = [...args];\n      handle(target, 'applyFunctionSendOnly', [args]);\n    },\n\n    applyMethod(target, prop, args) {\n      prop = coerceToObjectProperty(prop); // Ensure args is an array.\n\n      args = [...args];\n      return handle(target, 'applyMethod', [prop, args]);\n    },\n\n    applyMethodSendOnly(target, prop, args) {\n      prop = coerceToObjectProperty(prop); // Ensure args is an array.\n\n      args = [...args];\n      handle(target, 'applyMethodSendOnly', [prop, args]);\n    },\n\n    resolve(value) {\n      // Resolving a Presence returns the pre-registered handled promise.\n      let resolvedPromise = presenceToPromise.get(\n      /** @type {any} */\n      value);\n\n      if (!resolvedPromise) {\n        resolvedPromise = Promise.resolve(value);\n      } // Prevent any proxy trickery.\n\n\n      harden(resolvedPromise);\n\n      if (isFrozenPromiseThen(resolvedPromise)) {\n        // We can use the `resolvedPromise` directly, since it is guaranteed to\n        // have a `then` which is actually `Promise.prototype.then`.\n        return resolvedPromise;\n      } // Assimilate the `resolvedPromise` as an actual frozen Promise, by\n      // treating `resolvedPromise` as if it is a non-promise thenable.\n\n\n      const executeThen = (resolve, reject) => resolvedPromise.then(resolve, reject);\n\n      return harden(Promise.resolve().then(_ => new HandledPromise(executeThen)));\n    }\n\n  };\n\n  const makeForwarder = (operation, localImpl) => {\n    return function (o) {\n      // We are in another turn already, and have the naked object.\n      const presenceHandler = presenceToHandler.get(o);\n\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (!presenceHandler) {\n        return localImpl(o, ...args);\n      }\n\n      return dispatchToHandler('presenceHandler', presenceHandler, operation, o, args);\n    };\n  }; // eslint-disable-next-line prefer-const\n\n\n  forwardingHandler = {\n    get: makeForwarder('get', localGet),\n    getSendOnly: makeForwarder('getSendOnly', localGet),\n    applyFunction: makeForwarder('applyFunction', localApplyFunction),\n    applyFunctionSendOnly: makeForwarder('applyFunctionSendOnly', localApplyFunction),\n    applyMethod: makeForwarder('applyMethod', localApplyMethod),\n    applyMethodSendOnly: makeForwarder('applyMethodSendOnly', localApplyMethod)\n  };\n\n  handle = function () {\n    for (var _len2 = arguments.length, handleArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      handleArgs[_key2] = arguments[_key2];\n    }\n\n    // We're in SES mode, so we should harden.\n    harden(handleArgs);\n    const [_p, operation, opArgs, ...dispatchArgs] = handleArgs;\n    let [p] = handleArgs;\n\n    const doDispatch = (handlerName, handler, o) => dispatchToHandler(handlerName, handler, operation, o, opArgs, // eslint-disable-next-line no-use-before-define\n    ...(dispatchArgs.length === 0 ? [returnedP] : dispatchArgs));\n\n    const [trackedDoDispatch] = trackTurns([doDispatch]);\n    const returnedP = new HandledPromise((resolve, reject) => {\n      // We run in a future turn to prevent synchronous attacks,\n      let raceIsOver = false;\n\n      const win = (handlerName, handler, o) => {\n        if (raceIsOver) {\n          return;\n        }\n\n        try {\n          resolve(trackedDoDispatch(handlerName, handler, o));\n        } catch (reason) {\n          reject(reason);\n        }\n\n        raceIsOver = true;\n      };\n\n      const lose = e => {\n        if (raceIsOver) {\n          return;\n        }\n\n        reject(e);\n        raceIsOver = true;\n      }; // This contestant tries to win with the target's resolution.\n\n\n      staticMethods.resolve(p).then(o => win('forwardingHandler', forwardingHandler, o)).catch(lose); // This contestant sleeps a turn, but then tries to win immediately.\n\n      staticMethods.resolve().then(() => {\n        p = shorten(p);\n        const pendingHandler = promiseToPendingHandler.get(p);\n\n        if (pendingHandler) {\n          // resolve to the answer from the specific pending handler,\n          win('pendingHandler', pendingHandler, p);\n        } else if (!p || typeof p.then !== 'function') {\n          // Not a Thenable, so use it.\n          win('forwardingHandler', forwardingHandler, p);\n        } else if (promiseToPresence.has(p)) {\n          // We have the object synchronously, so resolve with it.\n          const o = promiseToPresence.get(p);\n          win('forwardingHandler', forwardingHandler, o);\n        } // If we made it here without winning, then we will wait\n        // for the other contestant to win instead.\n\n      }).catch(lose);\n    }); // Harden the fulfillment and rejection, as well as a workaround for\n    // Node.js: silence \"Unhandled Rejection\" by default when using the static\n    // methods.\n\n    returnedP.then(harden, harden); // We return a handled promise with the default pending handler.  This\n    // prevents a race between the above Promise.resolves and pipelining.\n\n    return harden(returnedP);\n  }; // Add everything needed on the constructor.\n\n\n  baseHandledPromise.prototype = Promise.prototype;\n  setPrototypeOf(baseHandledPromise, Promise);\n  defineProperties(baseHandledPromise, getOwnPropertyDescriptors(staticMethods)); // FIXME: This is really ugly to bypass the type system, but it will be better\n  // once we use Promise.delegated and don't have any [[Constructor]] behaviours.\n\n  /** @type {unknown} */\n\n  const unknownBaseHandledPromise = baseHandledPromise;\n  HandledPromise =\n  /** @type {typeof HandledPromise} */\n  unknownBaseHandledPromise; // We cannot harden(HandledPromise) because we're a vetted shim which\n  // runs before lockdown() allows harden to function.  In that case,\n  // though, globalThis.HandledPromise will be hardened after lockdown.\n\n  return HandledPromise;\n};","map":{"version":3,"names":["trackTurns","localApplyFunction","localApplyMethod","localGet","sortedOwnKeys","makePostponedHandler","details","X","quote","q","assert","create","getOwnPropertyDescriptor","getOwnPropertyDescriptors","defineProperties","getPrototypeOf","setPrototypeOf","isFrozen","Object","apply","construct","Reflect","SEND_ONLY_RE","coerceToObjectProperty","specimen","String","makeHandledPromise","presenceToHandler","WeakMap","presenceToPromise","promiseToPendingHandler","promiseToPresence","forwardedPromiseToPromise","shorten","target","p","has","get","presence","parent","delete","set","forwardingHandler","handle","dispatchToHandler","handlerName","handler","operation","o","opArgs","returnedP","actualOp","matchSendOnly","exec","makeResult","result","undefined","hfn","prop","args","getResultP","amfn","applyMethod","fail","TypeError","HandledPromise","baseHandledPromise","executor","pendingHandler","new","handledResolve","handledReject","resolved","resolvedTarget","handledP","continueForwarding","superExecutor","superResolve","superReject","value","targetP","then","_","err","harden","Promise","validateHandler","h","rejectHandled","reason","resolveWithPresence","presenceHandler","options","proxy","proxyOpts","proxyHandler","proxyTarget","revokerCallback","revoke","Proxy","revocable","e","note","resolveHandled","isFrozenPromiseThen","prototype","resolve","staticMethods","getSendOnly","applyFunction","applyFunctionSendOnly","applyMethodSendOnly","resolvedPromise","executeThen","reject","makeForwarder","localImpl","handleArgs","_p","dispatchArgs","doDispatch","length","trackedDoDispatch","raceIsOver","win","lose","catch","unknownBaseHandledPromise"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/eventual-send/src/handled-promise.js"],"sourcesContent":["// @ts-check\n/// <reference types=\"ses\" />\nimport { trackTurns } from './track-turns.js';\nimport {\n  localApplyFunction,\n  localApplyMethod,\n  localGet,\n  sortedOwnKeys,\n} from './local.js';\nimport { makePostponedHandler } from './postponed.js';\n\nconst { details: X, quote: q } = assert;\n\n/**\n * @template T\n * @typedef {import('.').EHandler<T>} EHandler\n */\n\n/** @typedef {import('.').HandledPromiseConstructor} HandledPromiseConstructor */\n\nconst {\n  create,\n  getOwnPropertyDescriptor,\n  getOwnPropertyDescriptors,\n  defineProperties,\n  getPrototypeOf,\n  setPrototypeOf,\n  isFrozen,\n} = Object;\n\nconst { apply, construct } = Reflect;\n\nconst SEND_ONLY_RE = /^(.*)SendOnly$/;\n\n/**\n * Coerce to an object property (string or symbol).\n *\n * @param {any} specimen\n * @returns {string | symbol}\n */\nconst coerceToObjectProperty = specimen => {\n  if (typeof specimen === 'symbol') {\n    return specimen;\n  }\n  return String(specimen);\n};\n\n// the following method (makeHandledPromise) is part\n// of the shim, and will not be exported by the module once the feature\n// becomes a part of standard javascript\n\n/**\n * Create a HandledPromise class to have it support eventual send\n * (wavy-dot) operations.\n *\n * Based heavily on nanoq\n * https://github.com/drses/nanoq/blob/master/src/nanoq.js\n *\n * Original spec for the infix-bang (predecessor to wavy-dot) desugaring:\n * https://web.archive.org/web/20161026162206/http://wiki.ecmascript.org/doku.php?id=strawman:concurrency\n *\n * @returns {HandledPromiseConstructor} Handled promise\n */\nexport const makeHandledPromise = () => {\n  const presenceToHandler = new WeakMap();\n  /** @type {WeakMap<any, any>} */\n  const presenceToPromise = new WeakMap();\n  const promiseToPendingHandler = new WeakMap();\n  const promiseToPresence = new WeakMap();\n  const forwardedPromiseToPromise = new WeakMap(); // forwarding, union-find-ish\n\n  /**\n   * You can imagine a forest of trees in which the roots of each tree is an\n   * unresolved HandledPromise or a non-Promise, and each node's parent is the\n   * HandledPromise to which it was forwarded.  We maintain that mapping of\n   * forwarded HandledPromise to its resolution in forwardedPromiseToPromise.\n   *\n   * We use something like the description of \"Find\" with \"Path splitting\"\n   * to propagate changes down to the children efficiently:\n   * https://en.wikipedia.org/wiki/Disjoint-set_data_structure\n   *\n   * @param {*} target Any value.\n   * @returns {*} If the target was a HandledPromise, the most-resolved parent\n   * of it, otherwise the target.\n   */\n  const shorten = target => {\n    let p = target;\n    // Find the most-resolved value for p.\n    while (forwardedPromiseToPromise.has(p)) {\n      p = forwardedPromiseToPromise.get(p);\n    }\n    const presence = promiseToPresence.get(p);\n    if (presence) {\n      // Presences are final, so it is ok to propagate\n      // this upstream.\n      while (target !== p) {\n        const parent = forwardedPromiseToPromise.get(target);\n        forwardedPromiseToPromise.delete(target);\n        promiseToPendingHandler.delete(target);\n        promiseToPresence.set(target, presence);\n        target = parent;\n      }\n    } else {\n      // We propagate p and remove all other pending handlers\n      // upstream.\n      // Note that everything except presences is covered here.\n      while (target !== p) {\n        const parent = forwardedPromiseToPromise.get(target);\n        forwardedPromiseToPromise.set(target, p);\n        promiseToPendingHandler.delete(target);\n        target = parent;\n      }\n    }\n    return target;\n  };\n\n  /**\n   * This special handler accepts Promises, and forwards\n   * handled Promises to their corresponding fulfilledHandler.\n   *\n   * @type {Required<EHandler<any>>}\n   */\n  let forwardingHandler;\n  let handle;\n\n  /**\n   * @param {string} handlerName\n   * @param {EHandler<any>} handler\n   * @param {string} operation\n   * @param {any} o\n   * @param {any[]} opArgs\n   * @param {Promise<unknown>} [returnedP]\n   * @returns {any}\n   */\n  const dispatchToHandler = (\n    handlerName,\n    handler,\n    operation,\n    o,\n    opArgs,\n    returnedP,\n  ) => {\n    let actualOp = operation;\n\n    const matchSendOnly = SEND_ONLY_RE.exec(actualOp);\n\n    const makeResult = result => (matchSendOnly ? undefined : result);\n\n    if (matchSendOnly) {\n      // We don't specify the resulting promise if it is sendonly.\n      returnedP = undefined;\n    }\n\n    if (matchSendOnly && typeof handler[actualOp] !== 'function') {\n      // Substitute for sendonly with the corresponding non-sendonly operation.\n      actualOp = matchSendOnly[1];\n    }\n\n    // Fast path: just call the actual operation.\n    const hfn = handler[actualOp];\n    if (typeof hfn === 'function') {\n      const result = apply(hfn, handler, [o, ...opArgs, returnedP]);\n      return makeResult(result);\n    }\n\n    if (actualOp === 'applyMethod') {\n      // Compose a missing applyMethod by get followed by applyFunction.\n      const [prop, args] = opArgs;\n      const getResultP = handle(\n        o,\n        'get',\n        // The argument to 'get' is a string or symbol.\n        [coerceToObjectProperty(prop)],\n        undefined,\n      );\n      return makeResult(handle(getResultP, 'applyFunction', [args], returnedP));\n    }\n\n    // BASE CASE: applyFunction bottoms out into applyMethod, if it exists.\n    if (actualOp === 'applyFunction') {\n      const amfn = handler.applyMethod;\n      if (typeof amfn === 'function') {\n        // Downlevel a missing applyFunction to applyMethod with undefined name.\n        const [args] = opArgs;\n        const result = apply(amfn, handler, [o, undefined, [args], returnedP]);\n        return makeResult(result);\n      }\n    }\n\n    assert.fail(\n      X`${q(handlerName)} is defined but has no methods needed for ${q(\n        operation,\n      )} (has ${q(sortedOwnKeys(handler))})`,\n      TypeError,\n    );\n  };\n\n  /** @type {HandledPromiseConstructor} */\n  let HandledPromise;\n\n  /**\n   * This *needs* to be a `function X` so that we can use it as a constructor.\n   *\n   * @template R\n   * @param {import('.').HandledExecutor<R>} executor\n   * @param {EHandler<Promise<R>>} [pendingHandler]\n   * @returns {Promise<R>}\n   */\n  function baseHandledPromise(executor, pendingHandler = undefined) {\n    assert(new.target, X`must be invoked with \"new\"`);\n    let handledResolve;\n    let handledReject;\n    let resolved = false;\n    let resolvedTarget = null;\n    let handledP;\n    let continueForwarding = () => {};\n    const superExecutor = (superResolve, superReject) => {\n      handledResolve = value => {\n        if (resolved) {\n          return;\n        }\n        assert(\n          !forwardedPromiseToPromise.has(handledP),\n          X`internal: already forwarded`,\n          TypeError,\n        );\n        value = shorten(value);\n        let targetP;\n        if (\n          promiseToPendingHandler.has(value) ||\n          promiseToPresence.has(value)\n        ) {\n          targetP = value;\n        } else {\n          // We're resolving to a non-promise, so remove our handler.\n          promiseToPendingHandler.delete(handledP);\n          targetP = presenceToPromise.get(value);\n        }\n        // Ensure our data structure is a proper tree (avoid cycles).\n        if (targetP && targetP !== handledP) {\n          forwardedPromiseToPromise.set(handledP, targetP);\n        } else {\n          forwardedPromiseToPromise.delete(handledP);\n        }\n\n        // Remove stale pending handlers, set to canonical form.\n        shorten(handledP);\n\n        // Ensure our pendingHandler is cleaned up if not already.\n        if (promiseToPendingHandler.has(handledP)) {\n          handledP.then(_ => promiseToPendingHandler.delete(handledP));\n        }\n\n        // Finish the resolution.\n        superResolve(value);\n        resolved = true;\n        resolvedTarget = value;\n\n        // We're resolved, so forward any postponed operations to us.\n        continueForwarding();\n      };\n      handledReject = err => {\n        if (resolved) {\n          return;\n        }\n        assert(\n          !forwardedPromiseToPromise.has(handledP),\n          X`internal: already forwarded`,\n          TypeError,\n        );\n        promiseToPendingHandler.delete(handledP);\n        resolved = true;\n        superReject(err);\n        continueForwarding();\n      };\n    };\n    handledP = harden(construct(Promise, [superExecutor], new.target));\n\n    if (!pendingHandler) {\n      // This is insufficient for actual remote handled Promises\n      // (too many round-trips), but is an easy way to create a\n      // local handled Promise.\n      [pendingHandler, continueForwarding] = makePostponedHandler(\n        HandledPromise,\n      );\n    }\n\n    const validateHandler = h => {\n      assert(Object(h) === h, X`Handler ${h} cannot be a primitive`, TypeError);\n    };\n    validateHandler(pendingHandler);\n\n    // Until the handled promise is resolved, we use the pendingHandler.\n    promiseToPendingHandler.set(handledP, pendingHandler);\n\n    const rejectHandled = reason => {\n      if (resolved) {\n        return;\n      }\n      assert(\n        !forwardedPromiseToPromise.has(handledP),\n        X`internal: already forwarded`,\n        TypeError,\n      );\n      handledReject(reason);\n    };\n\n    const resolveWithPresence = (presenceHandler, options = {}) => {\n      if (resolved) {\n        return resolvedTarget;\n      }\n      assert(\n        !forwardedPromiseToPromise.has(handledP),\n        X`internal: already forwarded`,\n        TypeError,\n      );\n      try {\n        // Sanity checks.\n        validateHandler(presenceHandler);\n\n        const { proxy: proxyOpts } = options;\n        let presence;\n        if (proxyOpts) {\n          const {\n            handler: proxyHandler,\n            target: proxyTarget,\n            revokerCallback,\n          } = proxyOpts;\n          if (revokerCallback) {\n            // Create a proxy and its revoke function.\n            const { proxy, revoke } = Proxy.revocable(\n              proxyTarget,\n              proxyHandler,\n            );\n            presence = proxy;\n            revokerCallback(revoke);\n          } else {\n            presence = new Proxy(proxyTarget, proxyHandler);\n          }\n        } else {\n          // Default presence.\n          presence = create(null);\n        }\n\n        // Validate and install our mapped target (i.e. presence).\n        resolvedTarget = presence;\n\n        // Create table entries for the presence mapped to the\n        // fulfilledHandler.\n        presenceToPromise.set(resolvedTarget, handledP);\n        promiseToPresence.set(handledP, resolvedTarget);\n        presenceToHandler.set(resolvedTarget, presenceHandler);\n\n        // We committed to this presence, so resolve.\n        handledResolve(resolvedTarget);\n        return resolvedTarget;\n      } catch (e) {\n        assert.note(e, X`during resolveWithPresence`);\n        handledReject(e);\n        throw e;\n      }\n    };\n\n    const resolveHandled = target => {\n      if (resolved) {\n        return;\n      }\n      assert(\n        !forwardedPromiseToPromise.has(handledP),\n        X`internal: already forwarded`,\n        TypeError,\n      );\n      try {\n        // Resolve the target.\n        handledResolve(target);\n      } catch (e) {\n        handledReject(e);\n      }\n    };\n\n    // Invoke the callback to let the user resolve/reject.\n    executor(resolveHandled, rejectHandled, resolveWithPresence);\n\n    return handledP;\n  }\n\n  const isFrozenPromiseThen = p => {\n    return (\n      isFrozen(p) &&\n      getPrototypeOf(p) === Promise.prototype &&\n      Promise.resolve(p) === p &&\n      getOwnPropertyDescriptor(p, 'then') === undefined\n    );\n  };\n\n  /** @type {import('.').HandledPromiseStaticMethods & Pick<PromiseConstructor, 'resolve'>} */\n  const staticMethods = {\n    get(target, prop) {\n      prop = coerceToObjectProperty(prop);\n      return handle(target, 'get', [prop]);\n    },\n    getSendOnly(target, prop) {\n      prop = coerceToObjectProperty(prop);\n      handle(target, 'getSendOnly', [prop]);\n    },\n    applyFunction(target, args) {\n      // Ensure args is an array.\n      args = [...args];\n      return handle(target, 'applyFunction', [args]);\n    },\n    applyFunctionSendOnly(target, args) {\n      // Ensure args is an array.\n      args = [...args];\n      handle(target, 'applyFunctionSendOnly', [args]);\n    },\n    applyMethod(target, prop, args) {\n      prop = coerceToObjectProperty(prop);\n      // Ensure args is an array.\n      args = [...args];\n      return handle(target, 'applyMethod', [prop, args]);\n    },\n    applyMethodSendOnly(target, prop, args) {\n      prop = coerceToObjectProperty(prop);\n      // Ensure args is an array.\n      args = [...args];\n      handle(target, 'applyMethodSendOnly', [prop, args]);\n    },\n    resolve(value) {\n      // Resolving a Presence returns the pre-registered handled promise.\n      let resolvedPromise = presenceToPromise.get(/** @type {any} */ (value));\n      if (!resolvedPromise) {\n        resolvedPromise = Promise.resolve(value);\n      }\n      // Prevent any proxy trickery.\n      harden(resolvedPromise);\n      if (isFrozenPromiseThen(resolvedPromise)) {\n        // We can use the `resolvedPromise` directly, since it is guaranteed to\n        // have a `then` which is actually `Promise.prototype.then`.\n        return resolvedPromise;\n      }\n      // Assimilate the `resolvedPromise` as an actual frozen Promise, by\n      // treating `resolvedPromise` as if it is a non-promise thenable.\n      const executeThen = (resolve, reject) =>\n        resolvedPromise.then(resolve, reject);\n      return harden(\n        Promise.resolve().then(_ => new HandledPromise(executeThen)),\n      );\n    },\n  };\n\n  const makeForwarder = (operation, localImpl) => {\n    return (o, ...args) => {\n      // We are in another turn already, and have the naked object.\n      const presenceHandler = presenceToHandler.get(o);\n      if (!presenceHandler) {\n        return localImpl(o, ...args);\n      }\n      return dispatchToHandler(\n        'presenceHandler',\n        presenceHandler,\n        operation,\n        o,\n        args,\n      );\n    };\n  };\n\n  // eslint-disable-next-line prefer-const\n  forwardingHandler = {\n    get: makeForwarder('get', localGet),\n    getSendOnly: makeForwarder('getSendOnly', localGet),\n    applyFunction: makeForwarder('applyFunction', localApplyFunction),\n    applyFunctionSendOnly: makeForwarder(\n      'applyFunctionSendOnly',\n      localApplyFunction,\n    ),\n    applyMethod: makeForwarder('applyMethod', localApplyMethod),\n    applyMethodSendOnly: makeForwarder('applyMethodSendOnly', localApplyMethod),\n  };\n\n  handle = (...handleArgs) => {\n    // We're in SES mode, so we should harden.\n    harden(handleArgs);\n    const [_p, operation, opArgs, ...dispatchArgs] = handleArgs;\n    let [p] = handleArgs;\n    const doDispatch = (handlerName, handler, o) =>\n      dispatchToHandler(\n        handlerName,\n        handler,\n        operation,\n        o,\n        opArgs,\n        // eslint-disable-next-line no-use-before-define\n        ...(dispatchArgs.length === 0 ? [returnedP] : dispatchArgs),\n      );\n    const [trackedDoDispatch] = trackTurns([doDispatch]);\n    const returnedP = new HandledPromise((resolve, reject) => {\n      // We run in a future turn to prevent synchronous attacks,\n      let raceIsOver = false;\n      const win = (handlerName, handler, o) => {\n        if (raceIsOver) {\n          return;\n        }\n        try {\n          resolve(trackedDoDispatch(handlerName, handler, o));\n        } catch (reason) {\n          reject(reason);\n        }\n        raceIsOver = true;\n      };\n\n      const lose = e => {\n        if (raceIsOver) {\n          return;\n        }\n        reject(e);\n        raceIsOver = true;\n      };\n\n      // This contestant tries to win with the target's resolution.\n      staticMethods\n        .resolve(p)\n        .then(o => win('forwardingHandler', forwardingHandler, o))\n        .catch(lose);\n\n      // This contestant sleeps a turn, but then tries to win immediately.\n      staticMethods\n        .resolve()\n        .then(() => {\n          p = shorten(p);\n          const pendingHandler = promiseToPendingHandler.get(p);\n          if (pendingHandler) {\n            // resolve to the answer from the specific pending handler,\n            win('pendingHandler', pendingHandler, p);\n          } else if (!p || typeof p.then !== 'function') {\n            // Not a Thenable, so use it.\n            win('forwardingHandler', forwardingHandler, p);\n          } else if (promiseToPresence.has(p)) {\n            // We have the object synchronously, so resolve with it.\n            const o = promiseToPresence.get(p);\n            win('forwardingHandler', forwardingHandler, o);\n          }\n          // If we made it here without winning, then we will wait\n          // for the other contestant to win instead.\n        })\n        .catch(lose);\n    });\n\n    // Harden the fulfillment and rejection, as well as a workaround for\n    // Node.js: silence \"Unhandled Rejection\" by default when using the static\n    // methods.\n    returnedP.then(harden, harden);\n\n    // We return a handled promise with the default pending handler.  This\n    // prevents a race between the above Promise.resolves and pipelining.\n    return harden(returnedP);\n  };\n\n  // Add everything needed on the constructor.\n  baseHandledPromise.prototype = Promise.prototype;\n  setPrototypeOf(baseHandledPromise, Promise);\n  defineProperties(\n    baseHandledPromise,\n    getOwnPropertyDescriptors(staticMethods),\n  );\n\n  // FIXME: This is really ugly to bypass the type system, but it will be better\n  // once we use Promise.delegated and don't have any [[Constructor]] behaviours.\n  /** @type {unknown} */\n  const unknownBaseHandledPromise = baseHandledPromise;\n  HandledPromise = /** @type {typeof HandledPromise} */ (unknownBaseHandledPromise);\n\n  // We cannot harden(HandledPromise) because we're a vetted shim which\n  // runs before lockdown() allows harden to function.  In that case,\n  // though, globalThis.HandledPromise will be hardened after lockdown.\n  return HandledPromise;\n};\n"],"mappings":"AAAA;AACA;AACA,SAASA,UAAT,QAA2B,kBAA3B;AACA,SACEC,kBADF,EAEEC,gBAFF,EAGEC,QAHF,EAIEC,aAJF,QAKO,YALP;AAMA,SAASC,oBAAT,QAAqC,gBAArC;AAEA,MAAM;EAAEC,OAAO,EAAEC,CAAX;EAAcC,KAAK,EAAEC;AAArB,IAA2BC,MAAjC;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,MAAM;EACJC,MADI;EAEJC,wBAFI;EAGJC,yBAHI;EAIJC,gBAJI;EAKJC,cALI;EAMJC,cANI;EAOJC;AAPI,IAQFC,MARJ;AAUA,MAAM;EAAEC,KAAF;EAASC;AAAT,IAAuBC,OAA7B;AAEA,MAAMC,YAAY,GAAG,gBAArB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,sBAAsB,GAAGC,QAAQ,IAAI;EACzC,IAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;IAChC,OAAOA,QAAP;EACD;;EACD,OAAOC,MAAM,CAACD,QAAD,CAAb;AACD,CALD,C,CAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAME,kBAAkB,GAAG,MAAM;EACtC,MAAMC,iBAAiB,GAAG,IAAIC,OAAJ,EAA1B;EACA;;EACA,MAAMC,iBAAiB,GAAG,IAAID,OAAJ,EAA1B;EACA,MAAME,uBAAuB,GAAG,IAAIF,OAAJ,EAAhC;EACA,MAAMG,iBAAiB,GAAG,IAAIH,OAAJ,EAA1B;EACA,MAAMI,yBAAyB,GAAG,IAAIJ,OAAJ,EAAlC,CANsC,CAMW;;EAEjD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,MAAMK,OAAO,GAAGC,MAAM,IAAI;IACxB,IAAIC,CAAC,GAAGD,MAAR,CADwB,CAExB;;IACA,OAAOF,yBAAyB,CAACI,GAA1B,CAA8BD,CAA9B,CAAP,EAAyC;MACvCA,CAAC,GAAGH,yBAAyB,CAACK,GAA1B,CAA8BF,CAA9B,CAAJ;IACD;;IACD,MAAMG,QAAQ,GAAGP,iBAAiB,CAACM,GAAlB,CAAsBF,CAAtB,CAAjB;;IACA,IAAIG,QAAJ,EAAc;MACZ;MACA;MACA,OAAOJ,MAAM,KAAKC,CAAlB,EAAqB;QACnB,MAAMI,MAAM,GAAGP,yBAAyB,CAACK,GAA1B,CAA8BH,MAA9B,CAAf;QACAF,yBAAyB,CAACQ,MAA1B,CAAiCN,MAAjC;QACAJ,uBAAuB,CAACU,MAAxB,CAA+BN,MAA/B;QACAH,iBAAiB,CAACU,GAAlB,CAAsBP,MAAtB,EAA8BI,QAA9B;QACAJ,MAAM,GAAGK,MAAT;MACD;IACF,CAVD,MAUO;MACL;MACA;MACA;MACA,OAAOL,MAAM,KAAKC,CAAlB,EAAqB;QACnB,MAAMI,MAAM,GAAGP,yBAAyB,CAACK,GAA1B,CAA8BH,MAA9B,CAAf;QACAF,yBAAyB,CAACS,GAA1B,CAA8BP,MAA9B,EAAsCC,CAAtC;QACAL,uBAAuB,CAACU,MAAxB,CAA+BN,MAA/B;QACAA,MAAM,GAAGK,MAAT;MACD;IACF;;IACD,OAAOL,MAAP;EACD,CA7BD;EA+BA;AACF;AACA;AACA;AACA;AACA;;;EACE,IAAIQ,iBAAJ;EACA,IAAIC,MAAJ;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,MAAMC,iBAAiB,GAAG,CACxBC,WADwB,EAExBC,OAFwB,EAGxBC,SAHwB,EAIxBC,CAJwB,EAKxBC,MALwB,EAMxBC,SANwB,KAOrB;IACH,IAAIC,QAAQ,GAAGJ,SAAf;IAEA,MAAMK,aAAa,GAAG9B,YAAY,CAAC+B,IAAb,CAAkBF,QAAlB,CAAtB;;IAEA,MAAMG,UAAU,GAAGC,MAAM,IAAKH,aAAa,GAAGI,SAAH,GAAeD,MAA1D;;IAEA,IAAIH,aAAJ,EAAmB;MACjB;MACAF,SAAS,GAAGM,SAAZ;IACD;;IAED,IAAIJ,aAAa,IAAI,OAAON,OAAO,CAACK,QAAD,CAAd,KAA6B,UAAlD,EAA8D;MAC5D;MACAA,QAAQ,GAAGC,aAAa,CAAC,CAAD,CAAxB;IACD,CAfE,CAiBH;;;IACA,MAAMK,GAAG,GAAGX,OAAO,CAACK,QAAD,CAAnB;;IACA,IAAI,OAAOM,GAAP,KAAe,UAAnB,EAA+B;MAC7B,MAAMF,MAAM,GAAGpC,KAAK,CAACsC,GAAD,EAAMX,OAAN,EAAe,CAACE,CAAD,EAAI,GAAGC,MAAP,EAAeC,SAAf,CAAf,CAApB;MACA,OAAOI,UAAU,CAACC,MAAD,CAAjB;IACD;;IAED,IAAIJ,QAAQ,KAAK,aAAjB,EAAgC;MAC9B;MACA,MAAM,CAACO,IAAD,EAAOC,IAAP,IAAeV,MAArB;MACA,MAAMW,UAAU,GAAGjB,MAAM,CACvBK,CADuB,EAEvB,KAFuB,EAGvB;MACA,CAACzB,sBAAsB,CAACmC,IAAD,CAAvB,CAJuB,EAKvBF,SALuB,CAAzB;MAOA,OAAOF,UAAU,CAACX,MAAM,CAACiB,UAAD,EAAa,eAAb,EAA8B,CAACD,IAAD,CAA9B,EAAsCT,SAAtC,CAAP,CAAjB;IACD,CAnCE,CAqCH;;;IACA,IAAIC,QAAQ,KAAK,eAAjB,EAAkC;MAChC,MAAMU,IAAI,GAAGf,OAAO,CAACgB,WAArB;;MACA,IAAI,OAAOD,IAAP,KAAgB,UAApB,EAAgC;QAC9B;QACA,MAAM,CAACF,IAAD,IAASV,MAAf;QACA,MAAMM,MAAM,GAAGpC,KAAK,CAAC0C,IAAD,EAAOf,OAAP,EAAgB,CAACE,CAAD,EAAIQ,SAAJ,EAAe,CAACG,IAAD,CAAf,EAAuBT,SAAvB,CAAhB,CAApB;QACA,OAAOI,UAAU,CAACC,MAAD,CAAjB;MACD;IACF;;IAED7C,MAAM,CAACqD,IAAP,CACExD,CAAE,GAAEE,CAAC,CAACoC,WAAD,CAAc,6CAA4CpC,CAAC,CAC9DsC,SAD8D,CAE9D,SAAQtC,CAAC,CAACL,aAAa,CAAC0C,OAAD,CAAd,CAAyB,GAHtC,EAIEkB,SAJF;EAMD,CA7DD;EA+DA;;;EACA,IAAIC,cAAJ;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EACE,SAASC,kBAAT,CAA4BC,QAA5B,EAAkE;IAAA,IAA5BC,cAA4B,uEAAXZ,SAAW;IAChE9C,MAAM,CAAC2D,GAAG,CAACnC,MAAL,EAAa3B,CAAE,4BAAf,CAAN;IACA,IAAI+D,cAAJ;IACA,IAAIC,aAAJ;IACA,IAAIC,QAAQ,GAAG,KAAf;IACA,IAAIC,cAAc,GAAG,IAArB;IACA,IAAIC,QAAJ;;IACA,IAAIC,kBAAkB,GAAG,MAAM,CAAE,CAAjC;;IACA,MAAMC,aAAa,GAAG,CAACC,YAAD,EAAeC,WAAf,KAA+B;MACnDR,cAAc,GAAGS,KAAK,IAAI;QACxB,IAAIP,QAAJ,EAAc;UACZ;QACD;;QACD9D,MAAM,CACJ,CAACsB,yBAAyB,CAACI,GAA1B,CAA8BsC,QAA9B,CADG,EAEJnE,CAAE,6BAFE,EAGJyD,SAHI,CAAN;QAKAe,KAAK,GAAG9C,OAAO,CAAC8C,KAAD,CAAf;QACA,IAAIC,OAAJ;;QACA,IACElD,uBAAuB,CAACM,GAAxB,CAA4B2C,KAA5B,KACAhD,iBAAiB,CAACK,GAAlB,CAAsB2C,KAAtB,CAFF,EAGE;UACAC,OAAO,GAAGD,KAAV;QACD,CALD,MAKO;UACL;UACAjD,uBAAuB,CAACU,MAAxB,CAA+BkC,QAA/B;UACAM,OAAO,GAAGnD,iBAAiB,CAACQ,GAAlB,CAAsB0C,KAAtB,CAAV;QACD,CApBuB,CAqBxB;;;QACA,IAAIC,OAAO,IAAIA,OAAO,KAAKN,QAA3B,EAAqC;UACnC1C,yBAAyB,CAACS,GAA1B,CAA8BiC,QAA9B,EAAwCM,OAAxC;QACD,CAFD,MAEO;UACLhD,yBAAyB,CAACQ,MAA1B,CAAiCkC,QAAjC;QACD,CA1BuB,CA4BxB;;;QACAzC,OAAO,CAACyC,QAAD,CAAP,CA7BwB,CA+BxB;;QACA,IAAI5C,uBAAuB,CAACM,GAAxB,CAA4BsC,QAA5B,CAAJ,EAA2C;UACzCA,QAAQ,CAACO,IAAT,CAAcC,CAAC,IAAIpD,uBAAuB,CAACU,MAAxB,CAA+BkC,QAA/B,CAAnB;QACD,CAlCuB,CAoCxB;;;QACAG,YAAY,CAACE,KAAD,CAAZ;QACAP,QAAQ,GAAG,IAAX;QACAC,cAAc,GAAGM,KAAjB,CAvCwB,CAyCxB;;QACAJ,kBAAkB;MACnB,CA3CD;;MA4CAJ,aAAa,GAAGY,GAAG,IAAI;QACrB,IAAIX,QAAJ,EAAc;UACZ;QACD;;QACD9D,MAAM,CACJ,CAACsB,yBAAyB,CAACI,GAA1B,CAA8BsC,QAA9B,CADG,EAEJnE,CAAE,6BAFE,EAGJyD,SAHI,CAAN;QAKAlC,uBAAuB,CAACU,MAAxB,CAA+BkC,QAA/B;QACAF,QAAQ,GAAG,IAAX;QACAM,WAAW,CAACK,GAAD,CAAX;QACAR,kBAAkB;MACnB,CAbD;IAcD,CA3DD;;IA4DAD,QAAQ,GAAGU,MAAM,CAAChE,SAAS,CAACiE,OAAD,EAAU,CAACT,aAAD,CAAV,EAA2BP,GAAG,CAACnC,MAA/B,CAAV,CAAjB;;IAEA,IAAI,CAACkC,cAAL,EAAqB;MACnB;MACA;MACA;MACA,CAACA,cAAD,EAAiBO,kBAAjB,IAAuCtE,oBAAoB,CACzD4D,cADyD,CAA3D;IAGD;;IAED,MAAMqB,eAAe,GAAGC,CAAC,IAAI;MAC3B7E,MAAM,CAACQ,MAAM,CAACqE,CAAD,CAAN,KAAcA,CAAf,EAAkBhF,CAAE,WAAUgF,CAAE,wBAAhC,EAAyDvB,SAAzD,CAAN;IACD,CAFD;;IAGAsB,eAAe,CAAClB,cAAD,CAAf,CAlFgE,CAoFhE;;IACAtC,uBAAuB,CAACW,GAAxB,CAA4BiC,QAA5B,EAAsCN,cAAtC;;IAEA,MAAMoB,aAAa,GAAGC,MAAM,IAAI;MAC9B,IAAIjB,QAAJ,EAAc;QACZ;MACD;;MACD9D,MAAM,CACJ,CAACsB,yBAAyB,CAACI,GAA1B,CAA8BsC,QAA9B,CADG,EAEJnE,CAAE,6BAFE,EAGJyD,SAHI,CAAN;MAKAO,aAAa,CAACkB,MAAD,CAAb;IACD,CAVD;;IAYA,MAAMC,mBAAmB,GAAG,UAACC,eAAD,EAAmC;MAAA,IAAjBC,OAAiB,uEAAP,EAAO;;MAC7D,IAAIpB,QAAJ,EAAc;QACZ,OAAOC,cAAP;MACD;;MACD/D,MAAM,CACJ,CAACsB,yBAAyB,CAACI,GAA1B,CAA8BsC,QAA9B,CADG,EAEJnE,CAAE,6BAFE,EAGJyD,SAHI,CAAN;;MAKA,IAAI;QACF;QACAsB,eAAe,CAACK,eAAD,CAAf;QAEA,MAAM;UAAEE,KAAK,EAAEC;QAAT,IAAuBF,OAA7B;QACA,IAAItD,QAAJ;;QACA,IAAIwD,SAAJ,EAAe;UACb,MAAM;YACJhD,OAAO,EAAEiD,YADL;YAEJ7D,MAAM,EAAE8D,WAFJ;YAGJC;UAHI,IAIFH,SAJJ;;UAKA,IAAIG,eAAJ,EAAqB;YACnB;YACA,MAAM;cAAEJ,KAAF;cAASK;YAAT,IAAoBC,KAAK,CAACC,SAAN,CACxBJ,WADwB,EAExBD,YAFwB,CAA1B;YAIAzD,QAAQ,GAAGuD,KAAX;YACAI,eAAe,CAACC,MAAD,CAAf;UACD,CARD,MAQO;YACL5D,QAAQ,GAAG,IAAI6D,KAAJ,CAAUH,WAAV,EAAuBD,YAAvB,CAAX;UACD;QACF,CAjBD,MAiBO;UACL;UACAzD,QAAQ,GAAG3B,MAAM,CAAC,IAAD,CAAjB;QACD,CA1BC,CA4BF;;;QACA8D,cAAc,GAAGnC,QAAjB,CA7BE,CA+BF;QACA;;QACAT,iBAAiB,CAACY,GAAlB,CAAsBgC,cAAtB,EAAsCC,QAAtC;QACA3C,iBAAiB,CAACU,GAAlB,CAAsBiC,QAAtB,EAAgCD,cAAhC;QACA9C,iBAAiB,CAACc,GAAlB,CAAsBgC,cAAtB,EAAsCkB,eAAtC,EAnCE,CAqCF;;QACArB,cAAc,CAACG,cAAD,CAAd;QACA,OAAOA,cAAP;MACD,CAxCD,CAwCE,OAAO4B,CAAP,EAAU;QACV3F,MAAM,CAAC4F,IAAP,CAAYD,CAAZ,EAAe9F,CAAE,4BAAjB;QACAgE,aAAa,CAAC8B,CAAD,CAAb;QACA,MAAMA,CAAN;MACD;IACF,CAtDD;;IAwDA,MAAME,cAAc,GAAGrE,MAAM,IAAI;MAC/B,IAAIsC,QAAJ,EAAc;QACZ;MACD;;MACD9D,MAAM,CACJ,CAACsB,yBAAyB,CAACI,GAA1B,CAA8BsC,QAA9B,CADG,EAEJnE,CAAE,6BAFE,EAGJyD,SAHI,CAAN;;MAKA,IAAI;QACF;QACAM,cAAc,CAACpC,MAAD,CAAd;MACD,CAHD,CAGE,OAAOmE,CAAP,EAAU;QACV9B,aAAa,CAAC8B,CAAD,CAAb;MACD;IACF,CAfD,CA3JgE,CA4KhE;;;IACAlC,QAAQ,CAACoC,cAAD,EAAiBf,aAAjB,EAAgCE,mBAAhC,CAAR;IAEA,OAAOhB,QAAP;EACD;;EAED,MAAM8B,mBAAmB,GAAGrE,CAAC,IAAI;IAC/B,OACElB,QAAQ,CAACkB,CAAD,CAAR,IACApB,cAAc,CAACoB,CAAD,CAAd,KAAsBkD,OAAO,CAACoB,SAD9B,IAEApB,OAAO,CAACqB,OAAR,CAAgBvE,CAAhB,MAAuBA,CAFvB,IAGAvB,wBAAwB,CAACuB,CAAD,EAAI,MAAJ,CAAxB,KAAwCqB,SAJ1C;EAMD,CAPD;EASA;;;EACA,MAAMmD,aAAa,GAAG;IACpBtE,GAAG,CAACH,MAAD,EAASwB,IAAT,EAAe;MAChBA,IAAI,GAAGnC,sBAAsB,CAACmC,IAAD,CAA7B;MACA,OAAOf,MAAM,CAACT,MAAD,EAAS,KAAT,EAAgB,CAACwB,IAAD,CAAhB,CAAb;IACD,CAJmB;;IAKpBkD,WAAW,CAAC1E,MAAD,EAASwB,IAAT,EAAe;MACxBA,IAAI,GAAGnC,sBAAsB,CAACmC,IAAD,CAA7B;MACAf,MAAM,CAACT,MAAD,EAAS,aAAT,EAAwB,CAACwB,IAAD,CAAxB,CAAN;IACD,CARmB;;IASpBmD,aAAa,CAAC3E,MAAD,EAASyB,IAAT,EAAe;MAC1B;MACAA,IAAI,GAAG,CAAC,GAAGA,IAAJ,CAAP;MACA,OAAOhB,MAAM,CAACT,MAAD,EAAS,eAAT,EAA0B,CAACyB,IAAD,CAA1B,CAAb;IACD,CAbmB;;IAcpBmD,qBAAqB,CAAC5E,MAAD,EAASyB,IAAT,EAAe;MAClC;MACAA,IAAI,GAAG,CAAC,GAAGA,IAAJ,CAAP;MACAhB,MAAM,CAACT,MAAD,EAAS,uBAAT,EAAkC,CAACyB,IAAD,CAAlC,CAAN;IACD,CAlBmB;;IAmBpBG,WAAW,CAAC5B,MAAD,EAASwB,IAAT,EAAeC,IAAf,EAAqB;MAC9BD,IAAI,GAAGnC,sBAAsB,CAACmC,IAAD,CAA7B,CAD8B,CAE9B;;MACAC,IAAI,GAAG,CAAC,GAAGA,IAAJ,CAAP;MACA,OAAOhB,MAAM,CAACT,MAAD,EAAS,aAAT,EAAwB,CAACwB,IAAD,EAAOC,IAAP,CAAxB,CAAb;IACD,CAxBmB;;IAyBpBoD,mBAAmB,CAAC7E,MAAD,EAASwB,IAAT,EAAeC,IAAf,EAAqB;MACtCD,IAAI,GAAGnC,sBAAsB,CAACmC,IAAD,CAA7B,CADsC,CAEtC;;MACAC,IAAI,GAAG,CAAC,GAAGA,IAAJ,CAAP;MACAhB,MAAM,CAACT,MAAD,EAAS,qBAAT,EAAgC,CAACwB,IAAD,EAAOC,IAAP,CAAhC,CAAN;IACD,CA9BmB;;IA+BpB+C,OAAO,CAAC3B,KAAD,EAAQ;MACb;MACA,IAAIiC,eAAe,GAAGnF,iBAAiB,CAACQ,GAAlB;MAAsB;MAAoB0C,KAA1C,CAAtB;;MACA,IAAI,CAACiC,eAAL,EAAsB;QACpBA,eAAe,GAAG3B,OAAO,CAACqB,OAAR,CAAgB3B,KAAhB,CAAlB;MACD,CALY,CAMb;;;MACAK,MAAM,CAAC4B,eAAD,CAAN;;MACA,IAAIR,mBAAmB,CAACQ,eAAD,CAAvB,EAA0C;QACxC;QACA;QACA,OAAOA,eAAP;MACD,CAZY,CAab;MACA;;;MACA,MAAMC,WAAW,GAAG,CAACP,OAAD,EAAUQ,MAAV,KAClBF,eAAe,CAAC/B,IAAhB,CAAqByB,OAArB,EAA8BQ,MAA9B,CADF;;MAEA,OAAO9B,MAAM,CACXC,OAAO,CAACqB,OAAR,GAAkBzB,IAAlB,CAAuBC,CAAC,IAAI,IAAIjB,cAAJ,CAAmBgD,WAAnB,CAA5B,CADW,CAAb;IAGD;;EAnDmB,CAAtB;;EAsDA,MAAME,aAAa,GAAG,CAACpE,SAAD,EAAYqE,SAAZ,KAA0B;IAC9C,OAAO,UAACpE,CAAD,EAAgB;MACrB;MACA,MAAM2C,eAAe,GAAGhE,iBAAiB,CAACU,GAAlB,CAAsBW,CAAtB,CAAxB;;MAFqB,kCAATW,IAAS;QAATA,IAAS;MAAA;;MAGrB,IAAI,CAACgC,eAAL,EAAsB;QACpB,OAAOyB,SAAS,CAACpE,CAAD,EAAI,GAAGW,IAAP,CAAhB;MACD;;MACD,OAAOf,iBAAiB,CACtB,iBADsB,EAEtB+C,eAFsB,EAGtB5C,SAHsB,EAItBC,CAJsB,EAKtBW,IALsB,CAAxB;IAOD,CAbD;EAcD,CAfD,CAnYsC,CAoZtC;;;EACAjB,iBAAiB,GAAG;IAClBL,GAAG,EAAE8E,aAAa,CAAC,KAAD,EAAQhH,QAAR,CADA;IAElByG,WAAW,EAAEO,aAAa,CAAC,aAAD,EAAgBhH,QAAhB,CAFR;IAGlB0G,aAAa,EAAEM,aAAa,CAAC,eAAD,EAAkBlH,kBAAlB,CAHV;IAIlB6G,qBAAqB,EAAEK,aAAa,CAClC,uBADkC,EAElClH,kBAFkC,CAJlB;IAQlB6D,WAAW,EAAEqD,aAAa,CAAC,aAAD,EAAgBjH,gBAAhB,CARR;IASlB6G,mBAAmB,EAAEI,aAAa,CAAC,qBAAD,EAAwBjH,gBAAxB;EAThB,CAApB;;EAYAyC,MAAM,GAAG,YAAmB;IAAA,mCAAf0E,UAAe;MAAfA,UAAe;IAAA;;IAC1B;IACAjC,MAAM,CAACiC,UAAD,CAAN;IACA,MAAM,CAACC,EAAD,EAAKvE,SAAL,EAAgBE,MAAhB,EAAwB,GAAGsE,YAA3B,IAA2CF,UAAjD;IACA,IAAI,CAAClF,CAAD,IAAMkF,UAAV;;IACA,MAAMG,UAAU,GAAG,CAAC3E,WAAD,EAAcC,OAAd,EAAuBE,CAAvB,KACjBJ,iBAAiB,CACfC,WADe,EAEfC,OAFe,EAGfC,SAHe,EAIfC,CAJe,EAKfC,MALe,EAMf;IACA,IAAIsE,YAAY,CAACE,MAAb,KAAwB,CAAxB,GAA4B,CAACvE,SAAD,CAA5B,GAA0CqE,YAA9C,CAPe,CADnB;;IAUA,MAAM,CAACG,iBAAD,IAAsB1H,UAAU,CAAC,CAACwH,UAAD,CAAD,CAAtC;IACA,MAAMtE,SAAS,GAAG,IAAIe,cAAJ,CAAmB,CAACyC,OAAD,EAAUQ,MAAV,KAAqB;MACxD;MACA,IAAIS,UAAU,GAAG,KAAjB;;MACA,MAAMC,GAAG,GAAG,CAAC/E,WAAD,EAAcC,OAAd,EAAuBE,CAAvB,KAA6B;QACvC,IAAI2E,UAAJ,EAAgB;UACd;QACD;;QACD,IAAI;UACFjB,OAAO,CAACgB,iBAAiB,CAAC7E,WAAD,EAAcC,OAAd,EAAuBE,CAAvB,CAAlB,CAAP;QACD,CAFD,CAEE,OAAOyC,MAAP,EAAe;UACfyB,MAAM,CAACzB,MAAD,CAAN;QACD;;QACDkC,UAAU,GAAG,IAAb;MACD,CAVD;;MAYA,MAAME,IAAI,GAAGxB,CAAC,IAAI;QAChB,IAAIsB,UAAJ,EAAgB;UACd;QACD;;QACDT,MAAM,CAACb,CAAD,CAAN;QACAsB,UAAU,GAAG,IAAb;MACD,CAND,CAfwD,CAuBxD;;;MACAhB,aAAa,CACVD,OADH,CACWvE,CADX,EAEG8C,IAFH,CAEQjC,CAAC,IAAI4E,GAAG,CAAC,mBAAD,EAAsBlF,iBAAtB,EAAyCM,CAAzC,CAFhB,EAGG8E,KAHH,CAGSD,IAHT,EAxBwD,CA6BxD;;MACAlB,aAAa,CACVD,OADH,GAEGzB,IAFH,CAEQ,MAAM;QACV9C,CAAC,GAAGF,OAAO,CAACE,CAAD,CAAX;QACA,MAAMiC,cAAc,GAAGtC,uBAAuB,CAACO,GAAxB,CAA4BF,CAA5B,CAAvB;;QACA,IAAIiC,cAAJ,EAAoB;UAClB;UACAwD,GAAG,CAAC,gBAAD,EAAmBxD,cAAnB,EAAmCjC,CAAnC,CAAH;QACD,CAHD,MAGO,IAAI,CAACA,CAAD,IAAM,OAAOA,CAAC,CAAC8C,IAAT,KAAkB,UAA5B,EAAwC;UAC7C;UACA2C,GAAG,CAAC,mBAAD,EAAsBlF,iBAAtB,EAAyCP,CAAzC,CAAH;QACD,CAHM,MAGA,IAAIJ,iBAAiB,CAACK,GAAlB,CAAsBD,CAAtB,CAAJ,EAA8B;UACnC;UACA,MAAMa,CAAC,GAAGjB,iBAAiB,CAACM,GAAlB,CAAsBF,CAAtB,CAAV;UACAyF,GAAG,CAAC,mBAAD,EAAsBlF,iBAAtB,EAAyCM,CAAzC,CAAH;QACD,CAbS,CAcV;QACA;;MACD,CAlBH,EAmBG8E,KAnBH,CAmBSD,IAnBT;IAoBD,CAlDiB,CAAlB,CAhB0B,CAoE1B;IACA;IACA;;IACA3E,SAAS,CAAC+B,IAAV,CAAeG,MAAf,EAAuBA,MAAvB,EAvE0B,CAyE1B;IACA;;IACA,OAAOA,MAAM,CAAClC,SAAD,CAAb;EACD,CA5ED,CAjasC,CA+etC;;;EACAgB,kBAAkB,CAACuC,SAAnB,GAA+BpB,OAAO,CAACoB,SAAvC;EACAzF,cAAc,CAACkD,kBAAD,EAAqBmB,OAArB,CAAd;EACAvE,gBAAgB,CACdoD,kBADc,EAEdrD,yBAAyB,CAAC8F,aAAD,CAFX,CAAhB,CAlfsC,CAuftC;EACA;;EACA;;EACA,MAAMoB,yBAAyB,GAAG7D,kBAAlC;EACAD,cAAc;EAAG;EAAsC8D,yBAAvD,CA3fsC,CA6ftC;EACA;EACA;;EACA,OAAO9D,cAAP;AACD,CAjgBM"},"metadata":{},"sourceType":"module"}