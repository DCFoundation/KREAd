{"ast":null,"code":"// @ts-nocheck TODO Fix the recursive types to it checks. Will this\n// require a .d.ts file? I don't know.\n/// <reference path=\"extra-types.d.ts\" />\nexport {};\n/**\n * @typedef { \"undefined\" | \"null\" |\n *   \"boolean\" | \"number\" | \"bigint\" | \"string\" | \"symbol\"\n * } PrimitiveStyle\n */\n\n/**\n * @typedef { PrimitiveStyle |\n *   \"copyRecord\" | \"copyArray\" | \"tagged\" |\n *   \"remotable\" |\n *   \"error\" | \"promise\"\n * } PassStyle\n */\n// TODO declare more precise types throughout this file, so the type system\n// and IDE can be more helpful.\n\n/**\n * @typedef {*} Passable\n *\n * A Passable value that may be marshalled. It is classified as one of\n * PassStyle. A Passable must be hardened.\n *\n * A Passable has a pass-by-copy superstructure. This includes\n *    * the atomic pass-by-copy primitives (\"undefined\" | \"null\" |\n *      \"boolean\" | \"number\" | \"bigint\" | \"string\" | \"symbol\"),\n *    * the pass-by-copy containers\n *      (\"copyRecord\" | \"copyArray\" | \"tagged\") that\n *      contain other Passables,\n *    * and the special cases (\"error\" | \"promise\").\n *\n * A Passable's pass-by-copy superstructure ends in\n * PassableCap leafs (\"remotable\" | \"promise\"). Since a\n * Passable is hardened, its structure and classification is stable --- its\n * structure and classification cannot change even if some of the objects are\n * proxies.\n */\n\n/**\n * @callback PassStyleOf\n * @param {Passable} passable\n * @returns {PassStyle}\n */\n\n/**\n * @typedef {Passable} PureData\n *\n * A Passable is PureData when its pass-by-copy superstructure whose\n * nodes are pass-by-copy composites (CopyArray, CopyRecord, Tagged) leaves are\n * primitives or empty composites. No remotables, promises, or errors.\n *\n * This check assures purity *given* that none of these pass-by-copy composites\n * can be a Proxy. TODO SECURITY BUG we plan to enforce this, giving these\n * pass-by-copy composites much of the same security properties as the\n * proposed Records and Tuples (TODO need link).\n *\n * Given this (currently counter-factual) assumption, a PureData value cannot\n * be used as a communications channel,\n * and can therefore be safely shared with subgraphs that should not be able\n * to communicate with each other.\n */\n\n/**\n * @typedef {Passable} Remotable\n * Might be an object explicitly declared to be `Remotable` using the\n * `Far` or `Remotable` functions, or a remote presence of a Remotable.\n */\n\n/**\n * @typedef {Promise | Remotable} PassableCap\n * The leaves of a Passable's pass-by-copy superstructure.\n */\n\n/**\n * @template T\n * @typedef {T[]} CopyArray\n */\n\n/**\n * @template T\n * @typedef {Record<string, T>} CopyRecord\n */\n\n/**\n * @typedef {{\n *   [PASS_STYLE]: 'tagged',\n *   [Symbol.toStringTag]: string,\n *   payload: Passable\n * }} CopyTagged\n *\n * The tag is the value of the `[String.toStringTag]` property.\n */\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @template Slot\n * @callback ConvertValToSlot\n * @param {PassableCap} val\n * @returns {Slot}\n */\n\n/**\n * @template Slot\n * @callback ConvertSlotToVal\n * @param {Slot} slot\n * @param {InterfaceSpec=} iface\n * @returns {PassableCap}\n */\n\n/**\n * @template T\n * @typedef {{ '@qclass': T }} EncodingClass\n */\n\n/**\n * @typedef {EncodingClass<'NaN'> |\n *           EncodingClass<'undefined'> |\n *           EncodingClass<'Infinity'> |\n *           EncodingClass<'-Infinity'> |\n *           EncodingClass<'bigint'> & { digits: string } |\n *           EncodingClass<'@@asyncIterator'> |\n *           EncodingClass<'symbol'> & { name: string } |\n *           EncodingClass<'error'> & { name: string,\n *                                      message: string,\n *                                      errorId?: string\n *           } |\n *           EncodingClass<'slot'> & { index: number, iface?: InterfaceSpec } |\n *           EncodingClass<'hilbert'> & { original: Encoding,\n *                                        rest?: Encoding\n *           } |\n *           EncodingClass<'tagged'> & { tag: string,\n *                                       payload: Encoding\n *           }\n * } EncodingUnion\n * @typedef {{ [index: string]: Encoding,\n *             '@qclass'?: undefined\n * }} EncodingRecord\n * We exclude '@qclass' as a property in encoding records.\n * @typedef {EncodingUnion | null | string |\n *           boolean | number | EncodingRecord\n * } EncodingElement\n */\n\n/**\n * @typedef {EncodingElement | NestedArray<EncodingElement>} Encoding\n * The JSON structure that the data portion of a Passable serializes to.\n *\n * The QCLASS 'hilbert' is a reference to the Hilbert Hotel\n * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel\n * If QCLASS appears as a property name in the data, we encode it instead\n * as a QCLASS record of type 'hilbert'. To do so, we must move the other\n * parts of the record into fields of the hilbert record.\n */\n\n/**\n * @template Slot\n * @typedef {Object} CapData\n * @property {string} body A JSON.stringify of an Encoding\n * @property {Slot[]} slots\n */\n\n/**\n * @template Slot\n * @callback Serialize\n * @param {Passable} val\n * @returns {CapData<Slot>}\n */\n\n/**\n * @template Slot\n * @callback Unserialize\n * @param {CapData<Slot>} data\n * @returns {Passable}\n */\n\n/**\n * @template Slot\n * @typedef {Object} Marshal\n * @property {Serialize<Slot>} serialize\n * @property {Unserialize<Slot>} unserialize\n */\n\n/**\n * @typedef {Object} MakeMarshalOptions\n * @property {'on'|'off'=} errorTagging controls whether serialized errors\n * also carry tagging information, made from `marshalName` and numbers\n * generated (currently by counting) starting at `errorIdNum`. The\n * `errorTagging` option defaults to `'on'`. Serialized\n * errors are also logged to `marshalSaveError` only if tagging is `'on'`.\n * @property {string=} marshalName Used to identify sent errors.\n * @property {number=} errorIdNum Ascending numbers staring from here\n * identify the sending of errors relative to this marshal instance.\n * @property {(err: Error) => void=} marshalSaveError If `errorTagging` is\n * `'on'`, then errors serialized by this marshal instance are also\n * logged by calling `marshalSaveError` *after* `assert.note` associated\n * that error with its errorId. Thus, if `marshalSaveError` in turn logs\n * to the normal console, which is the default, then the console will\n * show that note showing the associated errorId.\n */\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {string} InterfaceSpec\n * This is an interface specification.\n * For now, it is just a string, but will eventually be `PureData`. Either\n * way, it must remain pure, so that it can be safely shared by subgraphs that\n * are not supposed to be able to communicate.\n */\n\n/**\n * @callback MarshalGetInterfaceOf\n * Simple semantics, just tell what interface (or undefined) a remotable has.\n * @param {*} maybeRemotable the value to check\n * @returns {InterfaceSpec|undefined} the interface specification, or undefined\n * if not a deemed to be a Remotable\n */\n\n/**\n * @callback Checker\n * Internal to a useful pattern for writing checking logic\n * (a \"checkFoo\" function) that can be used to implement a predicate\n * (an \"isFoo\" function) or a validator (an \"assertFoo\" function).\n *\n *    * A predicate ideally only returns `true` or `false` and rarely throws.\n *    * A validator throws an informative diagnostic when the predicate\n *      would have returned `false`, and simply returns `undefined` normally\n *      when the predicate would have returned `true`.\n *    * The internal checking function that they share is parameterized by a\n *      `Checker` that determines how to proceed with a failure condition.\n *      Predicates pass in an identity function as checker. Validators\n *      pass in `assertChecker` which is a trivial wrapper around `assert`.\n *\n * See the various uses for good examples.\n * @param {boolean} cond\n * @param {Details=} details\n * @returns {boolean}\n */","map":{"version":3,"names":[],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/types.js"],"sourcesContent":["// @ts-nocheck TODO Fix the recursive types to it checks. Will this\n// require a .d.ts file? I don't know.\n\n/// <reference path=\"extra-types.d.ts\" />\n\nexport {};\n\n/**\n * @typedef { \"undefined\" | \"null\" |\n *   \"boolean\" | \"number\" | \"bigint\" | \"string\" | \"symbol\"\n * } PrimitiveStyle\n */\n\n/**\n * @typedef { PrimitiveStyle |\n *   \"copyRecord\" | \"copyArray\" | \"tagged\" |\n *   \"remotable\" |\n *   \"error\" | \"promise\"\n * } PassStyle\n */\n\n// TODO declare more precise types throughout this file, so the type system\n// and IDE can be more helpful.\n\n/**\n * @typedef {*} Passable\n *\n * A Passable value that may be marshalled. It is classified as one of\n * PassStyle. A Passable must be hardened.\n *\n * A Passable has a pass-by-copy superstructure. This includes\n *    * the atomic pass-by-copy primitives (\"undefined\" | \"null\" |\n *      \"boolean\" | \"number\" | \"bigint\" | \"string\" | \"symbol\"),\n *    * the pass-by-copy containers\n *      (\"copyRecord\" | \"copyArray\" | \"tagged\") that\n *      contain other Passables,\n *    * and the special cases (\"error\" | \"promise\").\n *\n * A Passable's pass-by-copy superstructure ends in\n * PassableCap leafs (\"remotable\" | \"promise\"). Since a\n * Passable is hardened, its structure and classification is stable --- its\n * structure and classification cannot change even if some of the objects are\n * proxies.\n */\n\n/**\n * @callback PassStyleOf\n * @param {Passable} passable\n * @returns {PassStyle}\n */\n\n/**\n * @typedef {Passable} PureData\n *\n * A Passable is PureData when its pass-by-copy superstructure whose\n * nodes are pass-by-copy composites (CopyArray, CopyRecord, Tagged) leaves are\n * primitives or empty composites. No remotables, promises, or errors.\n *\n * This check assures purity *given* that none of these pass-by-copy composites\n * can be a Proxy. TODO SECURITY BUG we plan to enforce this, giving these\n * pass-by-copy composites much of the same security properties as the\n * proposed Records and Tuples (TODO need link).\n *\n * Given this (currently counter-factual) assumption, a PureData value cannot\n * be used as a communications channel,\n * and can therefore be safely shared with subgraphs that should not be able\n * to communicate with each other.\n */\n\n/**\n * @typedef {Passable} Remotable\n * Might be an object explicitly declared to be `Remotable` using the\n * `Far` or `Remotable` functions, or a remote presence of a Remotable.\n */\n\n/**\n * @typedef {Promise | Remotable} PassableCap\n * The leaves of a Passable's pass-by-copy superstructure.\n */\n\n/**\n * @template T\n * @typedef {T[]} CopyArray\n */\n\n/**\n * @template T\n * @typedef {Record<string, T>} CopyRecord\n */\n\n/**\n * @typedef {{\n *   [PASS_STYLE]: 'tagged',\n *   [Symbol.toStringTag]: string,\n *   payload: Passable\n * }} CopyTagged\n *\n * The tag is the value of the `[String.toStringTag]` property.\n */\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @template Slot\n * @callback ConvertValToSlot\n * @param {PassableCap} val\n * @returns {Slot}\n */\n\n/**\n * @template Slot\n * @callback ConvertSlotToVal\n * @param {Slot} slot\n * @param {InterfaceSpec=} iface\n * @returns {PassableCap}\n */\n\n/**\n * @template T\n * @typedef {{ '@qclass': T }} EncodingClass\n */\n\n/**\n * @typedef {EncodingClass<'NaN'> |\n *           EncodingClass<'undefined'> |\n *           EncodingClass<'Infinity'> |\n *           EncodingClass<'-Infinity'> |\n *           EncodingClass<'bigint'> & { digits: string } |\n *           EncodingClass<'@@asyncIterator'> |\n *           EncodingClass<'symbol'> & { name: string } |\n *           EncodingClass<'error'> & { name: string,\n *                                      message: string,\n *                                      errorId?: string\n *           } |\n *           EncodingClass<'slot'> & { index: number, iface?: InterfaceSpec } |\n *           EncodingClass<'hilbert'> & { original: Encoding,\n *                                        rest?: Encoding\n *           } |\n *           EncodingClass<'tagged'> & { tag: string,\n *                                       payload: Encoding\n *           }\n * } EncodingUnion\n * @typedef {{ [index: string]: Encoding,\n *             '@qclass'?: undefined\n * }} EncodingRecord\n * We exclude '@qclass' as a property in encoding records.\n * @typedef {EncodingUnion | null | string |\n *           boolean | number | EncodingRecord\n * } EncodingElement\n */\n\n/**\n * @typedef {EncodingElement | NestedArray<EncodingElement>} Encoding\n * The JSON structure that the data portion of a Passable serializes to.\n *\n * The QCLASS 'hilbert' is a reference to the Hilbert Hotel\n * of https://www.ias.edu/ideas/2016/pires-hilbert-hotel\n * If QCLASS appears as a property name in the data, we encode it instead\n * as a QCLASS record of type 'hilbert'. To do so, we must move the other\n * parts of the record into fields of the hilbert record.\n */\n\n/**\n * @template Slot\n * @typedef {Object} CapData\n * @property {string} body A JSON.stringify of an Encoding\n * @property {Slot[]} slots\n */\n\n/**\n * @template Slot\n * @callback Serialize\n * @param {Passable} val\n * @returns {CapData<Slot>}\n */\n\n/**\n * @template Slot\n * @callback Unserialize\n * @param {CapData<Slot>} data\n * @returns {Passable}\n */\n\n/**\n * @template Slot\n * @typedef {Object} Marshal\n * @property {Serialize<Slot>} serialize\n * @property {Unserialize<Slot>} unserialize\n */\n\n/**\n * @typedef {Object} MakeMarshalOptions\n * @property {'on'|'off'=} errorTagging controls whether serialized errors\n * also carry tagging information, made from `marshalName` and numbers\n * generated (currently by counting) starting at `errorIdNum`. The\n * `errorTagging` option defaults to `'on'`. Serialized\n * errors are also logged to `marshalSaveError` only if tagging is `'on'`.\n * @property {string=} marshalName Used to identify sent errors.\n * @property {number=} errorIdNum Ascending numbers staring from here\n * identify the sending of errors relative to this marshal instance.\n * @property {(err: Error) => void=} marshalSaveError If `errorTagging` is\n * `'on'`, then errors serialized by this marshal instance are also\n * logged by calling `marshalSaveError` *after* `assert.note` associated\n * that error with its errorId. Thus, if `marshalSaveError` in turn logs\n * to the normal console, which is the default, then the console will\n * show that note showing the associated errorId.\n */\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * @typedef {string} InterfaceSpec\n * This is an interface specification.\n * For now, it is just a string, but will eventually be `PureData`. Either\n * way, it must remain pure, so that it can be safely shared by subgraphs that\n * are not supposed to be able to communicate.\n */\n\n/**\n * @callback MarshalGetInterfaceOf\n * Simple semantics, just tell what interface (or undefined) a remotable has.\n * @param {*} maybeRemotable the value to check\n * @returns {InterfaceSpec|undefined} the interface specification, or undefined\n * if not a deemed to be a Remotable\n */\n\n/**\n * @callback Checker\n * Internal to a useful pattern for writing checking logic\n * (a \"checkFoo\" function) that can be used to implement a predicate\n * (an \"isFoo\" function) or a validator (an \"assertFoo\" function).\n *\n *    * A predicate ideally only returns `true` or `false` and rarely throws.\n *    * A validator throws an informative diagnostic when the predicate\n *      would have returned `false`, and simply returns `undefined` normally\n *      when the predicate would have returned `true`.\n *    * The internal checking function that they share is parameterized by a\n *      `Checker` that determines how to proceed with a failure condition.\n *      Predicates pass in an identity function as checker. Validators\n *      pass in `assertChecker` which is a trivial wrapper around `assert`.\n *\n * See the various uses for good examples.\n * @param {boolean} cond\n * @param {Details=} details\n * @returns {boolean}\n */\n"],"mappings":"AAAA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module"}