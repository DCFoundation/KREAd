{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { E } from '@endo/eventual-send';\nimport { isPromise } from '@endo/promise-kit';\nimport { getTag, isObject } from './helpers/passStyle-helpers.js';\nimport { makeTagged } from './makeTagged.js';\nimport { passStyleOf } from './passStyleOf.js';\n/** @typedef {import('./types.js').Passable} Passable */\n\n/** @template T @typedef {import('@endo/eventual-send').ERef<T>} ERef */\n\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  ownKeys\n} = Reflect;\nconst {\n  fromEntries\n} = Object;\n/**\n * Given a Passable `val` whose pass-by-copy structure may contain leaf\n * promises, return either a replacement Passable, or a promise for that\n * replacement, where that replacement is *deeply fulfilled*, i.e., its\n * pass-by-copy structure does not contain any promises.\n *\n * This is a deep form of `Promise.all` specialized for Passables. For each\n * encountered promise, replace it with the deeply fulfilled form of\n * its fulfillment.\n * If any of the promises reject, then the promise for the replacement\n * rejects. If any of the promises never settle, then the promise for\n * the replacement never settles.\n *\n * If `val` or its parts are non-key passables *because* they contains\n * promises, the deeply fulfilled forms of val or its parts may be keys. This\n * is for the higher \"store\" level of abstraction to determine, because it\n * defines the \"key\" notion in question.\n *\n * @param {Passable} val\n * @returns {ERef<Passable>}\n */\n\nexport const deeplyFulfilled = val => {\n  if (!isObject(val)) {\n    return val;\n  }\n\n  if (isPromise(val)) {\n    return E.when(val, nonp => deeplyFulfilled(nonp));\n  }\n\n  const passStyle = passStyleOf(val);\n\n  switch (passStyle) {\n    case 'copyRecord':\n      {\n        const names = ownKeys(val);\n        const valPs = names.map(name => deeplyFulfilled(val[name]));\n        return E.when(Promise.all(valPs), vals => harden(fromEntries(vals.map((c, i) => [names[i], c]))));\n      }\n\n    case 'copyArray':\n      {\n        const valPs = val.map(p => deeplyFulfilled(p));\n        return E.when(Promise.all(valPs), vals => harden(vals));\n      }\n\n    case 'tagged':\n      {\n        const tag = getTag(val);\n        return E.when(deeplyFulfilled(val.payload), payload => makeTagged(tag, payload));\n      }\n\n    case 'remotable':\n      {\n        return val;\n      }\n\n    case 'error':\n      {\n        return val;\n      }\n\n    case 'promise':\n      {\n        return E.when(val, nonp => deeplyFulfilled(nonp));\n      }\n\n    default:\n      {\n        assert.fail(X`Unexpected passStyle ${q(passStyle)}`, TypeError);\n      }\n  }\n};\nharden(deeplyFulfilled);","map":{"version":3,"names":["E","isPromise","getTag","isObject","makeTagged","passStyleOf","details","X","quote","q","assert","ownKeys","Reflect","fromEntries","Object","deeplyFulfilled","val","when","nonp","passStyle","names","valPs","map","name","Promise","all","vals","harden","c","i","p","tag","payload","fail","TypeError"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/deeplyFulfilled.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport { E } from '@endo/eventual-send';\nimport { isPromise } from '@endo/promise-kit';\nimport { getTag, isObject } from './helpers/passStyle-helpers.js';\nimport { makeTagged } from './makeTagged.js';\nimport { passStyleOf } from './passStyleOf.js';\n\n/** @typedef {import('./types.js').Passable} Passable */\n/** @template T @typedef {import('@endo/eventual-send').ERef<T>} ERef */\n\nconst { details: X, quote: q } = assert;\nconst { ownKeys } = Reflect;\nconst { fromEntries } = Object;\n\n/**\n * Given a Passable `val` whose pass-by-copy structure may contain leaf\n * promises, return either a replacement Passable, or a promise for that\n * replacement, where that replacement is *deeply fulfilled*, i.e., its\n * pass-by-copy structure does not contain any promises.\n *\n * This is a deep form of `Promise.all` specialized for Passables. For each\n * encountered promise, replace it with the deeply fulfilled form of\n * its fulfillment.\n * If any of the promises reject, then the promise for the replacement\n * rejects. If any of the promises never settle, then the promise for\n * the replacement never settles.\n *\n * If `val` or its parts are non-key passables *because* they contains\n * promises, the deeply fulfilled forms of val or its parts may be keys. This\n * is for the higher \"store\" level of abstraction to determine, because it\n * defines the \"key\" notion in question.\n *\n * @param {Passable} val\n * @returns {ERef<Passable>}\n */\nexport const deeplyFulfilled = val => {\n  if (!isObject(val)) {\n    return val;\n  }\n  if (isPromise(val)) {\n    return E.when(val, nonp => deeplyFulfilled(nonp));\n  }\n  const passStyle = passStyleOf(val);\n  switch (passStyle) {\n    case 'copyRecord': {\n      const names = ownKeys(val);\n      const valPs = names.map(name => deeplyFulfilled(val[name]));\n      return E.when(Promise.all(valPs), vals =>\n        harden(fromEntries(vals.map((c, i) => [names[i], c]))),\n      );\n    }\n    case 'copyArray': {\n      const valPs = val.map(p => deeplyFulfilled(p));\n      return E.when(Promise.all(valPs), vals => harden(vals));\n    }\n    case 'tagged': {\n      const tag = getTag(val);\n      return E.when(deeplyFulfilled(val.payload), payload =>\n        makeTagged(tag, payload),\n      );\n    }\n    case 'remotable': {\n      return val;\n    }\n    case 'error': {\n      return val;\n    }\n    case 'promise': {\n      return E.when(val, nonp => deeplyFulfilled(nonp));\n    }\n    default: {\n      assert.fail(X`Unexpected passStyle ${q(passStyle)}`, TypeError);\n    }\n  }\n};\nharden(deeplyFulfilled);\n"],"mappings":"AAAA;AAEA;AAEA,SAASA,CAAT,QAAkB,qBAAlB;AACA,SAASC,SAAT,QAA0B,mBAA1B;AACA,SAASC,MAAT,EAAiBC,QAAjB,QAAiC,gCAAjC;AACA,SAASC,UAAT,QAA2B,iBAA3B;AACA,SAASC,WAAT,QAA4B,kBAA5B;AAEA;;AACA;;AAEA,MAAM;EAAEC,OAAO,EAAEC,CAAX;EAAcC,KAAK,EAAEC;AAArB,IAA2BC,MAAjC;AACA,MAAM;EAAEC;AAAF,IAAcC,OAApB;AACA,MAAM;EAAEC;AAAF,IAAkBC,MAAxB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,eAAe,GAAGC,GAAG,IAAI;EACpC,IAAI,CAACb,QAAQ,CAACa,GAAD,CAAb,EAAoB;IAClB,OAAOA,GAAP;EACD;;EACD,IAAIf,SAAS,CAACe,GAAD,CAAb,EAAoB;IAClB,OAAOhB,CAAC,CAACiB,IAAF,CAAOD,GAAP,EAAYE,IAAI,IAAIH,eAAe,CAACG,IAAD,CAAnC,CAAP;EACD;;EACD,MAAMC,SAAS,GAAGd,WAAW,CAACW,GAAD,CAA7B;;EACA,QAAQG,SAAR;IACE,KAAK,YAAL;MAAmB;QACjB,MAAMC,KAAK,GAAGT,OAAO,CAACK,GAAD,CAArB;QACA,MAAMK,KAAK,GAAGD,KAAK,CAACE,GAAN,CAAUC,IAAI,IAAIR,eAAe,CAACC,GAAG,CAACO,IAAD,CAAJ,CAAjC,CAAd;QACA,OAAOvB,CAAC,CAACiB,IAAF,CAAOO,OAAO,CAACC,GAAR,CAAYJ,KAAZ,CAAP,EAA2BK,IAAI,IACpCC,MAAM,CAACd,WAAW,CAACa,IAAI,CAACJ,GAAL,CAAS,CAACM,CAAD,EAAIC,CAAJ,KAAU,CAACT,KAAK,CAACS,CAAD,CAAN,EAAWD,CAAX,CAAnB,CAAD,CAAZ,CADD,CAAP;MAGD;;IACD,KAAK,WAAL;MAAkB;QAChB,MAAMP,KAAK,GAAGL,GAAG,CAACM,GAAJ,CAAQQ,CAAC,IAAIf,eAAe,CAACe,CAAD,CAA5B,CAAd;QACA,OAAO9B,CAAC,CAACiB,IAAF,CAAOO,OAAO,CAACC,GAAR,CAAYJ,KAAZ,CAAP,EAA2BK,IAAI,IAAIC,MAAM,CAACD,IAAD,CAAzC,CAAP;MACD;;IACD,KAAK,QAAL;MAAe;QACb,MAAMK,GAAG,GAAG7B,MAAM,CAACc,GAAD,CAAlB;QACA,OAAOhB,CAAC,CAACiB,IAAF,CAAOF,eAAe,CAACC,GAAG,CAACgB,OAAL,CAAtB,EAAqCA,OAAO,IACjD5B,UAAU,CAAC2B,GAAD,EAAMC,OAAN,CADL,CAAP;MAGD;;IACD,KAAK,WAAL;MAAkB;QAChB,OAAOhB,GAAP;MACD;;IACD,KAAK,OAAL;MAAc;QACZ,OAAOA,GAAP;MACD;;IACD,KAAK,SAAL;MAAgB;QACd,OAAOhB,CAAC,CAACiB,IAAF,CAAOD,GAAP,EAAYE,IAAI,IAAIH,eAAe,CAACG,IAAD,CAAnC,CAAP;MACD;;IACD;MAAS;QACPR,MAAM,CAACuB,IAAP,CAAY1B,CAAE,wBAAuBE,CAAC,CAACU,SAAD,CAAY,EAAlD,EAAqDe,SAArD;MACD;EA7BH;AA+BD,CAvCM;AAwCPP,MAAM,CAACZ,eAAD,CAAN"},"metadata":{},"sourceType":"module"}