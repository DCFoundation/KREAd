{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { isPromise } from '@endo/promise-kit';\nimport { isObject, PASS_STYLE } from './helpers/passStyle-helpers.js';\nimport { CopyArrayHelper } from './helpers/copyArray.js';\nimport { CopyRecordHelper } from './helpers/copyRecord.js';\nimport { TaggedHelper } from './helpers/tagged.js';\nimport { RemotableHelper } from './helpers/remotable.js';\nimport { ErrorHelper } from './helpers/error.js';\nimport { assertPassableSymbol } from './helpers/symbol.js';\n/** @typedef {import('./helpers/internal-types.js').PassStyleHelper} PassStyleHelper */\n\n/** @typedef {import('./types.js').Passable} Passable */\n\n/** @typedef {import('./types.js').PassStyle} PassStyle */\n\n/** @typedef {import('./types.js').PassStyleOf} PassStyleOf */\n\n/** @typedef {import('./types.js').PrimitiveStyle} PrimitiveStyle */\n\n/** @typedef {Exclude<PassStyle, PrimitiveStyle | \"promise\">} HelperPassStyle */\n\nconst {\n  details: X,\n  quote: q\n} = assert;\nconst {\n  ownKeys\n} = Reflect;\nconst {\n  isFrozen\n} = Object;\n/**\n * @param {PassStyleHelper[]} passStyleHelpers\n * @returns {Record<HelperPassStyle, PassStyleHelper> }\n */\n\nconst makeHelperTable = passStyleHelpers => {\n  /** @type {Record<HelperPassStyle, any> & {__proto__: null}} */\n  const HelperTable = {\n    __proto__: null,\n    copyArray: undefined,\n    copyRecord: undefined,\n    tagged: undefined,\n    remotable: undefined,\n    error: undefined\n  };\n\n  for (const helper of passStyleHelpers) {\n    const {\n      styleName\n    } = helper;\n    assert(styleName in HelperTable, X`Unrecognized helper: ${q(styleName)}`);\n    assert.equal(HelperTable[styleName], undefined, X`conflicting helpers for ${q(styleName)}`);\n    HelperTable[styleName] = helper;\n  }\n\n  for (const styleName of ownKeys(HelperTable)) {\n    assert(HelperTable[styleName] !== undefined, X`missing helper for ${q(styleName)}`);\n  }\n\n  return harden(HelperTable);\n};\n/**\n * @param {PassStyleHelper[]} passStyleHelpers The passStyleHelpers to register,\n * in priority order.\n * NOTE These must all be \"trusted\",\n * complete, and non-colliding. `makePassStyleOf` may *assume* that each helper\n * does what it is supposed to do. `makePassStyleOf` is not trying to defend\n * itself against malicious helpers, though it does defend against some\n * accidents.\n * @returns {PassStyleOf}\n */\n\n\nconst makePassStyleOf = passStyleHelpers => {\n  const HelperTable = makeHelperTable(passStyleHelpers);\n  const remotableHelper = HelperTable.remotable;\n  /**\n   * Purely for performance. However it is mutable static state, and\n   * it does have some observability on proxies. TODO need to assess\n   * whether this creates a static communications channel.\n   *\n   * passStyleOf does a full recursive walk of pass-by-copy\n   * structures, in order to validate that they are acyclic. In addition\n   * it is used by other algorithms to recursively walk these pass-by-copy\n   * structures, so without this cache, these algorithms could be\n   * O(N**2) or worse.\n   *\n   * @type {WeakMap<Passable, PassStyle>}\n   */\n\n  const passStyleMemo = new WeakMap();\n  /**\n   * @type {PassStyleOf}\n   */\n\n  const passStyleOf = passable => {\n    // Even when a WeakSet is correct, when the set has a shorter lifetime\n    // than its keys, we prefer a Set due to expected implementation\n    // tradeoffs.\n    const inProgress = new Set();\n    /**\n     * @type {PassStyleOf}\n     */\n\n    const passStyleOfRecur = inner => {\n      const innerIsObject = isObject(inner);\n\n      if (innerIsObject) {\n        if (passStyleMemo.has(inner)) {\n          // @ts-ignore TypeScript doesn't know that `get` after `has` is safe\n          return passStyleMemo.get(inner);\n        }\n\n        assert(!inProgress.has(inner), X`Pass-by-copy data cannot be cyclic ${inner}`);\n        inProgress.add(inner);\n      } // eslint-disable-next-line no-use-before-define\n\n\n      const passStyle = passStyleOfInternal(inner);\n\n      if (innerIsObject) {\n        passStyleMemo.set(inner, passStyle);\n        inProgress.delete(inner);\n      }\n\n      return passStyle;\n    };\n    /**\n     * @type {PassStyleOf}\n     */\n\n\n    const passStyleOfInternal = inner => {\n      const typestr = typeof inner;\n\n      switch (typestr) {\n        case 'undefined':\n        case 'string':\n        case 'boolean':\n        case 'number':\n        case 'bigint':\n          {\n            return typestr;\n          }\n\n        case 'symbol':\n          {\n            assertPassableSymbol(inner);\n            return 'symbol';\n          }\n\n        case 'object':\n          {\n            if (inner === null) {\n              return 'null';\n            }\n\n            assert(isFrozen(inner), X`Cannot pass non-frozen objects like ${inner}. Use harden()`);\n\n            if (isPromise(inner)) {\n              return 'promise';\n            }\n\n            assert(typeof inner.then !== 'function', X`Cannot pass non-promise thenables`);\n            const passStyleTag = inner[PASS_STYLE];\n\n            if (passStyleTag !== undefined) {\n              assert.typeof(passStyleTag, 'string');\n              const helper = HelperTable[passStyleTag];\n              assert(helper !== undefined, X`Unrecognized PassStyle: ${q(passStyleTag)}`);\n              helper.assertValid(inner, passStyleOfRecur);\n              return (\n                /** @type {PassStyle} */\n                passStyleTag\n              );\n            }\n\n            for (const helper of passStyleHelpers) {\n              if (helper.canBeValid(inner)) {\n                helper.assertValid(inner, passStyleOfRecur);\n                return helper.styleName;\n              }\n            }\n\n            remotableHelper.assertValid(inner, passStyleOfRecur);\n            return 'remotable';\n          }\n\n        case 'function':\n          {\n            assert(isFrozen(inner), X`Cannot pass non-frozen objects like ${inner}. Use harden()`);\n            assert(typeof inner.then !== 'function', X`Cannot pass non-promise thenables`);\n            remotableHelper.assertValid(inner, passStyleOfRecur);\n            return 'remotable';\n          }\n\n        default:\n          {\n            assert.fail(X`Unrecognized typeof ${q(typestr)}`, TypeError);\n          }\n      }\n    };\n\n    return passStyleOfRecur(passable);\n  };\n\n  return harden(passStyleOf);\n};\n\nexport const passStyleOf = makePassStyleOf([CopyArrayHelper, CopyRecordHelper, TaggedHelper, RemotableHelper, ErrorHelper]);\nexport const assertPassable = val => {\n  passStyleOf(val); // throws if val is not a passable\n};\nharden(assertPassable);","map":{"version":3,"names":["isPromise","isObject","PASS_STYLE","CopyArrayHelper","CopyRecordHelper","TaggedHelper","RemotableHelper","ErrorHelper","assertPassableSymbol","details","X","quote","q","assert","ownKeys","Reflect","isFrozen","Object","makeHelperTable","passStyleHelpers","HelperTable","__proto__","copyArray","undefined","copyRecord","tagged","remotable","error","helper","styleName","equal","harden","makePassStyleOf","remotableHelper","passStyleMemo","WeakMap","passStyleOf","passable","inProgress","Set","passStyleOfRecur","inner","innerIsObject","has","get","add","passStyle","passStyleOfInternal","set","delete","typestr","then","passStyleTag","typeof","assertValid","canBeValid","fail","TypeError","assertPassable","val"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/passStyleOf.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport { isPromise } from '@endo/promise-kit';\nimport { isObject, PASS_STYLE } from './helpers/passStyle-helpers.js';\n\nimport { CopyArrayHelper } from './helpers/copyArray.js';\nimport { CopyRecordHelper } from './helpers/copyRecord.js';\nimport { TaggedHelper } from './helpers/tagged.js';\nimport { RemotableHelper } from './helpers/remotable.js';\nimport { ErrorHelper } from './helpers/error.js';\n\nimport { assertPassableSymbol } from './helpers/symbol.js';\n\n/** @typedef {import('./helpers/internal-types.js').PassStyleHelper} PassStyleHelper */\n/** @typedef {import('./types.js').Passable} Passable */\n/** @typedef {import('./types.js').PassStyle} PassStyle */\n/** @typedef {import('./types.js').PassStyleOf} PassStyleOf */\n/** @typedef {import('./types.js').PrimitiveStyle} PrimitiveStyle */\n\n/** @typedef {Exclude<PassStyle, PrimitiveStyle | \"promise\">} HelperPassStyle */\n\nconst { details: X, quote: q } = assert;\nconst { ownKeys } = Reflect;\nconst { isFrozen } = Object;\n\n/**\n * @param {PassStyleHelper[]} passStyleHelpers\n * @returns {Record<HelperPassStyle, PassStyleHelper> }\n */\n\nconst makeHelperTable = passStyleHelpers => {\n  /** @type {Record<HelperPassStyle, any> & {__proto__: null}} */\n  const HelperTable = {\n    __proto__: null,\n    copyArray: undefined,\n    copyRecord: undefined,\n    tagged: undefined,\n    remotable: undefined,\n    error: undefined,\n  };\n  for (const helper of passStyleHelpers) {\n    const { styleName } = helper;\n    assert(styleName in HelperTable, X`Unrecognized helper: ${q(styleName)}`);\n    assert.equal(\n      HelperTable[styleName],\n      undefined,\n      X`conflicting helpers for ${q(styleName)}`,\n    );\n    HelperTable[styleName] = helper;\n  }\n  for (const styleName of ownKeys(HelperTable)) {\n    assert(\n      HelperTable[styleName] !== undefined,\n      X`missing helper for ${q(styleName)}`,\n    );\n  }\n\n  return harden(HelperTable);\n};\n\n/**\n * @param {PassStyleHelper[]} passStyleHelpers The passStyleHelpers to register,\n * in priority order.\n * NOTE These must all be \"trusted\",\n * complete, and non-colliding. `makePassStyleOf` may *assume* that each helper\n * does what it is supposed to do. `makePassStyleOf` is not trying to defend\n * itself against malicious helpers, though it does defend against some\n * accidents.\n * @returns {PassStyleOf}\n */\nconst makePassStyleOf = passStyleHelpers => {\n  const HelperTable = makeHelperTable(passStyleHelpers);\n  const remotableHelper = HelperTable.remotable;\n\n  /**\n   * Purely for performance. However it is mutable static state, and\n   * it does have some observability on proxies. TODO need to assess\n   * whether this creates a static communications channel.\n   *\n   * passStyleOf does a full recursive walk of pass-by-copy\n   * structures, in order to validate that they are acyclic. In addition\n   * it is used by other algorithms to recursively walk these pass-by-copy\n   * structures, so without this cache, these algorithms could be\n   * O(N**2) or worse.\n   *\n   * @type {WeakMap<Passable, PassStyle>}\n   */\n  const passStyleMemo = new WeakMap();\n\n  /**\n   * @type {PassStyleOf}\n   */\n  const passStyleOf = passable => {\n    // Even when a WeakSet is correct, when the set has a shorter lifetime\n    // than its keys, we prefer a Set due to expected implementation\n    // tradeoffs.\n    const inProgress = new Set();\n\n    /**\n     * @type {PassStyleOf}\n     */\n    const passStyleOfRecur = inner => {\n      const innerIsObject = isObject(inner);\n      if (innerIsObject) {\n        if (passStyleMemo.has(inner)) {\n          // @ts-ignore TypeScript doesn't know that `get` after `has` is safe\n          return passStyleMemo.get(inner);\n        }\n        assert(\n          !inProgress.has(inner),\n          X`Pass-by-copy data cannot be cyclic ${inner}`,\n        );\n        inProgress.add(inner);\n      }\n      // eslint-disable-next-line no-use-before-define\n      const passStyle = passStyleOfInternal(inner);\n      if (innerIsObject) {\n        passStyleMemo.set(inner, passStyle);\n        inProgress.delete(inner);\n      }\n      return passStyle;\n    };\n\n    /**\n     * @type {PassStyleOf}\n     */\n    const passStyleOfInternal = inner => {\n      const typestr = typeof inner;\n      switch (typestr) {\n        case 'undefined':\n        case 'string':\n        case 'boolean':\n        case 'number':\n        case 'bigint': {\n          return typestr;\n        }\n        case 'symbol': {\n          assertPassableSymbol(inner);\n          return 'symbol';\n        }\n        case 'object': {\n          if (inner === null) {\n            return 'null';\n          }\n          assert(\n            isFrozen(inner),\n            X`Cannot pass non-frozen objects like ${inner}. Use harden()`,\n          );\n          if (isPromise(inner)) {\n            return 'promise';\n          }\n          assert(\n            typeof inner.then !== 'function',\n            X`Cannot pass non-promise thenables`,\n          );\n          const passStyleTag = inner[PASS_STYLE];\n          if (passStyleTag !== undefined) {\n            assert.typeof(passStyleTag, 'string');\n            const helper = HelperTable[passStyleTag];\n            assert(\n              helper !== undefined,\n              X`Unrecognized PassStyle: ${q(passStyleTag)}`,\n            );\n            helper.assertValid(inner, passStyleOfRecur);\n            return /** @type {PassStyle} */ (passStyleTag);\n          }\n          for (const helper of passStyleHelpers) {\n            if (helper.canBeValid(inner)) {\n              helper.assertValid(inner, passStyleOfRecur);\n              return helper.styleName;\n            }\n          }\n          remotableHelper.assertValid(inner, passStyleOfRecur);\n          return 'remotable';\n        }\n        case 'function': {\n          assert(\n            isFrozen(inner),\n            X`Cannot pass non-frozen objects like ${inner}. Use harden()`,\n          );\n          assert(\n            typeof inner.then !== 'function',\n            X`Cannot pass non-promise thenables`,\n          );\n          remotableHelper.assertValid(inner, passStyleOfRecur);\n          return 'remotable';\n        }\n        default: {\n          assert.fail(X`Unrecognized typeof ${q(typestr)}`, TypeError);\n        }\n      }\n    };\n\n    return passStyleOfRecur(passable);\n  };\n  return harden(passStyleOf);\n};\n\nexport const passStyleOf = makePassStyleOf([\n  CopyArrayHelper,\n  CopyRecordHelper,\n  TaggedHelper,\n  RemotableHelper,\n  ErrorHelper,\n]);\n\nexport const assertPassable = val => {\n  passStyleOf(val); // throws if val is not a passable\n};\nharden(assertPassable);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}