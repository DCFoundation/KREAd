{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { assertChecker, PASS_STYLE } from './helpers/passStyle-helpers.js';\nimport { assertIface, getInterfaceOf, RemotableHelper } from './helpers/remotable.js';\n/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */\n\n/** @template L,R @typedef {import('@endo/eventual-send').RemotableBrand<L, R>} RemotableBrand */\n\nconst {\n  quote: q,\n  details: X\n} = assert;\nconst {\n  prototype: functionPrototype\n} = Function;\nconst {\n  getPrototypeOf,\n  setPrototypeOf,\n  create,\n  isFrozen,\n  prototype: objectPrototype\n} = Object;\n/**\n * Now that the remotableProto does not provide its own `toString` method,\n * ensure it always inherits from something. The original prototype of\n * `remotable` if there was one, or `Object.prototype` otherwise.\n *\n * @param {Object} remotable\n * @param {InterfaceSpec} iface\n * @returns {Object}\n */\n\nconst makeRemotableProto = (remotable, iface) => {\n  let oldProto = getPrototypeOf(remotable);\n\n  if (typeof remotable === 'object') {\n    if (oldProto === null) {\n      oldProto = objectPrototype;\n    }\n\n    assert(oldProto === objectPrototype || oldProto === null, X`For now, remotables cannot inherit from anything unusual, in ${remotable}`);\n  } else if (typeof remotable === 'function') {\n    assert(oldProto !== null, X`Original function must not inherit from null: ${remotable}`);\n    assert(oldProto === functionPrototype || getPrototypeOf(oldProto) === functionPrototype, X`Far functions must originally inherit from Function.prototype, in ${remotable}`);\n  } else {\n    assert.fail(X`unrecognized typeof ${remotable}`);\n  }\n\n  return harden(create(oldProto, {\n    [PASS_STYLE]: {\n      value: 'remotable'\n    },\n    [Symbol.toStringTag]: {\n      value: iface\n    }\n  }));\n};\n\nconst assertCanBeRemotable = candidate => RemotableHelper.canBeValid(candidate, assertChecker);\n/**\n * Create and register a Remotable.  After this, getInterfaceOf(remotable)\n * returns iface.\n *\n * // https://github.com/Agoric/agoric-sdk/issues/804\n *\n * @template T\n * @param {InterfaceSpec} [iface='Remotable'] The interface specification for\n * the remotable. For now, a string iface must be \"Remotable\" or begin with\n * \"Alleged: \", to serve as the alleged name. More general ifaces are not yet\n * implemented. This is temporary. We include the\n * \"Alleged\" as a reminder that we do not yet have SwingSet or Comms Vat\n * support for ensuring this is according to the vat hosting the object.\n * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)\n * misrepresents Carol's `iface`. VatB and therefore Bob will then see\n * Carol's `iface` as misrepresented by VatA.\n * @param {undefined} [props=undefined] Currently may only be undefined.\n * That plan is that own-properties are copied to the remotable\n * @param {T} [remotable={}] The object used as the remotable\n * @returns {T & RemotableBrand<{}, T>} remotable, modified for debuggability\n */\n\n\nexport const Remotable = function () {\n  let iface = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Remotable';\n  let props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  let remotable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] :\n  /** @type {T} */\n  {};\n  assertIface(iface);\n  assert(iface); // TODO: When iface is richer than just string, we need to get the allegedName\n  // in a different way.\n\n  assert(props === undefined, X`Remotable props not yet implemented ${props}`); // Fail fast: check that the unmodified object is able to become a Remotable.\n\n  assertCanBeRemotable(remotable); // Ensure that the remotable isn't already marked.\n\n  assert(!(PASS_STYLE in remotable), X`Remotable ${remotable} is already marked as a ${q(remotable[PASS_STYLE])}`); // Ensure that the remotable isn't already frozen.\n\n  assert(!isFrozen(remotable), X`Remotable ${remotable} is already frozen`);\n  const remotableProto = makeRemotableProto(remotable, iface); // Take a static copy of the enumerable own properties as data properties.\n  // const propDescs = getOwnPropertyDescriptors({ ...props });\n\n  const mutateHardenAndCheck = target => {\n    // defineProperties(target, propDescs);\n    setPrototypeOf(target, remotableProto);\n    harden(target);\n    assertCanBeRemotable(target);\n  }; // Fail fast: check a fresh remotable to see if our rules fit.\n\n\n  mutateHardenAndCheck({}); // Actually finish the new remotable.\n\n  mutateHardenAndCheck(remotable); // COMMITTED!\n  // We're committed, so keep the interface for future reference.\n\n  assert(iface !== undefined); // To make TypeScript happy\n\n  return (\n    /** @type {T & RemotableBrand<{}, T>} */\n    remotable\n  );\n};\nharden(Remotable);\n/**\n * A concise convenience for the most common `Remotable` use.\n *\n * @template T\n * @param {string} farName This name will be prepended with `Alleged: `\n * for now to form the `Remotable` `iface` argument.\n * @param {T} [remotable={}] The object used as the remotable\n */\n\nexport const Far = function (farName) {\n  let remotable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n  const r = remotable === undefined ?\n  /** @type {T} */\n  {} : remotable;\n  return Remotable(`Alleged: ${farName}`, undefined, r);\n};\nharden(Far);\n/**\n * Coerce `func` to a far function that preserves its call behavior.\n * If it is already a far function, return it. Otherwise make and return a\n * new far function that wraps `func` and forwards calls to it. This\n * works even if `func` is already frozen. `ToFarFunction` is to be used\n * when the function comes from elsewhere under less control. For functions\n * you author in place, better to use `Far` on their function literal directly.\n *\n * @param {string} farName to be used only if `func` is not already a\n * far function.\n * @param {(...args: any[]) => any} func\n */\n\nexport const ToFarFunction = (farName, func) => {\n  if (getInterfaceOf(func) !== undefined) {\n    return func;\n  }\n\n  return Far(farName, function () {\n    return func(...arguments);\n  });\n};\nharden(ToFarFunction);","map":{"version":3,"names":["assertChecker","PASS_STYLE","assertIface","getInterfaceOf","RemotableHelper","quote","q","details","X","assert","prototype","functionPrototype","Function","getPrototypeOf","setPrototypeOf","create","isFrozen","objectPrototype","Object","makeRemotableProto","remotable","iface","oldProto","fail","harden","value","Symbol","toStringTag","assertCanBeRemotable","candidate","canBeValid","Remotable","props","undefined","remotableProto","mutateHardenAndCheck","target","Far","farName","r","ToFarFunction","func"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/make-far.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport { assertChecker, PASS_STYLE } from './helpers/passStyle-helpers.js';\nimport {\n  assertIface,\n  getInterfaceOf,\n  RemotableHelper,\n} from './helpers/remotable.js';\n\n/** @typedef {import('./types.js').InterfaceSpec} InterfaceSpec */\n/** @template L,R @typedef {import('@endo/eventual-send').RemotableBrand<L, R>} RemotableBrand */\n\nconst { quote: q, details: X } = assert;\n\nconst { prototype: functionPrototype } = Function;\nconst {\n  getPrototypeOf,\n  setPrototypeOf,\n  create,\n  isFrozen,\n  prototype: objectPrototype,\n} = Object;\n\n/**\n * Now that the remotableProto does not provide its own `toString` method,\n * ensure it always inherits from something. The original prototype of\n * `remotable` if there was one, or `Object.prototype` otherwise.\n *\n * @param {Object} remotable\n * @param {InterfaceSpec} iface\n * @returns {Object}\n */\nconst makeRemotableProto = (remotable, iface) => {\n  let oldProto = getPrototypeOf(remotable);\n  if (typeof remotable === 'object') {\n    if (oldProto === null) {\n      oldProto = objectPrototype;\n    }\n    assert(\n      oldProto === objectPrototype || oldProto === null,\n      X`For now, remotables cannot inherit from anything unusual, in ${remotable}`,\n    );\n  } else if (typeof remotable === 'function') {\n    assert(\n      oldProto !== null,\n      X`Original function must not inherit from null: ${remotable}`,\n    );\n    assert(\n      oldProto === functionPrototype ||\n        getPrototypeOf(oldProto) === functionPrototype,\n      X`Far functions must originally inherit from Function.prototype, in ${remotable}`,\n    );\n  } else {\n    assert.fail(X`unrecognized typeof ${remotable}`);\n  }\n  return harden(\n    create(oldProto, {\n      [PASS_STYLE]: { value: 'remotable' },\n      [Symbol.toStringTag]: { value: iface },\n    }),\n  );\n};\n\nconst assertCanBeRemotable = candidate =>\n  RemotableHelper.canBeValid(candidate, assertChecker);\n\n/**\n * Create and register a Remotable.  After this, getInterfaceOf(remotable)\n * returns iface.\n *\n * // https://github.com/Agoric/agoric-sdk/issues/804\n *\n * @template T\n * @param {InterfaceSpec} [iface='Remotable'] The interface specification for\n * the remotable. For now, a string iface must be \"Remotable\" or begin with\n * \"Alleged: \", to serve as the alleged name. More general ifaces are not yet\n * implemented. This is temporary. We include the\n * \"Alleged\" as a reminder that we do not yet have SwingSet or Comms Vat\n * support for ensuring this is according to the vat hosting the object.\n * Currently, Alice can tell Bob about Carol, where VatA (on Alice's behalf)\n * misrepresents Carol's `iface`. VatB and therefore Bob will then see\n * Carol's `iface` as misrepresented by VatA.\n * @param {undefined} [props=undefined] Currently may only be undefined.\n * That plan is that own-properties are copied to the remotable\n * @param {T} [remotable={}] The object used as the remotable\n * @returns {T & RemotableBrand<{}, T>} remotable, modified for debuggability\n */\nexport const Remotable = (\n  iface = 'Remotable',\n  props = undefined,\n  remotable = /** @type {T} */ ({}),\n) => {\n  assertIface(iface);\n  assert(iface);\n  // TODO: When iface is richer than just string, we need to get the allegedName\n  // in a different way.\n  assert(props === undefined, X`Remotable props not yet implemented ${props}`);\n\n  // Fail fast: check that the unmodified object is able to become a Remotable.\n  assertCanBeRemotable(remotable);\n\n  // Ensure that the remotable isn't already marked.\n  assert(\n    !(PASS_STYLE in remotable),\n    X`Remotable ${remotable} is already marked as a ${q(\n      remotable[PASS_STYLE],\n    )}`,\n  );\n  // Ensure that the remotable isn't already frozen.\n  assert(!isFrozen(remotable), X`Remotable ${remotable} is already frozen`);\n  const remotableProto = makeRemotableProto(remotable, iface);\n\n  // Take a static copy of the enumerable own properties as data properties.\n  // const propDescs = getOwnPropertyDescriptors({ ...props });\n  const mutateHardenAndCheck = target => {\n    // defineProperties(target, propDescs);\n    setPrototypeOf(target, remotableProto);\n    harden(target);\n    assertCanBeRemotable(target);\n  };\n\n  // Fail fast: check a fresh remotable to see if our rules fit.\n  mutateHardenAndCheck({});\n\n  // Actually finish the new remotable.\n  mutateHardenAndCheck(remotable);\n\n  // COMMITTED!\n  // We're committed, so keep the interface for future reference.\n  assert(iface !== undefined); // To make TypeScript happy\n  return /** @type {T & RemotableBrand<{}, T>} */ (remotable);\n};\nharden(Remotable);\n\n/**\n * A concise convenience for the most common `Remotable` use.\n *\n * @template T\n * @param {string} farName This name will be prepended with `Alleged: `\n * for now to form the `Remotable` `iface` argument.\n * @param {T} [remotable={}] The object used as the remotable\n */\nexport const Far = (farName, remotable = undefined) => {\n  const r = remotable === undefined ? /** @type {T} */ ({}) : remotable;\n  return Remotable(`Alleged: ${farName}`, undefined, r);\n};\nharden(Far);\n\n/**\n * Coerce `func` to a far function that preserves its call behavior.\n * If it is already a far function, return it. Otherwise make and return a\n * new far function that wraps `func` and forwards calls to it. This\n * works even if `func` is already frozen. `ToFarFunction` is to be used\n * when the function comes from elsewhere under less control. For functions\n * you author in place, better to use `Far` on their function literal directly.\n *\n * @param {string} farName to be used only if `func` is not already a\n * far function.\n * @param {(...args: any[]) => any} func\n */\nexport const ToFarFunction = (farName, func) => {\n  if (getInterfaceOf(func) !== undefined) {\n    return func;\n  }\n  return Far(farName, (...args) => func(...args));\n};\nharden(ToFarFunction);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}