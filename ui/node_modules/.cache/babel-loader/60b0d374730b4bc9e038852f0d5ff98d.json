{"ast":null,"code":"// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\nimport { WeakSet, apply, immutableObject, proxyRevocable, weaksetAdd } from './commons.js';\nimport { getScopeConstants } from './scope-constants.js';\nimport { createScopeHandler } from './scope-handler.js';\nimport { applyTransforms, mandatoryTransforms } from './transforms.js';\nimport { makeEvaluateFactory } from './make-evaluate-factory.js';\nimport { assert } from './error/assert.js';\nconst {\n  details: d\n} = assert;\n/**\n * makeSafeEvaluator()\n * Build the low-level operation used by all evaluators:\n * eval(), Function(), Compartment.prototype.evaluate().\n *\n * @param {Object} options\n * @param {Object} options.globalObject\n * @param {Object} [options.globalLexicals]\n * @param {Array<Transform>} [options.globalTransforms]\n * @param {bool} [options.sloppyGlobalsMode]\n * @param {WeakSet} [options.knownScopeProxies]\n */\n\nexport const makeSafeEvaluator = function () {\n  let {\n    globalObject,\n    globalLexicals = {},\n    globalTransforms = [],\n    sloppyGlobalsMode = false,\n    knownScopeProxies = new WeakSet()\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    scopeHandler,\n    scopeController\n  } = createScopeHandler(globalObject, globalLexicals, {\n    sloppyGlobalsMode\n  });\n  const {\n    proxy: scopeProxy,\n    revoke: revokeScopeProxy\n  } = proxyRevocable(immutableObject, scopeHandler);\n  weaksetAdd(knownScopeProxies, scopeProxy); // Defer creating the actual evaluator to first use.\n  // Creating a compartment should be possible in no-eval environments\n  // It also allows more global constants to be captured by the optimizer\n\n  let evaluate;\n\n  const makeEvaluate = () => {\n    if (!evaluate) {\n      const constants = getScopeConstants(globalObject, globalLexicals);\n      const evaluateFactory = makeEvaluateFactory(constants);\n      evaluate = apply(evaluateFactory, scopeProxy, []);\n    }\n  };\n  /**\n   * @param {string} source\n   * @param {Object} [options]\n   * @param {Array<Transform>} [options.localTransforms]\n   */\n\n\n  const safeEvaluate = function (source) {\n    let {\n      localTransforms = []\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    makeEvaluate(); // Execute the mandatory transforms last to ensure that any rewritten code\n    // meets those mandatory requirements.\n\n    source = applyTransforms(source, [...localTransforms, ...globalTransforms, mandatoryTransforms]);\n    scopeController.allowNextEvalToBeUnsafe = true;\n    let err;\n\n    try {\n      // Ensure that \"this\" resolves to the safe global.\n      return apply(evaluate, globalObject, [source]);\n    } catch (e) {\n      // stash the child-code error in hopes of debugging the internal failure\n      err = e;\n      throw e;\n    } finally {\n      const unsafeEvalWasStillExposed = scopeController.allowNextEvalToBeUnsafe;\n      scopeController.allowNextEvalToBeUnsafe = false;\n\n      if (unsafeEvalWasStillExposed) {\n        // Barring a defect in the SES shim, the scope proxy should allow the\n        // powerful, unsafe  `eval` to be used by `evaluate` exactly once, as the\n        // very first name that it attempts to access from the lexical scope.\n        // A defect in the SES shim could throw an exception after we set\n        // `scopeController.allowNextEvalToBeUnsafe` and before `evaluate`\n        // calls `eval` internally.\n        // If we get here, SES is very broken.\n        // This condition is one where this vat is now hopelessly confused, and\n        // the vat as a whole should be aborted.\n        // No further code should run.\n        // All immediately reachable state should be abandoned.\n        // However, that is not yet possible, so we at least prevent further\n        // variable resolution via the scopeHandler, and throw an error with\n        // diagnostic info including the thrown error if any from evaluating the\n        // source code.\n        revokeScopeProxy(); // TODO A GOOD PLACE TO PANIC(), i.e., kill the vat incarnation.\n        // See https://github.com/Agoric/SES-shim/issues/490\n        // eslint-disable-next-line @endo/no-polymorphic-call\n\n        assert.fail(d`handler did not reset allowNextEvalToBeUnsafe ${err}`);\n      }\n    }\n  };\n\n  return {\n    safeEvaluate\n  };\n};","map":{"version":3,"names":["WeakSet","apply","immutableObject","proxyRevocable","weaksetAdd","getScopeConstants","createScopeHandler","applyTransforms","mandatoryTransforms","makeEvaluateFactory","assert","details","d","makeSafeEvaluator","globalObject","globalLexicals","globalTransforms","sloppyGlobalsMode","knownScopeProxies","scopeHandler","scopeController","proxy","scopeProxy","revoke","revokeScopeProxy","evaluate","makeEvaluate","constants","evaluateFactory","safeEvaluate","source","localTransforms","allowNextEvalToBeUnsafe","err","e","unsafeEvalWasStillExposed","fail"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/make-safe-evaluator.js"],"sourcesContent":["// Portions adapted from V8 - Copyright 2016 the V8 project authors.\n// https://github.com/v8/v8/blob/master/src/builtins/builtins-function.cc\n\nimport {\n  WeakSet,\n  apply,\n  immutableObject,\n  proxyRevocable,\n  weaksetAdd,\n} from './commons.js';\nimport { getScopeConstants } from './scope-constants.js';\nimport { createScopeHandler } from './scope-handler.js';\nimport { applyTransforms, mandatoryTransforms } from './transforms.js';\nimport { makeEvaluateFactory } from './make-evaluate-factory.js';\nimport { assert } from './error/assert.js';\n\nconst { details: d } = assert;\n\n/**\n * makeSafeEvaluator()\n * Build the low-level operation used by all evaluators:\n * eval(), Function(), Compartment.prototype.evaluate().\n *\n * @param {Object} options\n * @param {Object} options.globalObject\n * @param {Object} [options.globalLexicals]\n * @param {Array<Transform>} [options.globalTransforms]\n * @param {bool} [options.sloppyGlobalsMode]\n * @param {WeakSet} [options.knownScopeProxies]\n */\nexport const makeSafeEvaluator = ({\n  globalObject,\n  globalLexicals = {},\n  globalTransforms = [],\n  sloppyGlobalsMode = false,\n  knownScopeProxies = new WeakSet(),\n} = {}) => {\n  const { scopeHandler, scopeController } = createScopeHandler(\n    globalObject,\n    globalLexicals,\n    {\n      sloppyGlobalsMode,\n    },\n  );\n  const { proxy: scopeProxy, revoke: revokeScopeProxy } = proxyRevocable(\n    immutableObject,\n    scopeHandler,\n  );\n  weaksetAdd(knownScopeProxies, scopeProxy);\n\n  // Defer creating the actual evaluator to first use.\n  // Creating a compartment should be possible in no-eval environments\n  // It also allows more global constants to be captured by the optimizer\n  let evaluate;\n  const makeEvaluate = () => {\n    if (!evaluate) {\n      const constants = getScopeConstants(globalObject, globalLexicals);\n      const evaluateFactory = makeEvaluateFactory(constants);\n      evaluate = apply(evaluateFactory, scopeProxy, []);\n    }\n  };\n\n  /**\n   * @param {string} source\n   * @param {Object} [options]\n   * @param {Array<Transform>} [options.localTransforms]\n   */\n  const safeEvaluate = (source, { localTransforms = [] } = {}) => {\n    makeEvaluate();\n\n    // Execute the mandatory transforms last to ensure that any rewritten code\n    // meets those mandatory requirements.\n    source = applyTransforms(source, [\n      ...localTransforms,\n      ...globalTransforms,\n      mandatoryTransforms,\n    ]);\n\n    scopeController.allowNextEvalToBeUnsafe = true;\n    let err;\n    try {\n      // Ensure that \"this\" resolves to the safe global.\n      return apply(evaluate, globalObject, [source]);\n    } catch (e) {\n      // stash the child-code error in hopes of debugging the internal failure\n      err = e;\n      throw e;\n    } finally {\n      const unsafeEvalWasStillExposed = scopeController.allowNextEvalToBeUnsafe;\n      scopeController.allowNextEvalToBeUnsafe = false;\n      if (unsafeEvalWasStillExposed) {\n        // Barring a defect in the SES shim, the scope proxy should allow the\n        // powerful, unsafe  `eval` to be used by `evaluate` exactly once, as the\n        // very first name that it attempts to access from the lexical scope.\n        // A defect in the SES shim could throw an exception after we set\n        // `scopeController.allowNextEvalToBeUnsafe` and before `evaluate`\n        // calls `eval` internally.\n        // If we get here, SES is very broken.\n        // This condition is one where this vat is now hopelessly confused, and\n        // the vat as a whole should be aborted.\n        // No further code should run.\n        // All immediately reachable state should be abandoned.\n        // However, that is not yet possible, so we at least prevent further\n        // variable resolution via the scopeHandler, and throw an error with\n        // diagnostic info including the thrown error if any from evaluating the\n        // source code.\n        revokeScopeProxy();\n        // TODO A GOOD PLACE TO PANIC(), i.e., kill the vat incarnation.\n        // See https://github.com/Agoric/SES-shim/issues/490\n        // eslint-disable-next-line @endo/no-polymorphic-call\n        assert.fail(d`handler did not reset allowNextEvalToBeUnsafe ${err}`);\n      }\n    }\n  };\n\n  return { safeEvaluate };\n};\n"],"mappings":"AAAA;AACA;AAEA,SACEA,OADF,EAEEC,KAFF,EAGEC,eAHF,EAIEC,cAJF,EAKEC,UALF,QAMO,cANP;AAOA,SAASC,iBAAT,QAAkC,sBAAlC;AACA,SAASC,kBAAT,QAAmC,oBAAnC;AACA,SAASC,eAAT,EAA0BC,mBAA1B,QAAqD,iBAArD;AACA,SAASC,mBAAT,QAAoC,4BAApC;AACA,SAASC,MAAT,QAAuB,mBAAvB;AAEA,MAAM;EAAEC,OAAO,EAAEC;AAAX,IAAiBF,MAAvB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMG,iBAAiB,GAAG,YAMtB;EAAA,IANuB;IAChCC,YADgC;IAEhCC,cAAc,GAAG,EAFe;IAGhCC,gBAAgB,GAAG,EAHa;IAIhCC,iBAAiB,GAAG,KAJY;IAKhCC,iBAAiB,GAAG,IAAIlB,OAAJ;EALY,CAMvB,uEAAP,EAAO;EACT,MAAM;IAAEmB,YAAF;IAAgBC;EAAhB,IAAoCd,kBAAkB,CAC1DQ,YAD0D,EAE1DC,cAF0D,EAG1D;IACEE;EADF,CAH0D,CAA5D;EAOA,MAAM;IAAEI,KAAK,EAAEC,UAAT;IAAqBC,MAAM,EAAEC;EAA7B,IAAkDrB,cAAc,CACpED,eADoE,EAEpEiB,YAFoE,CAAtE;EAIAf,UAAU,CAACc,iBAAD,EAAoBI,UAApB,CAAV,CAZS,CAcT;EACA;EACA;;EACA,IAAIG,QAAJ;;EACA,MAAMC,YAAY,GAAG,MAAM;IACzB,IAAI,CAACD,QAAL,EAAe;MACb,MAAME,SAAS,GAAGtB,iBAAiB,CAACS,YAAD,EAAeC,cAAf,CAAnC;MACA,MAAMa,eAAe,GAAGnB,mBAAmB,CAACkB,SAAD,CAA3C;MACAF,QAAQ,GAAGxB,KAAK,CAAC2B,eAAD,EAAkBN,UAAlB,EAA8B,EAA9B,CAAhB;IACD;EACF,CAND;EAQA;AACF;AACA;AACA;AACA;;;EACE,MAAMO,YAAY,GAAG,UAACC,MAAD,EAA2C;IAAA,IAAlC;MAAEC,eAAe,GAAG;IAApB,CAAkC,uEAAP,EAAO;IAC9DL,YAAY,GADkD,CAG9D;IACA;;IACAI,MAAM,GAAGvB,eAAe,CAACuB,MAAD,EAAS,CAC/B,GAAGC,eAD4B,EAE/B,GAAGf,gBAF4B,EAG/BR,mBAH+B,CAAT,CAAxB;IAMAY,eAAe,CAACY,uBAAhB,GAA0C,IAA1C;IACA,IAAIC,GAAJ;;IACA,IAAI;MACF;MACA,OAAOhC,KAAK,CAACwB,QAAD,EAAWX,YAAX,EAAyB,CAACgB,MAAD,CAAzB,CAAZ;IACD,CAHD,CAGE,OAAOI,CAAP,EAAU;MACV;MACAD,GAAG,GAAGC,CAAN;MACA,MAAMA,CAAN;IACD,CAPD,SAOU;MACR,MAAMC,yBAAyB,GAAGf,eAAe,CAACY,uBAAlD;MACAZ,eAAe,CAACY,uBAAhB,GAA0C,KAA1C;;MACA,IAAIG,yBAAJ,EAA+B;QAC7B;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACAX,gBAAgB,GAhBa,CAiB7B;QACA;QACA;;QACAd,MAAM,CAAC0B,IAAP,CAAYxB,CAAE,iDAAgDqB,GAAI,EAAlE;MACD;IACF;EACF,CA9CD;;EAgDA,OAAO;IAAEJ;EAAF,CAAP;AACD,CAtFM"},"metadata":{},"sourceType":"module"}