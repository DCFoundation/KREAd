{"ast":null,"code":"// Copyright (C) 2011 Google Inc.\n// Copyright (C) 2018 Agoric\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n// This module removes all non-allowed properties found by recursively and\n// reflectively walking own property chains.\n//\n// The prototype properties are type checked.\n//\n// In addition, it verifies that the `prototype`, `__proto__`, and\n// `constructor` properties do point to their allowed values.\n//\n// Typically, this module will not be used directly, but via the\n// [lockdown-shim] which handles all necessary repairs and taming in SES.\n//\n// In the whitelist, the `prototype`, `__proto__`, and `constructor` must be\n// specified and point to top level entries in the map. For example,\n// `Object.__proto__` leads to `FunctionPrototype` which is a top level entry\n// in the map.\n//\n// The permit value must be\n//    * the typeof name of a primitive for type-checking (for example,\n//      `Error.stackTraceLimit` leads to 'number'),\n//    * the name of an intrinsic,\n//    * an internal constant(for example, `eval` leads to `fn` which\n//      is an alias for `FunctionInstance`, a record that whitelist all\n//      properties allowed on such instance).\n//    * false, a property to be removed that we know about.\n//\n// All unlisted properties are also removed. But for the ones that are removed\n// because they are unlisted, as opposed to `false`, we also print their\n// name to the console as a useful diagnostic, possibly provoking an expansion\n// of the whitelist.\nimport { whitelist, FunctionInstance, isAccessorPermit } from './whitelist.js';\nimport { Map, String, TypeError, arrayFilter, arrayIncludes, arrayMap, entries, getOwnPropertyDescriptor, getPrototypeOf, isObject, mapGet, objectHasOwnProperty, ownKeys, symbolKeyFor } from './commons.js';\n/**\n * whitelistIntrinsics()\n * Removes all non-allowed properties found by recursively and\n * reflectively walking own property chains.\n *\n * @param {Object} intrinsics\n * @param {(Object) => void} markVirtualizedNativeFunction\n */\n\nexport default function whitelistIntrinsics(intrinsics, markVirtualizedNativeFunction) {\n  // These primitives are allowed allowed for permits.\n  const primitives = ['undefined', 'boolean', 'number', 'string', 'symbol']; // These symbols are allowed as well-known symbols\n\n  const wellKnownSymbolNames = new Map(intrinsics.Symbol ? arrayMap(arrayFilter(entries(whitelist.Symbol), _ref => {\n    let [name, permit] = _ref;\n    return permit === 'symbol' && typeof intrinsics.Symbol[name] === 'symbol';\n  }), _ref2 => {\n    let [name] = _ref2;\n    return [intrinsics.Symbol[name], `@@${name}`];\n  }) : []);\n  /**\n   * asStringPropertyName()\n   *\n   * @param {string} path\n   * @param {string | symbol} prop\n   */\n\n  function asStringPropertyName(path, prop) {\n    if (typeof prop === 'string') {\n      return prop;\n    }\n\n    const wellKnownSymbol = mapGet(wellKnownSymbolNames, prop);\n\n    if (typeof prop === 'symbol') {\n      if (wellKnownSymbol) {\n        return wellKnownSymbol;\n      } else {\n        const registeredKey = symbolKeyFor(prop);\n\n        if (registeredKey !== undefined) {\n          return `RegisteredSymbol(${registeredKey})`;\n        } else {\n          return `Unique${String(prop)}`;\n        }\n      }\n    }\n\n    throw new TypeError(`Unexpected property name type ${path} ${prop}`);\n  }\n  /*\n   * visitPrototype()\n   * Validate the object's [[prototype]] against a permit.\n   */\n\n\n  function visitPrototype(path, obj, protoName) {\n    if (!isObject(obj)) {\n      throw new TypeError(`Object expected: ${path}, ${obj}, ${protoName}`);\n    }\n\n    const proto = getPrototypeOf(obj); // Null prototype.\n\n    if (proto === null && protoName === null) {\n      return;\n    } // Assert: protoName, if provided, is a string.\n\n\n    if (protoName !== undefined && typeof protoName !== 'string') {\n      throw new TypeError(`Malformed whitelist permit ${path}.__proto__`);\n    } // If permit not specified, default to Object.prototype.\n\n\n    if (proto === intrinsics[protoName || '%ObjectPrototype%']) {\n      return;\n    } // We can't clean [[prototype]], therefore abort.\n\n\n    throw new TypeError(`Unexpected intrinsic ${path}.__proto__ at ${protoName}`);\n  }\n  /*\n   * isAllowedPropertyValue()\n   * Whitelist a single property value against a permit.\n   */\n\n\n  function isAllowedPropertyValue(path, value, prop, permit) {\n    if (typeof permit === 'object') {\n      // eslint-disable-next-line no-use-before-define\n      visitProperties(path, value, permit); // The property is allowed.\n\n      return true;\n    }\n\n    if (permit === false) {\n      // A boolan 'false' permit specifies the removal of a property.\n      // We require a more specific permit instead of allowing 'true'.\n      return false;\n    }\n\n    if (typeof permit === 'string') {\n      // A string permit can have one of two meanings:\n      if (prop === 'prototype' || prop === 'constructor') {\n        // For prototype and constructor value properties, the permit\n        // is the name of an intrinsic.\n        // Assumption: prototype and constructor cannot be primitives.\n        // Assert: the permit is the name of an intrinsic.\n        // Assert: the property value is equal to that intrinsic.\n        if (objectHasOwnProperty(intrinsics, permit)) {\n          if (value !== intrinsics[permit]) {\n            throw new TypeError(`Does not match whitelist ${path}`);\n          }\n\n          return true;\n        }\n      } else {\n        // For all other properties, the permit is the name of a primitive.\n        // Assert: the permit is the name of a primitive.\n        // Assert: the property value type is equal to that primitive.\n        // eslint-disable-next-line no-lonely-if\n        if (arrayIncludes(primitives, permit)) {\n          // eslint-disable-next-line valid-typeof\n          if (typeof value !== permit) {\n            throw new TypeError(`At ${path} expected ${permit} not ${typeof value}`);\n          }\n\n          return true;\n        }\n      }\n    }\n\n    throw new TypeError(`Unexpected whitelist permit ${permit} at ${path}`);\n  }\n  /*\n   * isAllowedProperty()\n   * Check whether a single property is allowed.\n   */\n\n\n  function isAllowedProperty(path, obj, prop, permit) {\n    const desc = getOwnPropertyDescriptor(obj, prop); // Is this a value property?\n\n    if (objectHasOwnProperty(desc, 'value')) {\n      if (isAccessorPermit(permit)) {\n        throw new TypeError(`Accessor expected at ${path}`);\n      }\n\n      return isAllowedPropertyValue(path, desc.value, prop, permit);\n    }\n\n    if (!isAccessorPermit(permit)) {\n      throw new TypeError(`Accessor not expected at ${path}`);\n    }\n\n    return isAllowedPropertyValue(`${path}<get>`, desc.get, prop, permit.get) && isAllowedPropertyValue(`${path}<set>`, desc.set, prop, permit.set);\n  }\n  /*\n   * getSubPermit()\n   */\n\n\n  function getSubPermit(obj, permit, prop) {\n    const permitProp = prop === '__proto__' ? '--proto--' : prop;\n\n    if (objectHasOwnProperty(permit, permitProp)) {\n      return permit[permitProp];\n    }\n\n    if (typeof obj === 'function') {\n      markVirtualizedNativeFunction(obj);\n\n      if (objectHasOwnProperty(FunctionInstance, permitProp)) {\n        return FunctionInstance[permitProp];\n      }\n    }\n\n    return undefined;\n  }\n  /*\n   * visitProperties()\n   * Visit all properties for a permit.\n   */\n\n\n  function visitProperties(path, obj, permit) {\n    if (obj === undefined) {\n      return;\n    }\n\n    const protoName = permit['[[Proto]]'];\n    visitPrototype(path, obj, protoName);\n\n    for (const prop of ownKeys(obj)) {\n      const propString = asStringPropertyName(path, prop);\n      const subPath = `${path}.${propString}`;\n      const subPermit = getSubPermit(obj, permit, propString);\n\n      if (!subPermit || !isAllowedProperty(subPath, obj, prop, subPermit)) {\n        // Either the object lacks a permit or the object doesn't match the\n        // permit.\n        // If the permit is specifically false, not merely undefined,\n        // this is a property we expect to see because we know it exists in\n        // some environments and we have expressly decided to exclude it.\n        // Any other disallowed property is one we have not audited and we log\n        // that we are removing it so we know to look into it, as happens when\n        // the language evolves new features to existing intrinsics.\n        if (subPermit !== false) {\n          // This call to `console.warn` is intentional. It is not a vestige of\n          // a debugging attempt. See the comment at top of file for an\n          // explanation.\n          // eslint-disable-next-line @endo/no-polymorphic-call\n          console.warn(`Removing ${subPath}`);\n        }\n\n        try {\n          delete obj[prop];\n        } catch (err) {\n          if (prop in obj) {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(`failed to delete ${subPath}`, err);\n          } else {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(`deleting ${subPath} threw`, err);\n          }\n\n          throw err;\n        }\n      }\n    }\n  } // Start path with 'intrinsics' to clarify that properties are not\n  // removed from the global object by the whitelisting operation.\n\n\n  visitProperties('intrinsics', intrinsics, whitelist);\n}","map":{"version":3,"names":["whitelist","FunctionInstance","isAccessorPermit","Map","String","TypeError","arrayFilter","arrayIncludes","arrayMap","entries","getOwnPropertyDescriptor","getPrototypeOf","isObject","mapGet","objectHasOwnProperty","ownKeys","symbolKeyFor","whitelistIntrinsics","intrinsics","markVirtualizedNativeFunction","primitives","wellKnownSymbolNames","Symbol","name","permit","asStringPropertyName","path","prop","wellKnownSymbol","registeredKey","undefined","visitPrototype","obj","protoName","proto","isAllowedPropertyValue","value","visitProperties","isAllowedProperty","desc","get","set","getSubPermit","permitProp","propString","subPath","subPermit","console","warn","err","error"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/whitelist-intrinsics.js"],"sourcesContent":["// Copyright (C) 2011 Google Inc.\n// Copyright (C) 2018 Agoric\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This module removes all non-allowed properties found by recursively and\n// reflectively walking own property chains.\n//\n// The prototype properties are type checked.\n//\n// In addition, it verifies that the `prototype`, `__proto__`, and\n// `constructor` properties do point to their allowed values.\n//\n// Typically, this module will not be used directly, but via the\n// [lockdown-shim] which handles all necessary repairs and taming in SES.\n//\n// In the whitelist, the `prototype`, `__proto__`, and `constructor` must be\n// specified and point to top level entries in the map. For example,\n// `Object.__proto__` leads to `FunctionPrototype` which is a top level entry\n// in the map.\n//\n// The permit value must be\n//    * the typeof name of a primitive for type-checking (for example,\n//      `Error.stackTraceLimit` leads to 'number'),\n//    * the name of an intrinsic,\n//    * an internal constant(for example, `eval` leads to `fn` which\n//      is an alias for `FunctionInstance`, a record that whitelist all\n//      properties allowed on such instance).\n//    * false, a property to be removed that we know about.\n//\n// All unlisted properties are also removed. But for the ones that are removed\n// because they are unlisted, as opposed to `false`, we also print their\n// name to the console as a useful diagnostic, possibly provoking an expansion\n// of the whitelist.\n\nimport { whitelist, FunctionInstance, isAccessorPermit } from './whitelist.js';\nimport {\n  Map,\n  String,\n  TypeError,\n  arrayFilter,\n  arrayIncludes,\n  arrayMap,\n  entries,\n  getOwnPropertyDescriptor,\n  getPrototypeOf,\n  isObject,\n  mapGet,\n  objectHasOwnProperty,\n  ownKeys,\n  symbolKeyFor,\n} from './commons.js';\n\n/**\n * whitelistIntrinsics()\n * Removes all non-allowed properties found by recursively and\n * reflectively walking own property chains.\n *\n * @param {Object} intrinsics\n * @param {(Object) => void} markVirtualizedNativeFunction\n */\nexport default function whitelistIntrinsics(\n  intrinsics,\n  markVirtualizedNativeFunction,\n) {\n  // These primitives are allowed allowed for permits.\n  const primitives = ['undefined', 'boolean', 'number', 'string', 'symbol'];\n\n  // These symbols are allowed as well-known symbols\n  const wellKnownSymbolNames = new Map(\n    intrinsics.Symbol\n      ? arrayMap(\n          arrayFilter(\n            entries(whitelist.Symbol),\n            ([name, permit]) =>\n              permit === 'symbol' &&\n              typeof intrinsics.Symbol[name] === 'symbol',\n          ),\n          ([name]) => [intrinsics.Symbol[name], `@@${name}`],\n        )\n      : [],\n  );\n\n  /**\n   * asStringPropertyName()\n   *\n   * @param {string} path\n   * @param {string | symbol} prop\n   */\n  function asStringPropertyName(path, prop) {\n    if (typeof prop === 'string') {\n      return prop;\n    }\n\n    const wellKnownSymbol = mapGet(wellKnownSymbolNames, prop);\n\n    if (typeof prop === 'symbol') {\n      if (wellKnownSymbol) {\n        return wellKnownSymbol;\n      } else {\n        const registeredKey = symbolKeyFor(prop);\n        if (registeredKey !== undefined) {\n          return `RegisteredSymbol(${registeredKey})`;\n        } else {\n          return `Unique${String(prop)}`;\n        }\n      }\n    }\n\n    throw new TypeError(`Unexpected property name type ${path} ${prop}`);\n  }\n\n  /*\n   * visitPrototype()\n   * Validate the object's [[prototype]] against a permit.\n   */\n  function visitPrototype(path, obj, protoName) {\n    if (!isObject(obj)) {\n      throw new TypeError(`Object expected: ${path}, ${obj}, ${protoName}`);\n    }\n    const proto = getPrototypeOf(obj);\n\n    // Null prototype.\n    if (proto === null && protoName === null) {\n      return;\n    }\n\n    // Assert: protoName, if provided, is a string.\n    if (protoName !== undefined && typeof protoName !== 'string') {\n      throw new TypeError(`Malformed whitelist permit ${path}.__proto__`);\n    }\n\n    // If permit not specified, default to Object.prototype.\n    if (proto === intrinsics[protoName || '%ObjectPrototype%']) {\n      return;\n    }\n\n    // We can't clean [[prototype]], therefore abort.\n    throw new TypeError(\n      `Unexpected intrinsic ${path}.__proto__ at ${protoName}`,\n    );\n  }\n\n  /*\n   * isAllowedPropertyValue()\n   * Whitelist a single property value against a permit.\n   */\n  function isAllowedPropertyValue(path, value, prop, permit) {\n    if (typeof permit === 'object') {\n      // eslint-disable-next-line no-use-before-define\n      visitProperties(path, value, permit);\n      // The property is allowed.\n      return true;\n    }\n\n    if (permit === false) {\n      // A boolan 'false' permit specifies the removal of a property.\n      // We require a more specific permit instead of allowing 'true'.\n      return false;\n    }\n\n    if (typeof permit === 'string') {\n      // A string permit can have one of two meanings:\n\n      if (prop === 'prototype' || prop === 'constructor') {\n        // For prototype and constructor value properties, the permit\n        // is the name of an intrinsic.\n        // Assumption: prototype and constructor cannot be primitives.\n        // Assert: the permit is the name of an intrinsic.\n        // Assert: the property value is equal to that intrinsic.\n\n        if (objectHasOwnProperty(intrinsics, permit)) {\n          if (value !== intrinsics[permit]) {\n            throw new TypeError(`Does not match whitelist ${path}`);\n          }\n          return true;\n        }\n      } else {\n        // For all other properties, the permit is the name of a primitive.\n        // Assert: the permit is the name of a primitive.\n        // Assert: the property value type is equal to that primitive.\n\n        // eslint-disable-next-line no-lonely-if\n        if (arrayIncludes(primitives, permit)) {\n          // eslint-disable-next-line valid-typeof\n          if (typeof value !== permit) {\n            throw new TypeError(\n              `At ${path} expected ${permit} not ${typeof value}`,\n            );\n          }\n          return true;\n        }\n      }\n    }\n\n    throw new TypeError(`Unexpected whitelist permit ${permit} at ${path}`);\n  }\n\n  /*\n   * isAllowedProperty()\n   * Check whether a single property is allowed.\n   */\n  function isAllowedProperty(path, obj, prop, permit) {\n    const desc = getOwnPropertyDescriptor(obj, prop);\n\n    // Is this a value property?\n    if (objectHasOwnProperty(desc, 'value')) {\n      if (isAccessorPermit(permit)) {\n        throw new TypeError(`Accessor expected at ${path}`);\n      }\n      return isAllowedPropertyValue(path, desc.value, prop, permit);\n    }\n    if (!isAccessorPermit(permit)) {\n      throw new TypeError(`Accessor not expected at ${path}`);\n    }\n    return (\n      isAllowedPropertyValue(`${path}<get>`, desc.get, prop, permit.get) &&\n      isAllowedPropertyValue(`${path}<set>`, desc.set, prop, permit.set)\n    );\n  }\n\n  /*\n   * getSubPermit()\n   */\n  function getSubPermit(obj, permit, prop) {\n    const permitProp = prop === '__proto__' ? '--proto--' : prop;\n    if (objectHasOwnProperty(permit, permitProp)) {\n      return permit[permitProp];\n    }\n\n    if (typeof obj === 'function') {\n      markVirtualizedNativeFunction(obj);\n      if (objectHasOwnProperty(FunctionInstance, permitProp)) {\n        return FunctionInstance[permitProp];\n      }\n    }\n\n    return undefined;\n  }\n\n  /*\n   * visitProperties()\n   * Visit all properties for a permit.\n   */\n  function visitProperties(path, obj, permit) {\n    if (obj === undefined) {\n      return;\n    }\n\n    const protoName = permit['[[Proto]]'];\n    visitPrototype(path, obj, protoName);\n\n    for (const prop of ownKeys(obj)) {\n      const propString = asStringPropertyName(path, prop);\n      const subPath = `${path}.${propString}`;\n      const subPermit = getSubPermit(obj, permit, propString);\n\n      if (!subPermit || !isAllowedProperty(subPath, obj, prop, subPermit)) {\n        // Either the object lacks a permit or the object doesn't match the\n        // permit.\n        // If the permit is specifically false, not merely undefined,\n        // this is a property we expect to see because we know it exists in\n        // some environments and we have expressly decided to exclude it.\n        // Any other disallowed property is one we have not audited and we log\n        // that we are removing it so we know to look into it, as happens when\n        // the language evolves new features to existing intrinsics.\n        if (subPermit !== false) {\n          // This call to `console.warn` is intentional. It is not a vestige of\n          // a debugging attempt. See the comment at top of file for an\n          // explanation.\n          // eslint-disable-next-line @endo/no-polymorphic-call\n          console.warn(`Removing ${subPath}`);\n        }\n        try {\n          delete obj[prop];\n        } catch (err) {\n          if (prop in obj) {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(`failed to delete ${subPath}`, err);\n          } else {\n            // eslint-disable-next-line @endo/no-polymorphic-call\n            console.error(`deleting ${subPath} threw`, err);\n          }\n          throw err;\n        }\n      }\n    }\n  }\n\n  // Start path with 'intrinsics' to clarify that properties are not\n  // removed from the global object by the whitelisting operation.\n  visitProperties('intrinsics', intrinsics, whitelist);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}