{"ast":null,"code":"// @ts-check\n\n/* eslint-disable no-underscore-dangle */\n/// <reference types=\"ses\">\nimport { Map, ReferenceError, TypeError, WeakMap, WeakSet, arrayFilter, arrayJoin, assign, defineProperties, entries, freeze, getOwnPropertyNames, promiseThen, weakmapGet, weakmapSet, weaksetHas } from './commons.js';\nimport { setGlobalObjectConstantProperties, setGlobalObjectMutableProperties, setGlobalObjectEvaluators } from './global-object.js';\nimport { isValidIdentifierName } from './scope-constants.js';\nimport { sharedGlobalPropertyNames } from './whitelist.js';\nimport { load } from './module-load.js';\nimport { link } from './module-link.js';\nimport { getDeferredExports } from './module-proxy.js';\nimport { assert } from './error/assert.js';\nimport { compartmentEvaluate } from './compartment-evaluate.js';\nimport { makeSafeEvaluator } from './make-safe-evaluator.js';\nconst {\n  quote: q\n} = assert; // moduleAliases associates every public module exports namespace with its\n// corresponding compartment and specifier so they can be used to link modules\n// across compartments.\n// The mechanism to thread an alias is to use the compartment.module function\n// to obtain the exports namespace of a foreign module and pass it into another\n// compartment's moduleMap constructor option.\n\nconst moduleAliases = new WeakMap(); // privateFields captures the private state for each compartment.\n\nconst privateFields = new WeakMap();\n/**\n * @typedef {(source: string) => string} Transform\n */\n// Compartments do not need an importHook or resolveHook to be useful\n// as a vessel for evaluating programs.\n// However, any method that operates the module system will throw an exception\n// if these hooks are not available.\n\nconst assertModuleHooks = compartment => {\n  const {\n    importHook,\n    resolveHook\n  } = weakmapGet(privateFields, compartment);\n\n  if (typeof importHook !== 'function' || typeof resolveHook !== 'function') {\n    throw new TypeError('Compartment must be constructed with an importHook and a resolveHook for it to be able to load modules');\n  }\n};\n\nexport const InertCompartment = function Compartment() {\n  let _endowments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  let _modules = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  let _options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  throw new TypeError('Compartment.prototype.constructor is not a valid constructor.');\n};\n/**\n * @param {Compartment} compartment\n * @param {string} specifier\n */\n\nconst compartmentImportNow = (compartment, specifier) => {\n  const {\n    execute,\n    exportsProxy\n  } = link(privateFields, moduleAliases, compartment, specifier);\n  execute();\n  return exportsProxy;\n};\n\nexport const CompartmentPrototype = {\n  constructor: InertCompartment,\n\n  get globalThis() {\n    return weakmapGet(privateFields, this).globalObject;\n  },\n\n  get name() {\n    return weakmapGet(privateFields, this).name;\n  },\n\n  /**\n   * @param {string} source is a JavaScript program grammar construction.\n   * @param {Object} [options]\n   * @param {Array<Transform>} [options.transforms]\n   * @param {boolean} [options.sloppyGlobalsMode]\n   * @param {Object} [options.__moduleShimLexicals__]\n   * @param {boolean} [options.__evadeHtmlCommentTest__]\n   * @param {boolean} [options.__evadeImportExpressionTest__]\n   * @param {boolean} [options.__rejectSomeDirectEvalExpressions__]\n   */\n  evaluate(source) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const compartmentFields = weakmapGet(privateFields, this);\n    return compartmentEvaluate(compartmentFields, source, options);\n  },\n\n  toString() {\n    return '[object Compartment]';\n  },\n\n  /* eslint-disable-next-line no-underscore-dangle */\n  __isKnownScopeProxy__(value) {\n    const {\n      knownScopeProxies\n    } = weakmapGet(privateFields, this);\n    return weaksetHas(knownScopeProxies, value);\n  },\n\n  module(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of module() must be a string');\n    }\n\n    assertModuleHooks(this);\n    const {\n      exportsProxy\n    } = getDeferredExports(this, weakmapGet(privateFields, this), moduleAliases, specifier);\n    return exportsProxy;\n  },\n\n  async import(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of import() must be a string');\n    }\n\n    assertModuleHooks(this);\n    return promiseThen(load(privateFields, moduleAliases, this, specifier), () => {\n      // The namespace box is a contentious design and likely to be a breaking\n      // change in an appropriately numbered future version.\n      const namespace = compartmentImportNow(this, specifier);\n      return {\n        namespace\n      };\n    });\n  },\n\n  async load(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of load() must be a string');\n    }\n\n    assertModuleHooks(this);\n    return load(privateFields, moduleAliases, this, specifier);\n  },\n\n  importNow(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of importNow() must be a string');\n    }\n\n    assertModuleHooks(this);\n    return compartmentImportNow(this, specifier);\n  }\n\n};\ndefineProperties(InertCompartment, {\n  prototype: {\n    value: CompartmentPrototype\n  }\n});\n/**\n * @callback MakeCompartmentConstructor\n * @param {MakeCompartmentConstructor} targetMakeCompartmentConstructor\n * @param {Record<string, any>} intrinsics\n * @param {(object: Object) => void} markVirtualizedNativeFunction\n * @returns {Compartment['constructor']}\n */\n\n/** @type {MakeCompartmentConstructor} */\n\nexport const makeCompartmentConstructor = (targetMakeCompartmentConstructor, intrinsics, markVirtualizedNativeFunction) => {\n  function Compartment() {\n    let endowments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let moduleMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (new.target === undefined) {\n      throw new TypeError(\"Class constructor Compartment cannot be invoked without 'new'\");\n    } // Extract options, and shallow-clone transforms.\n\n\n    const {\n      name = '<unknown>',\n      transforms = [],\n      __shimTransforms__ = [],\n      globalLexicals: globalLexicalsOption = {},\n      resolveHook,\n      importHook,\n      moduleMapHook\n    } = options;\n    const globalTransforms = [...transforms, ...__shimTransforms__]; // Map<FullSpecifier, ModuleCompartmentRecord>\n\n    const moduleRecords = new Map(); // Map<FullSpecifier, ModuleInstance>\n\n    const instances = new Map(); // Map<FullSpecifier, {ExportsProxy, ProxiedExports, activate()}>\n\n    const deferredExports = new Map(); // Validate given moduleMap.\n    // The module map gets translated on-demand in module-load.js and the\n    // moduleMap can be invalid in ways that cannot be detected in the\n    // constructor, but these checks allow us to throw early for a better\n    // developer experience.\n\n    for (const [specifier, aliasNamespace] of entries(moduleMap || {})) {\n      if (typeof aliasNamespace === 'string') {\n        // TODO implement parent module record retrieval.\n        throw new TypeError(`Cannot map module ${q(specifier)} to ${q(aliasNamespace)} in parent compartment`);\n      } else if (weakmapGet(moduleAliases, aliasNamespace) === undefined) {\n        // TODO create and link a synthetic module instance from the given\n        // namespace object.\n        throw ReferenceError(`Cannot map module ${q(specifier)} because it has no known compartment in this realm`);\n      }\n    }\n\n    const invalidNames = arrayFilter(getOwnPropertyNames(globalLexicalsOption), identifier => !isValidIdentifierName(identifier));\n\n    if (invalidNames.length) {\n      throw new TypeError(`Cannot create compartment with invalid names for global lexicals: ${arrayJoin(invalidNames, ', ')}; these names would not be lexically mentionable`);\n    } // The caller continues to own the globalLexicals object they passed to\n    // the compartment constructor, but the compartment only respects the\n    // original values and they are constants in the scope of evaluated\n    // programs and executed modules.\n    // This shallow copy captures only the values of enumerable own\n    // properties, erasing accessors.\n    // The snapshot is frozen to ensure that the properties are immutable\n    // when transferred-by-property-descriptor onto local scope objects.\n\n\n    const globalLexicals = freeze({ ...globalLexicalsOption\n    });\n    const globalObject = {}; // We must initialize all constant properties first because\n    // `makeSafeEvaluator` may use them to create optimized bindings\n    // in the evaluator.\n    // TODO: consider merging into a single initialization if internal\n    // evaluator is no longer eagerly created\n\n    setGlobalObjectConstantProperties(globalObject);\n    const knownScopeProxies = new WeakSet();\n    const {\n      safeEvaluate\n    } = makeSafeEvaluator({\n      globalObject,\n      globalLexicals,\n      globalTransforms,\n      sloppyGlobalsMode: false,\n      knownScopeProxies\n    });\n    setGlobalObjectMutableProperties(globalObject, {\n      intrinsics,\n      newGlobalPropertyNames: sharedGlobalPropertyNames,\n      makeCompartmentConstructor: targetMakeCompartmentConstructor,\n      markVirtualizedNativeFunction\n    }); // TODO: maybe add evalTaming to the Compartment constructor 3rd options?\n\n    setGlobalObjectEvaluators(globalObject, safeEvaluate, markVirtualizedNativeFunction);\n    assign(globalObject, endowments);\n    weakmapSet(privateFields, this, {\n      name,\n      globalTransforms,\n      globalObject,\n      knownScopeProxies,\n      globalLexicals,\n      safeEvaluate,\n      resolveHook,\n      importHook,\n      moduleMap,\n      moduleMapHook,\n      moduleRecords,\n      __shimTransforms__,\n      deferredExports,\n      instances\n    });\n  }\n\n  Compartment.prototype = CompartmentPrototype;\n  return Compartment;\n};","map":{"version":3,"names":["Map","ReferenceError","TypeError","WeakMap","WeakSet","arrayFilter","arrayJoin","assign","defineProperties","entries","freeze","getOwnPropertyNames","promiseThen","weakmapGet","weakmapSet","weaksetHas","setGlobalObjectConstantProperties","setGlobalObjectMutableProperties","setGlobalObjectEvaluators","isValidIdentifierName","sharedGlobalPropertyNames","load","link","getDeferredExports","assert","compartmentEvaluate","makeSafeEvaluator","quote","q","moduleAliases","privateFields","assertModuleHooks","compartment","importHook","resolveHook","InertCompartment","Compartment","_endowments","_modules","_options","compartmentImportNow","specifier","execute","exportsProxy","CompartmentPrototype","constructor","globalThis","globalObject","name","evaluate","source","options","compartmentFields","toString","__isKnownScopeProxy__","value","knownScopeProxies","module","import","namespace","importNow","prototype","makeCompartmentConstructor","targetMakeCompartmentConstructor","intrinsics","markVirtualizedNativeFunction","endowments","moduleMap","new","target","undefined","transforms","__shimTransforms__","globalLexicals","globalLexicalsOption","moduleMapHook","globalTransforms","moduleRecords","instances","deferredExports","aliasNamespace","invalidNames","identifier","length","safeEvaluate","sloppyGlobalsMode","newGlobalPropertyNames"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/compartment-shim.js"],"sourcesContent":["// @ts-check\n/* eslint-disable no-underscore-dangle */\n/// <reference types=\"ses\">\n\nimport {\n  Map,\n  ReferenceError,\n  TypeError,\n  WeakMap,\n  WeakSet,\n  arrayFilter,\n  arrayJoin,\n  assign,\n  defineProperties,\n  entries,\n  freeze,\n  getOwnPropertyNames,\n  promiseThen,\n  weakmapGet,\n  weakmapSet,\n  weaksetHas,\n} from './commons.js';\nimport {\n  setGlobalObjectConstantProperties,\n  setGlobalObjectMutableProperties,\n  setGlobalObjectEvaluators,\n} from './global-object.js';\nimport { isValidIdentifierName } from './scope-constants.js';\nimport { sharedGlobalPropertyNames } from './whitelist.js';\nimport { load } from './module-load.js';\nimport { link } from './module-link.js';\nimport { getDeferredExports } from './module-proxy.js';\nimport { assert } from './error/assert.js';\nimport { compartmentEvaluate } from './compartment-evaluate.js';\nimport { makeSafeEvaluator } from './make-safe-evaluator.js';\n\nconst { quote: q } = assert;\n\n// moduleAliases associates every public module exports namespace with its\n// corresponding compartment and specifier so they can be used to link modules\n// across compartments.\n// The mechanism to thread an alias is to use the compartment.module function\n// to obtain the exports namespace of a foreign module and pass it into another\n// compartment's moduleMap constructor option.\nconst moduleAliases = new WeakMap();\n\n// privateFields captures the private state for each compartment.\nconst privateFields = new WeakMap();\n\n/**\n * @typedef {(source: string) => string} Transform\n */\n\n// Compartments do not need an importHook or resolveHook to be useful\n// as a vessel for evaluating programs.\n// However, any method that operates the module system will throw an exception\n// if these hooks are not available.\nconst assertModuleHooks = compartment => {\n  const { importHook, resolveHook } = weakmapGet(privateFields, compartment);\n  if (typeof importHook !== 'function' || typeof resolveHook !== 'function') {\n    throw new TypeError(\n      'Compartment must be constructed with an importHook and a resolveHook for it to be able to load modules',\n    );\n  }\n};\n\nexport const InertCompartment = function Compartment(\n  _endowments = {},\n  _modules = {},\n  _options = {},\n) {\n  throw new TypeError(\n    'Compartment.prototype.constructor is not a valid constructor.',\n  );\n};\n\n/**\n * @param {Compartment} compartment\n * @param {string} specifier\n */\nconst compartmentImportNow = (compartment, specifier) => {\n  const { execute, exportsProxy } = link(\n    privateFields,\n    moduleAliases,\n    compartment,\n    specifier,\n  );\n  execute();\n  return exportsProxy;\n};\n\nexport const CompartmentPrototype = {\n  constructor: InertCompartment,\n\n  get globalThis() {\n    return weakmapGet(privateFields, this).globalObject;\n  },\n\n  get name() {\n    return weakmapGet(privateFields, this).name;\n  },\n\n  /**\n   * @param {string} source is a JavaScript program grammar construction.\n   * @param {Object} [options]\n   * @param {Array<Transform>} [options.transforms]\n   * @param {boolean} [options.sloppyGlobalsMode]\n   * @param {Object} [options.__moduleShimLexicals__]\n   * @param {boolean} [options.__evadeHtmlCommentTest__]\n   * @param {boolean} [options.__evadeImportExpressionTest__]\n   * @param {boolean} [options.__rejectSomeDirectEvalExpressions__]\n   */\n  evaluate(source, options = {}) {\n    const compartmentFields = weakmapGet(privateFields, this);\n    return compartmentEvaluate(compartmentFields, source, options);\n  },\n\n  toString() {\n    return '[object Compartment]';\n  },\n\n  /* eslint-disable-next-line no-underscore-dangle */\n  __isKnownScopeProxy__(value) {\n    const { knownScopeProxies } = weakmapGet(privateFields, this);\n    return weaksetHas(knownScopeProxies, value);\n  },\n\n  module(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of module() must be a string');\n    }\n\n    assertModuleHooks(this);\n\n    const { exportsProxy } = getDeferredExports(\n      this,\n      weakmapGet(privateFields, this),\n      moduleAliases,\n      specifier,\n    );\n\n    return exportsProxy;\n  },\n\n  async import(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of import() must be a string');\n    }\n\n    assertModuleHooks(this);\n\n    return promiseThen(\n      load(privateFields, moduleAliases, this, specifier),\n      () => {\n        // The namespace box is a contentious design and likely to be a breaking\n        // change in an appropriately numbered future version.\n        const namespace = compartmentImportNow(this, specifier);\n        return { namespace };\n      },\n    );\n  },\n\n  async load(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of load() must be a string');\n    }\n\n    assertModuleHooks(this);\n\n    return load(privateFields, moduleAliases, this, specifier);\n  },\n\n  importNow(specifier) {\n    if (typeof specifier !== 'string') {\n      throw new TypeError('first argument of importNow() must be a string');\n    }\n\n    assertModuleHooks(this);\n\n    return compartmentImportNow(this, specifier);\n  },\n};\n\ndefineProperties(InertCompartment, {\n  prototype: { value: CompartmentPrototype },\n});\n\n/**\n * @callback MakeCompartmentConstructor\n * @param {MakeCompartmentConstructor} targetMakeCompartmentConstructor\n * @param {Record<string, any>} intrinsics\n * @param {(object: Object) => void} markVirtualizedNativeFunction\n * @returns {Compartment['constructor']}\n */\n\n/** @type {MakeCompartmentConstructor} */\nexport const makeCompartmentConstructor = (\n  targetMakeCompartmentConstructor,\n  intrinsics,\n  markVirtualizedNativeFunction,\n) => {\n  function Compartment(endowments = {}, moduleMap = {}, options = {}) {\n    if (new.target === undefined) {\n      throw new TypeError(\n        \"Class constructor Compartment cannot be invoked without 'new'\",\n      );\n    }\n\n    // Extract options, and shallow-clone transforms.\n    const {\n      name = '<unknown>',\n      transforms = [],\n      __shimTransforms__ = [],\n      globalLexicals: globalLexicalsOption = {},\n      resolveHook,\n      importHook,\n      moduleMapHook,\n    } = options;\n    const globalTransforms = [...transforms, ...__shimTransforms__];\n\n    // Map<FullSpecifier, ModuleCompartmentRecord>\n    const moduleRecords = new Map();\n    // Map<FullSpecifier, ModuleInstance>\n    const instances = new Map();\n    // Map<FullSpecifier, {ExportsProxy, ProxiedExports, activate()}>\n    const deferredExports = new Map();\n\n    // Validate given moduleMap.\n    // The module map gets translated on-demand in module-load.js and the\n    // moduleMap can be invalid in ways that cannot be detected in the\n    // constructor, but these checks allow us to throw early for a better\n    // developer experience.\n    for (const [specifier, aliasNamespace] of entries(moduleMap || {})) {\n      if (typeof aliasNamespace === 'string') {\n        // TODO implement parent module record retrieval.\n        throw new TypeError(\n          `Cannot map module ${q(specifier)} to ${q(\n            aliasNamespace,\n          )} in parent compartment`,\n        );\n      } else if (weakmapGet(moduleAliases, aliasNamespace) === undefined) {\n        // TODO create and link a synthetic module instance from the given\n        // namespace object.\n        throw ReferenceError(\n          `Cannot map module ${q(\n            specifier,\n          )} because it has no known compartment in this realm`,\n        );\n      }\n    }\n\n    const invalidNames = arrayFilter(\n      getOwnPropertyNames(globalLexicalsOption),\n      identifier => !isValidIdentifierName(identifier),\n    );\n    if (invalidNames.length) {\n      throw new TypeError(\n        `Cannot create compartment with invalid names for global lexicals: ${arrayJoin(\n          invalidNames,\n          ', ',\n        )}; these names would not be lexically mentionable`,\n      );\n    }\n    // The caller continues to own the globalLexicals object they passed to\n    // the compartment constructor, but the compartment only respects the\n    // original values and they are constants in the scope of evaluated\n    // programs and executed modules.\n    // This shallow copy captures only the values of enumerable own\n    // properties, erasing accessors.\n    // The snapshot is frozen to ensure that the properties are immutable\n    // when transferred-by-property-descriptor onto local scope objects.\n    const globalLexicals = freeze({ ...globalLexicalsOption });\n\n    const globalObject = {};\n\n    // We must initialize all constant properties first because\n    // `makeSafeEvaluator` may use them to create optimized bindings\n    // in the evaluator.\n    // TODO: consider merging into a single initialization if internal\n    // evaluator is no longer eagerly created\n    setGlobalObjectConstantProperties(globalObject);\n\n    const knownScopeProxies = new WeakSet();\n    const { safeEvaluate } = makeSafeEvaluator({\n      globalObject,\n      globalLexicals,\n      globalTransforms,\n      sloppyGlobalsMode: false,\n      knownScopeProxies,\n    });\n\n    setGlobalObjectMutableProperties(globalObject, {\n      intrinsics,\n      newGlobalPropertyNames: sharedGlobalPropertyNames,\n      makeCompartmentConstructor: targetMakeCompartmentConstructor,\n      markVirtualizedNativeFunction,\n    });\n\n    // TODO: maybe add evalTaming to the Compartment constructor 3rd options?\n    setGlobalObjectEvaluators(\n      globalObject,\n      safeEvaluate,\n      markVirtualizedNativeFunction,\n    );\n\n    assign(globalObject, endowments);\n\n    weakmapSet(privateFields, this, {\n      name,\n      globalTransforms,\n      globalObject,\n      knownScopeProxies,\n      globalLexicals,\n      safeEvaluate,\n      resolveHook,\n      importHook,\n      moduleMap,\n      moduleMapHook,\n      moduleRecords,\n      __shimTransforms__,\n      deferredExports,\n      instances,\n    });\n  }\n\n  Compartment.prototype = CompartmentPrototype;\n\n  return Compartment;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}