{"ast":null,"code":"// @ts-check\nimport { FERAL_REG_EXP, SyntaxError, stringReplace, stringSearch, stringSlice, stringSplit } from './commons.js';\nimport { getSourceURL } from './get-source-url.js';\n/**\n * Find the first occurence of the given pattern and return\n * the location as the approximate line number.\n *\n * @param {string} src\n * @param {RegExp} pattern\n * @returns {number}\n */\n\nfunction getLineNumber(src, pattern) {\n  const index = stringSearch(src, pattern);\n\n  if (index < 0) {\n    return -1;\n  } // The importPattern incidentally captures an initial \\n in\n  // an attempt to reject a . prefix, so we need to offset\n  // the line number in that case.\n\n\n  const adjustment = src[index] === '\\n' ? 1 : 0;\n  return stringSplit(stringSlice(src, 0, index), '\\n').length + adjustment;\n} // /////////////////////////////////////////////////////////////////////////////\n\n\nconst htmlCommentPattern = new FERAL_REG_EXP(`(?:${'<'}!--|--${'>'})`, 'g');\n/**\n * Conservatively reject the source text if it may contain text that some\n * JavaScript parsers may treat as an html-like comment. To reject without\n * parsing, `rejectHtmlComments` will also reject some other text as well.\n *\n * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n * explains that JavaScript parsers may or may not recognize html\n * comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n * immediately followed by \">\" in non-module source text, and treat\n * them as a kind of line comment. Since otherwise both of these can\n * appear in normal JavaScript source code as a sequence of operators,\n * we have the terrifying possibility of the same source code parsing\n * one way on one correct JavaScript implementation, and another way\n * on another.\n *\n * This shim takes the conservative strategy of just rejecting source\n * text that contains these strings anywhere. Note that this very\n * source file is written strangely to avoid mentioning these\n * character strings explicitly.\n *\n * We do not write the regexp in a straightforward way, so that an\n * apparennt html comment does not appear in this file. Thus, we avoid\n * rejection by the overly eager rejectDangerousSources.\n *\n * @param {string} src\n * @returns {string}\n */\n\nexport const rejectHtmlComments = src => {\n  const lineNumber = getLineNumber(src, htmlCommentPattern);\n\n  if (lineNumber < 0) {\n    return src;\n  }\n\n  const name = getSourceURL(src);\n  throw new SyntaxError(`Possible HTML comment rejected at ${name}:${lineNumber}. (SES_HTML_COMMENT_REJECTED)`);\n};\n/**\n * An optional transform to place ahead of `rejectHtmlComments` to evade *that*\n * rejection. However, it may change the meaning of the program.\n *\n * This evasion replaces each alleged html comment with the space-separated\n * JavaScript operator sequence that it may mean, assuming that it appears\n * outside of a comment or literal string, in source code where the JS\n * parser makes no special case for html comments (like module source code).\n * In that case, this evasion preserves the meaning of the program, though it\n * does change the souce column numbers on each effected line.\n *\n * If the html comment appeared in a literal (a string literal, regexp literal,\n * or a template literal), then this evasion will change the meaning of the\n * program by changing the text of that literal.\n *\n * If the html comment appeared in a JavaScript comment, then this evasion does\n * not change the meaning of the program because it only changes the contents of\n * those comments.\n *\n * @param { string } src\n * @returns { string }\n */\n\nexport const evadeHtmlCommentTest = src => {\n  const replaceFn = match => match[0] === '<' ? '< ! --' : '-- >';\n\n  return stringReplace(src, htmlCommentPattern, replaceFn);\n}; // /////////////////////////////////////////////////////////////////////////////\n\nconst importPattern = new FERAL_REG_EXP('(^|[^.])\\\\bimport(\\\\s*(?:\\\\(|/[/*]))', 'g');\n/**\n * Conservatively reject the source text if it may contain a dynamic\n * import expression. To reject without parsing, `rejectImportExpressions` will\n * also reject some other text as well.\n *\n * The proposed dynamic import expression is the only syntax currently\n * proposed, that can appear in non-module JavaScript code, that\n * enables direct access to the outside world that cannot be\n * suppressed or intercepted without parsing and rewriting. Instead,\n * this shim conservatively rejects any source text that seems to\n * contain such an expression. To do this safely without parsing, we\n * must also reject some valid programs, i.e., those containing\n * apparent import expressions in literal strings or comments.\n *\n * The current conservative rule looks for the identifier \"import\"\n * followed by either an open paren or something that looks like the\n * beginning of a comment. We assume that we do not need to worry\n * about html comment syntax because that was already rejected by\n * rejectHtmlComments.\n *\n * this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n * U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n * whitespace by the parser, but not matched by /\\s/, then this would admit\n * an attack like: import\\u2028('power.js') . We're trying to distinguish\n * something like that from something like importnotreally('power.js') which\n * is perfectly safe.\n *\n * @param { string } src\n * @returns { string }\n */\n\nexport const rejectImportExpressions = src => {\n  const lineNumber = getLineNumber(src, importPattern);\n\n  if (lineNumber < 0) {\n    return src;\n  }\n\n  const name = getSourceURL(src);\n  throw new SyntaxError(`Possible import expression rejected at ${name}:${lineNumber}. (SES_IMPORT_REJECTED)`);\n};\n/**\n * An optional transform to place ahead of `rejectImportExpressions` to evade\n * *that* rejection. However, it may change the meaning of the program.\n *\n * This evasion replaces each suspicious `import` identifier with `__import__`.\n * If the alleged import expression appears in a JavaScript comment, this\n * evasion will not change the meaning of the program. If it appears in a\n * literal (string literal, regexp literal, or a template literal), then this\n * evasion will change the contents of that literal. If it appears as code\n * where it would be parsed as an expression, then it might or might not change\n * the meaning of the program, depending on the binding, if any, of the lexical\n * variable `__import__`.\n *\n * @param { string } src\n * @returns { string }\n */\n\nexport const evadeImportExpressionTest = src => {\n  const replaceFn = (_, p1, p2) => `${p1}__import__${p2}`;\n\n  return stringReplace(src, importPattern, replaceFn);\n}; // /////////////////////////////////////////////////////////////////////////////\n\nconst someDirectEvalPattern = new FERAL_REG_EXP('(^|[^.])\\\\beval(\\\\s*\\\\()', 'g');\n/**\n * Heuristically reject some text that seems to contain a direct eval\n * expression, with both false positives and false negavives. To reject without\n * parsing, `rejectSomeDirectEvalExpressions` may will also reject some other\n * text as well. It may also accept source text that contains a direct eval\n * written oddly, such as `(eval)(src)`. This false negative is not a security\n * vulnerability. Rather it is a compat hazard because it will execute as\n * an indirect eval under the SES-shim but as a direct eval on platforms that\n * support SES directly (like XS).\n *\n * The shim cannot correctly emulate a direct eval as explained at\n * https://github.com/Agoric/realms-shim/issues/12\n * If we did not reject direct eval syntax, we would\n * accidentally evaluate these with an emulation of indirect eval. To\n * prevent future compatibility problems, in shifting from use of the\n * shim to genuine platform support for the proposal, we should\n * instead statically reject code that seems to contain a direct eval\n * expression.\n *\n * As with the dynamic import expression, to avoid a full parse, we do\n * this approximately with a regexp, that will also reject strings\n * that appear safely in comments or strings. Unlike dynamic import,\n * if we miss some, this only creates future compat problems, not\n * security problems. Thus, we are only trying to catch innocent\n * occurrences, not malicious one. In particular, `(eval)(...)` is\n * direct eval syntax that would not be caught by the following regexp.\n *\n * Exported for unit tests.\n *\n * @param { string } src\n * @returns { string }\n */\n\nexport const rejectSomeDirectEvalExpressions = src => {\n  const lineNumber = getLineNumber(src, someDirectEvalPattern);\n\n  if (lineNumber < 0) {\n    return src;\n  }\n\n  const name = getSourceURL(src);\n  throw new SyntaxError(`Possible direct eval expression rejected at ${name}:${lineNumber}. (SES_EVAL_REJECTED)`);\n}; // /////////////////////////////////////////////////////////////////////////////\n\n/**\n * A transform that bundles together the transforms that must unconditionally\n * happen last in order to ensure safe evaluation without parsing.\n *\n * @param {string} source\n * @returns {string}\n */\n\nexport const mandatoryTransforms = source => {\n  source = rejectHtmlComments(source);\n  source = rejectImportExpressions(source);\n  return source;\n};\n/**\n * Starting with `source`, apply each transform to the result of the\n * previous one, returning the result of the last transformation.\n *\n * @param {string} source\n * @param {((str: string) => string)[]} transforms\n * @returns {string}\n */\n\nexport const applyTransforms = (source, transforms) => {\n  for (const transform of transforms) {\n    source = transform(source);\n  }\n\n  return source;\n};","map":{"version":3,"names":["FERAL_REG_EXP","SyntaxError","stringReplace","stringSearch","stringSlice","stringSplit","getSourceURL","getLineNumber","src","pattern","index","adjustment","length","htmlCommentPattern","rejectHtmlComments","lineNumber","name","evadeHtmlCommentTest","replaceFn","match","importPattern","rejectImportExpressions","evadeImportExpressionTest","_","p1","p2","someDirectEvalPattern","rejectSomeDirectEvalExpressions","mandatoryTransforms","source","applyTransforms","transforms","transform"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/transforms.js"],"sourcesContent":["// @ts-check\n\nimport {\n  FERAL_REG_EXP,\n  SyntaxError,\n  stringReplace,\n  stringSearch,\n  stringSlice,\n  stringSplit,\n} from './commons.js';\nimport { getSourceURL } from './get-source-url.js';\n\n/**\n * Find the first occurence of the given pattern and return\n * the location as the approximate line number.\n *\n * @param {string} src\n * @param {RegExp} pattern\n * @returns {number}\n */\nfunction getLineNumber(src, pattern) {\n  const index = stringSearch(src, pattern);\n  if (index < 0) {\n    return -1;\n  }\n\n  // The importPattern incidentally captures an initial \\n in\n  // an attempt to reject a . prefix, so we need to offset\n  // the line number in that case.\n  const adjustment = src[index] === '\\n' ? 1 : 0;\n\n  return stringSplit(stringSlice(src, 0, index), '\\n').length + adjustment;\n}\n\n// /////////////////////////////////////////////////////////////////////////////\n\nconst htmlCommentPattern = new FERAL_REG_EXP(`(?:${'<'}!--|--${'>'})`, 'g');\n\n/**\n * Conservatively reject the source text if it may contain text that some\n * JavaScript parsers may treat as an html-like comment. To reject without\n * parsing, `rejectHtmlComments` will also reject some other text as well.\n *\n * https://www.ecma-international.org/ecma-262/9.0/index.html#sec-html-like-comments\n * explains that JavaScript parsers may or may not recognize html\n * comment tokens \"<\" immediately followed by \"!--\" and \"--\"\n * immediately followed by \">\" in non-module source text, and treat\n * them as a kind of line comment. Since otherwise both of these can\n * appear in normal JavaScript source code as a sequence of operators,\n * we have the terrifying possibility of the same source code parsing\n * one way on one correct JavaScript implementation, and another way\n * on another.\n *\n * This shim takes the conservative strategy of just rejecting source\n * text that contains these strings anywhere. Note that this very\n * source file is written strangely to avoid mentioning these\n * character strings explicitly.\n *\n * We do not write the regexp in a straightforward way, so that an\n * apparennt html comment does not appear in this file. Thus, we avoid\n * rejection by the overly eager rejectDangerousSources.\n *\n * @param {string} src\n * @returns {string}\n */\nexport const rejectHtmlComments = src => {\n  const lineNumber = getLineNumber(src, htmlCommentPattern);\n  if (lineNumber < 0) {\n    return src;\n  }\n  const name = getSourceURL(src);\n  throw new SyntaxError(\n    `Possible HTML comment rejected at ${name}:${lineNumber}. (SES_HTML_COMMENT_REJECTED)`,\n  );\n};\n\n/**\n * An optional transform to place ahead of `rejectHtmlComments` to evade *that*\n * rejection. However, it may change the meaning of the program.\n *\n * This evasion replaces each alleged html comment with the space-separated\n * JavaScript operator sequence that it may mean, assuming that it appears\n * outside of a comment or literal string, in source code where the JS\n * parser makes no special case for html comments (like module source code).\n * In that case, this evasion preserves the meaning of the program, though it\n * does change the souce column numbers on each effected line.\n *\n * If the html comment appeared in a literal (a string literal, regexp literal,\n * or a template literal), then this evasion will change the meaning of the\n * program by changing the text of that literal.\n *\n * If the html comment appeared in a JavaScript comment, then this evasion does\n * not change the meaning of the program because it only changes the contents of\n * those comments.\n *\n * @param { string } src\n * @returns { string }\n */\nexport const evadeHtmlCommentTest = src => {\n  const replaceFn = match => (match[0] === '<' ? '< ! --' : '-- >');\n  return stringReplace(src, htmlCommentPattern, replaceFn);\n};\n\n// /////////////////////////////////////////////////////////////////////////////\n\nconst importPattern = new FERAL_REG_EXP(\n  '(^|[^.])\\\\bimport(\\\\s*(?:\\\\(|/[/*]))',\n  'g',\n);\n\n/**\n * Conservatively reject the source text if it may contain a dynamic\n * import expression. To reject without parsing, `rejectImportExpressions` will\n * also reject some other text as well.\n *\n * The proposed dynamic import expression is the only syntax currently\n * proposed, that can appear in non-module JavaScript code, that\n * enables direct access to the outside world that cannot be\n * suppressed or intercepted without parsing and rewriting. Instead,\n * this shim conservatively rejects any source text that seems to\n * contain such an expression. To do this safely without parsing, we\n * must also reject some valid programs, i.e., those containing\n * apparent import expressions in literal strings or comments.\n *\n * The current conservative rule looks for the identifier \"import\"\n * followed by either an open paren or something that looks like the\n * beginning of a comment. We assume that we do not need to worry\n * about html comment syntax because that was already rejected by\n * rejectHtmlComments.\n *\n * this \\s *must* match all kinds of syntax-defined whitespace. If e.g.\n * U+2028 (LINE SEPARATOR) or U+2029 (PARAGRAPH SEPARATOR) is treated as\n * whitespace by the parser, but not matched by /\\s/, then this would admit\n * an attack like: import\\u2028('power.js') . We're trying to distinguish\n * something like that from something like importnotreally('power.js') which\n * is perfectly safe.\n *\n * @param { string } src\n * @returns { string }\n */\nexport const rejectImportExpressions = src => {\n  const lineNumber = getLineNumber(src, importPattern);\n  if (lineNumber < 0) {\n    return src;\n  }\n  const name = getSourceURL(src);\n  throw new SyntaxError(\n    `Possible import expression rejected at ${name}:${lineNumber}. (SES_IMPORT_REJECTED)`,\n  );\n};\n\n/**\n * An optional transform to place ahead of `rejectImportExpressions` to evade\n * *that* rejection. However, it may change the meaning of the program.\n *\n * This evasion replaces each suspicious `import` identifier with `__import__`.\n * If the alleged import expression appears in a JavaScript comment, this\n * evasion will not change the meaning of the program. If it appears in a\n * literal (string literal, regexp literal, or a template literal), then this\n * evasion will change the contents of that literal. If it appears as code\n * where it would be parsed as an expression, then it might or might not change\n * the meaning of the program, depending on the binding, if any, of the lexical\n * variable `__import__`.\n *\n * @param { string } src\n * @returns { string }\n */\nexport const evadeImportExpressionTest = src => {\n  const replaceFn = (_, p1, p2) => `${p1}__import__${p2}`;\n  return stringReplace(src, importPattern, replaceFn);\n};\n\n// /////////////////////////////////////////////////////////////////////////////\n\nconst someDirectEvalPattern = new FERAL_REG_EXP(\n  '(^|[^.])\\\\beval(\\\\s*\\\\()',\n  'g',\n);\n\n/**\n * Heuristically reject some text that seems to contain a direct eval\n * expression, with both false positives and false negavives. To reject without\n * parsing, `rejectSomeDirectEvalExpressions` may will also reject some other\n * text as well. It may also accept source text that contains a direct eval\n * written oddly, such as `(eval)(src)`. This false negative is not a security\n * vulnerability. Rather it is a compat hazard because it will execute as\n * an indirect eval under the SES-shim but as a direct eval on platforms that\n * support SES directly (like XS).\n *\n * The shim cannot correctly emulate a direct eval as explained at\n * https://github.com/Agoric/realms-shim/issues/12\n * If we did not reject direct eval syntax, we would\n * accidentally evaluate these with an emulation of indirect eval. To\n * prevent future compatibility problems, in shifting from use of the\n * shim to genuine platform support for the proposal, we should\n * instead statically reject code that seems to contain a direct eval\n * expression.\n *\n * As with the dynamic import expression, to avoid a full parse, we do\n * this approximately with a regexp, that will also reject strings\n * that appear safely in comments or strings. Unlike dynamic import,\n * if we miss some, this only creates future compat problems, not\n * security problems. Thus, we are only trying to catch innocent\n * occurrences, not malicious one. In particular, `(eval)(...)` is\n * direct eval syntax that would not be caught by the following regexp.\n *\n * Exported for unit tests.\n *\n * @param { string } src\n * @returns { string }\n */\nexport const rejectSomeDirectEvalExpressions = src => {\n  const lineNumber = getLineNumber(src, someDirectEvalPattern);\n  if (lineNumber < 0) {\n    return src;\n  }\n  const name = getSourceURL(src);\n  throw new SyntaxError(\n    `Possible direct eval expression rejected at ${name}:${lineNumber}. (SES_EVAL_REJECTED)`,\n  );\n};\n\n// /////////////////////////////////////////////////////////////////////////////\n\n/**\n * A transform that bundles together the transforms that must unconditionally\n * happen last in order to ensure safe evaluation without parsing.\n *\n * @param {string} source\n * @returns {string}\n */\nexport const mandatoryTransforms = source => {\n  source = rejectHtmlComments(source);\n  source = rejectImportExpressions(source);\n  return source;\n};\n\n/**\n * Starting with `source`, apply each transform to the result of the\n * previous one, returning the result of the last transformation.\n *\n * @param {string} source\n * @param {((str: string) => string)[]} transforms\n * @returns {string}\n */\nexport const applyTransforms = (source, transforms) => {\n  for (const transform of transforms) {\n    source = transform(source);\n  }\n  return source;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}