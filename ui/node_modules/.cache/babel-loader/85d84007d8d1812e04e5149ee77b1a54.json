{"ast":null,"code":"import { arrayFilter, arrayIncludes, getOwnPropertyDescriptor, getOwnPropertyNames, objectHasOwnProperty, regexpTest } from './commons.js';\n/**\n * keywords\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\n\nconst keywords = [// 11.6.2.1 Keywords\n'await', 'break', 'case', 'catch', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new', 'return', 'super', 'switch', 'this', 'throw', 'try', 'typeof', 'var', 'void', 'while', 'with', 'yield', // Also reserved when parsing strict mode code\n'let', 'static', // 11.6.2.2 Future Reserved Words\n'enum', // Also reserved when parsing strict mode code\n'implements', 'package', 'protected', 'interface', 'private', 'public', // Reserved but not mentioned in specs\n'await', 'null', 'true', 'false', 'this', 'arguments'];\n/**\n * identifierPattern\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\n\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n/**\n * isValidIdentifierName()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n *\n * @param {string} name\n */\n\nexport const isValidIdentifierName = name => {\n  // Ensure we have a valid identifier. We use regexpTest rather than\n  // /../.test() to guard against the case where RegExp has been poisoned.\n  return name !== 'eval' && !arrayIncludes(keywords, name) && regexpTest(identifierPattern, name);\n};\n/*\n * isImmutableDataProperty\n */\n\nfunction isImmutableDataProperty(obj, name) {\n  const desc = getOwnPropertyDescriptor(obj, name);\n  return (//\n    // The getters will not have .writable, don't let the falsyness of\n    // 'undefined' trick us: test with === false, not ! . However descriptors\n    // inherit from the (potentially poisoned) global object, so we might see\n    // extra properties which weren't really there. Accessor properties have\n    // 'get/set/enumerable/configurable', while data properties have\n    // 'value/writable/enumerable/configurable'.\n    desc.configurable === false && desc.writable === false && //\n    // Checks for data properties because they're the only ones we can\n    // optimize (accessors are most likely non-constant). Descriptors can't\n    // can't have accessors and value properties at the same time, therefore\n    // this check is sufficient. Using explicit own property deal with the\n    // case where Object.prototype has been poisoned.\n    objectHasOwnProperty(desc, 'value')\n  );\n}\n/**\n * getScopeConstants()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n *\n * @param {Object} globalObject\n * @param {Object} localObject\n */\n\n\nexport const getScopeConstants = function (globalObject) {\n  let localObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // getOwnPropertyNames() does ignore Symbols so we don't need to\n  // filter them out.\n  const globalNames = getOwnPropertyNames(globalObject);\n  const localNames = getOwnPropertyNames(localObject); // Collect all valid & immutable identifiers from the endowments.\n\n  const localConstants = arrayFilter(localNames, name => isValidIdentifierName(name) && isImmutableDataProperty(localObject, name)); // Collect all valid & immutable identifiers from the global that\n  // are also not present in the endwoments (immutable or not).\n\n  const globalConstants = arrayFilter(globalNames, name => // Can't define a constant: it would prevent a\n  // lookup on the endowments.\n  !arrayIncludes(localNames, name) && isValidIdentifierName(name) && isImmutableDataProperty(globalObject, name));\n  return [...globalConstants, ...localConstants];\n};","map":{"version":3,"names":["arrayFilter","arrayIncludes","getOwnPropertyDescriptor","getOwnPropertyNames","objectHasOwnProperty","regexpTest","keywords","identifierPattern","isValidIdentifierName","name","isImmutableDataProperty","obj","desc","configurable","writable","getScopeConstants","globalObject","localObject","globalNames","localNames","localConstants","globalConstants"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/scope-constants.js"],"sourcesContent":["import {\n  arrayFilter,\n  arrayIncludes,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  objectHasOwnProperty,\n  regexpTest,\n} from './commons.js';\n\n/**\n * keywords\n * In JavaScript you cannot use these reserved words as variables.\n * See 11.6.1 Identifier Names\n */\nconst keywords = [\n  // 11.6.2.1 Keywords\n  'await',\n  'break',\n  'case',\n  'catch',\n  'class',\n  'const',\n  'continue',\n  'debugger',\n  'default',\n  'delete',\n  'do',\n  'else',\n  'export',\n  'extends',\n  'finally',\n  'for',\n  'function',\n  'if',\n  'import',\n  'in',\n  'instanceof',\n  'new',\n  'return',\n  'super',\n  'switch',\n  'this',\n  'throw',\n  'try',\n  'typeof',\n  'var',\n  'void',\n  'while',\n  'with',\n  'yield',\n\n  // Also reserved when parsing strict mode code\n  'let',\n  'static',\n\n  // 11.6.2.2 Future Reserved Words\n  'enum',\n\n  // Also reserved when parsing strict mode code\n  'implements',\n  'package',\n  'protected',\n  'interface',\n  'private',\n  'public',\n\n  // Reserved but not mentioned in specs\n  'await',\n\n  'null',\n  'true',\n  'false',\n\n  'this',\n  'arguments',\n];\n\n/**\n * identifierPattern\n * Simplified validation of indentifier names: may only contain alphanumeric\n * characters (or \"$\" or \"_\"), and may not start with a digit. This is safe\n * and does not reduces the compatibility of the shim. The motivation for\n * this limitation was to decrease the complexity of the implementation,\n * and to maintain a resonable level of performance.\n * Note: \\w is equivalent [a-zA-Z_0-9]\n * See 11.6.1 Identifier Names\n */\nconst identifierPattern = /^[a-zA-Z_$][\\w$]*$/;\n\n/**\n * isValidIdentifierName()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n *\n * @param {string} name\n */\nexport const isValidIdentifierName = name => {\n  // Ensure we have a valid identifier. We use regexpTest rather than\n  // /../.test() to guard against the case where RegExp has been poisoned.\n  return (\n    name !== 'eval' &&\n    !arrayIncludes(keywords, name) &&\n    regexpTest(identifierPattern, name)\n  );\n};\n\n/*\n * isImmutableDataProperty\n */\n\nfunction isImmutableDataProperty(obj, name) {\n  const desc = getOwnPropertyDescriptor(obj, name);\n  return (\n    //\n    // The getters will not have .writable, don't let the falsyness of\n    // 'undefined' trick us: test with === false, not ! . However descriptors\n    // inherit from the (potentially poisoned) global object, so we might see\n    // extra properties which weren't really there. Accessor properties have\n    // 'get/set/enumerable/configurable', while data properties have\n    // 'value/writable/enumerable/configurable'.\n    desc.configurable === false &&\n    desc.writable === false &&\n    //\n    // Checks for data properties because they're the only ones we can\n    // optimize (accessors are most likely non-constant). Descriptors can't\n    // can't have accessors and value properties at the same time, therefore\n    // this check is sufficient. Using explicit own property deal with the\n    // case where Object.prototype has been poisoned.\n    objectHasOwnProperty(desc, 'value')\n  );\n}\n\n/**\n * getScopeConstants()\n * What variable names might it bring into scope? These include all\n * property names which can be variable names, including the names\n * of inherited properties. It excludes symbols and names which are\n * keywords. We drop symbols safely. Currently, this shim refuses\n * service if any of the names are keywords or keyword-like. This is\n * safe and only prevent performance optimization.\n *\n * @param {Object} globalObject\n * @param {Object} localObject\n */\nexport const getScopeConstants = (globalObject, localObject = {}) => {\n  // getOwnPropertyNames() does ignore Symbols so we don't need to\n  // filter them out.\n  const globalNames = getOwnPropertyNames(globalObject);\n  const localNames = getOwnPropertyNames(localObject);\n\n  // Collect all valid & immutable identifiers from the endowments.\n  const localConstants = arrayFilter(\n    localNames,\n    name =>\n      isValidIdentifierName(name) && isImmutableDataProperty(localObject, name),\n  );\n\n  // Collect all valid & immutable identifiers from the global that\n  // are also not present in the endwoments (immutable or not).\n  const globalConstants = arrayFilter(\n    globalNames,\n    name =>\n      // Can't define a constant: it would prevent a\n      // lookup on the endowments.\n      !arrayIncludes(localNames, name) &&\n      isValidIdentifierName(name) &&\n      isImmutableDataProperty(globalObject, name),\n  );\n\n  return [...globalConstants, ...localConstants];\n};\n"],"mappings":"AAAA,SACEA,WADF,EAEEC,aAFF,EAGEC,wBAHF,EAIEC,mBAJF,EAKEC,oBALF,EAMEC,UANF,QAOO,cAPP;AASA;AACA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAG,CACf;AACA,OAFe,EAGf,OAHe,EAIf,MAJe,EAKf,OALe,EAMf,OANe,EAOf,OAPe,EAQf,UARe,EASf,UATe,EAUf,SAVe,EAWf,QAXe,EAYf,IAZe,EAaf,MAbe,EAcf,QAde,EAef,SAfe,EAgBf,SAhBe,EAiBf,KAjBe,EAkBf,UAlBe,EAmBf,IAnBe,EAoBf,QApBe,EAqBf,IArBe,EAsBf,YAtBe,EAuBf,KAvBe,EAwBf,QAxBe,EAyBf,OAzBe,EA0Bf,QA1Be,EA2Bf,MA3Be,EA4Bf,OA5Be,EA6Bf,KA7Be,EA8Bf,QA9Be,EA+Bf,KA/Be,EAgCf,MAhCe,EAiCf,OAjCe,EAkCf,MAlCe,EAmCf,OAnCe,EAqCf;AACA,KAtCe,EAuCf,QAvCe,EAyCf;AACA,MA1Ce,EA4Cf;AACA,YA7Ce,EA8Cf,SA9Ce,EA+Cf,WA/Ce,EAgDf,WAhDe,EAiDf,SAjDe,EAkDf,QAlDe,EAoDf;AACA,OArDe,EAuDf,MAvDe,EAwDf,MAxDe,EAyDf,OAzDe,EA2Df,MA3De,EA4Df,WA5De,CAAjB;AA+DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,iBAAiB,GAAG,oBAA1B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,qBAAqB,GAAGC,IAAI,IAAI;EAC3C;EACA;EACA,OACEA,IAAI,KAAK,MAAT,IACA,CAACR,aAAa,CAACK,QAAD,EAAWG,IAAX,CADd,IAEAJ,UAAU,CAACE,iBAAD,EAAoBE,IAApB,CAHZ;AAKD,CARM;AAUP;AACA;AACA;;AAEA,SAASC,uBAAT,CAAiCC,GAAjC,EAAsCF,IAAtC,EAA4C;EAC1C,MAAMG,IAAI,GAAGV,wBAAwB,CAACS,GAAD,EAAMF,IAAN,CAArC;EACA,OACE;IACA;IACA;IACA;IACA;IACA;IACA;IACAG,IAAI,CAACC,YAAL,KAAsB,KAAtB,IACAD,IAAI,CAACE,QAAL,KAAkB,KADlB,IAEA;IACA;IACA;IACA;IACA;IACA;IACAV,oBAAoB,CAACQ,IAAD,EAAO,OAAP;EAhBtB;AAkBD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,MAAMG,iBAAiB,GAAG,UAACC,YAAD,EAAoC;EAAA,IAArBC,WAAqB,uEAAP,EAAO;EACnE;EACA;EACA,MAAMC,WAAW,GAAGf,mBAAmB,CAACa,YAAD,CAAvC;EACA,MAAMG,UAAU,GAAGhB,mBAAmB,CAACc,WAAD,CAAtC,CAJmE,CAMnE;;EACA,MAAMG,cAAc,GAAGpB,WAAW,CAChCmB,UADgC,EAEhCV,IAAI,IACFD,qBAAqB,CAACC,IAAD,CAArB,IAA+BC,uBAAuB,CAACO,WAAD,EAAcR,IAAd,CAHxB,CAAlC,CAPmE,CAanE;EACA;;EACA,MAAMY,eAAe,GAAGrB,WAAW,CACjCkB,WADiC,EAEjCT,IAAI,IACF;EACA;EACA,CAACR,aAAa,CAACkB,UAAD,EAAaV,IAAb,CAAd,IACAD,qBAAqB,CAACC,IAAD,CADrB,IAEAC,uBAAuB,CAACM,YAAD,EAAeP,IAAf,CAPQ,CAAnC;EAUA,OAAO,CAAC,GAAGY,eAAJ,EAAqB,GAAGD,cAAxB,CAAP;AACD,CA1BM"},"metadata":{},"sourceType":"module"}