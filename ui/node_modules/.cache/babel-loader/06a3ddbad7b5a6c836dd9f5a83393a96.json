{"ast":null,"code":"import { Number, String, TypeError, defineProperty, getOwnPropertyNames, isObject, regexpExec } from './commons.js';\nimport { assert } from './error/assert.js';\nconst {\n  details: d,\n  quote: q\n} = assert;\nconst localePattern = /^(\\w*[a-z])Locale([A-Z]\\w*)$/; // Use concise methods to obtain named functions without constructor\n// behavior or `.prototype` property.\n\nconst tamedMethods = {\n  // See https://tc39.es/ecma262/#sec-string.prototype.localecompare\n  localeCompare(that) {\n    if (this === null || this === undefined) {\n      throw new TypeError('Cannot localeCompare with null or undefined \"this\" value');\n    }\n\n    const s = `${this}`;\n    that = `${that}`;\n\n    if (s < that) {\n      return -1;\n    }\n\n    if (s > that) {\n      return 1;\n    }\n\n    assert(s === that, d`expected ${q(s)} and ${q(that)} to compare`);\n    return 0;\n  },\n\n  toString() {\n    return `${this}`;\n  }\n\n};\nconst nonLocaleCompare = tamedMethods.localeCompare;\nconst numberToString = tamedMethods.toString;\nexport default function tameLocaleMethods(intrinsics) {\n  let localeTaming = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'safe';\n\n  if (localeTaming !== 'safe' && localeTaming !== 'unsafe') {\n    throw new TypeError(`unrecognized localeTaming ${localeTaming}`);\n  }\n\n  if (localeTaming === 'unsafe') {\n    return;\n  }\n\n  defineProperty(String.prototype, 'localeCompare', {\n    value: nonLocaleCompare\n  });\n\n  for (const intrinsicName of getOwnPropertyNames(intrinsics)) {\n    const intrinsic = intrinsics[intrinsicName];\n\n    if (isObject(intrinsic)) {\n      for (const methodName of getOwnPropertyNames(intrinsic)) {\n        const match = regexpExec(localePattern, methodName);\n\n        if (match) {\n          assert(typeof intrinsic[methodName] === 'function', d`expected ${q(methodName)} to be a function`);\n          const nonLocaleMethodName = `${match[1]}${match[2]}`;\n          const method = intrinsic[nonLocaleMethodName];\n          assert(typeof method === 'function', d`function ${q(nonLocaleMethodName)} not found`);\n          defineProperty(intrinsic, methodName, {\n            value: method\n          });\n        }\n      }\n    }\n  } // Numbers are special because toString accepts a radix instead of ignoring\n  // all of the arguments that we would otherwise forward.\n\n\n  defineProperty(Number.prototype, 'toLocaleString', {\n    value: numberToString\n  });\n}","map":{"version":3,"names":["Number","String","TypeError","defineProperty","getOwnPropertyNames","isObject","regexpExec","assert","details","d","quote","q","localePattern","tamedMethods","localeCompare","that","undefined","s","toString","nonLocaleCompare","numberToString","tameLocaleMethods","intrinsics","localeTaming","prototype","value","intrinsicName","intrinsic","methodName","match","nonLocaleMethodName","method"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/ses/src/tame-locale-methods.js"],"sourcesContent":["import {\n  Number,\n  String,\n  TypeError,\n  defineProperty,\n  getOwnPropertyNames,\n  isObject,\n  regexpExec,\n} from './commons.js';\nimport { assert } from './error/assert.js';\n\nconst { details: d, quote: q } = assert;\n\nconst localePattern = /^(\\w*[a-z])Locale([A-Z]\\w*)$/;\n\n// Use concise methods to obtain named functions without constructor\n// behavior or `.prototype` property.\nconst tamedMethods = {\n  // See https://tc39.es/ecma262/#sec-string.prototype.localecompare\n  localeCompare(that) {\n    if (this === null || this === undefined) {\n      throw new TypeError(\n        'Cannot localeCompare with null or undefined \"this\" value',\n      );\n    }\n    const s = `${this}`;\n    that = `${that}`;\n    if (s < that) {\n      return -1;\n    }\n    if (s > that) {\n      return 1;\n    }\n    assert(s === that, d`expected ${q(s)} and ${q(that)} to compare`);\n    return 0;\n  },\n\n  toString() {\n    return `${this}`;\n  },\n};\n\nconst nonLocaleCompare = tamedMethods.localeCompare;\nconst numberToString = tamedMethods.toString;\n\nexport default function tameLocaleMethods(intrinsics, localeTaming = 'safe') {\n  if (localeTaming !== 'safe' && localeTaming !== 'unsafe') {\n    throw new TypeError(`unrecognized localeTaming ${localeTaming}`);\n  }\n  if (localeTaming === 'unsafe') {\n    return;\n  }\n\n  defineProperty(String.prototype, 'localeCompare', {\n    value: nonLocaleCompare,\n  });\n\n  for (const intrinsicName of getOwnPropertyNames(intrinsics)) {\n    const intrinsic = intrinsics[intrinsicName];\n    if (isObject(intrinsic)) {\n      for (const methodName of getOwnPropertyNames(intrinsic)) {\n        const match = regexpExec(localePattern, methodName);\n        if (match) {\n          assert(\n            typeof intrinsic[methodName] === 'function',\n            d`expected ${q(methodName)} to be a function`,\n          );\n          const nonLocaleMethodName = `${match[1]}${match[2]}`;\n          const method = intrinsic[nonLocaleMethodName];\n          assert(\n            typeof method === 'function',\n            d`function ${q(nonLocaleMethodName)} not found`,\n          );\n          defineProperty(intrinsic, methodName, { value: method });\n        }\n      }\n    }\n  }\n\n  // Numbers are special because toString accepts a radix instead of ignoring\n  // all of the arguments that we would otherwise forward.\n  defineProperty(Number.prototype, 'toLocaleString', {\n    value: numberToString,\n  });\n}\n"],"mappings":"AAAA,SACEA,MADF,EAEEC,MAFF,EAGEC,SAHF,EAIEC,cAJF,EAKEC,mBALF,EAMEC,QANF,EAOEC,UAPF,QAQO,cARP;AASA,SAASC,MAAT,QAAuB,mBAAvB;AAEA,MAAM;EAAEC,OAAO,EAAEC,CAAX;EAAcC,KAAK,EAAEC;AAArB,IAA2BJ,MAAjC;AAEA,MAAMK,aAAa,GAAG,8BAAtB,C,CAEA;AACA;;AACA,MAAMC,YAAY,GAAG;EACnB;EACAC,aAAa,CAACC,IAAD,EAAO;IAClB,IAAI,SAAS,IAAT,IAAiB,SAASC,SAA9B,EAAyC;MACvC,MAAM,IAAId,SAAJ,CACJ,0DADI,CAAN;IAGD;;IACD,MAAMe,CAAC,GAAI,GAAE,IAAK,EAAlB;IACAF,IAAI,GAAI,GAAEA,IAAK,EAAf;;IACA,IAAIE,CAAC,GAAGF,IAAR,EAAc;MACZ,OAAO,CAAC,CAAR;IACD;;IACD,IAAIE,CAAC,GAAGF,IAAR,EAAc;MACZ,OAAO,CAAP;IACD;;IACDR,MAAM,CAACU,CAAC,KAAKF,IAAP,EAAaN,CAAE,YAAWE,CAAC,CAACM,CAAD,CAAI,QAAON,CAAC,CAACI,IAAD,CAAO,aAA9C,CAAN;IACA,OAAO,CAAP;EACD,CAlBkB;;EAoBnBG,QAAQ,GAAG;IACT,OAAQ,GAAE,IAAK,EAAf;EACD;;AAtBkB,CAArB;AAyBA,MAAMC,gBAAgB,GAAGN,YAAY,CAACC,aAAtC;AACA,MAAMM,cAAc,GAAGP,YAAY,CAACK,QAApC;AAEA,eAAe,SAASG,iBAAT,CAA2BC,UAA3B,EAA8D;EAAA,IAAvBC,YAAuB,uEAAR,MAAQ;;EAC3E,IAAIA,YAAY,KAAK,MAAjB,IAA2BA,YAAY,KAAK,QAAhD,EAA0D;IACxD,MAAM,IAAIrB,SAAJ,CAAe,6BAA4BqB,YAAa,EAAxD,CAAN;EACD;;EACD,IAAIA,YAAY,KAAK,QAArB,EAA+B;IAC7B;EACD;;EAEDpB,cAAc,CAACF,MAAM,CAACuB,SAAR,EAAmB,eAAnB,EAAoC;IAChDC,KAAK,EAAEN;EADyC,CAApC,CAAd;;EAIA,KAAK,MAAMO,aAAX,IAA4BtB,mBAAmB,CAACkB,UAAD,CAA/C,EAA6D;IAC3D,MAAMK,SAAS,GAAGL,UAAU,CAACI,aAAD,CAA5B;;IACA,IAAIrB,QAAQ,CAACsB,SAAD,CAAZ,EAAyB;MACvB,KAAK,MAAMC,UAAX,IAAyBxB,mBAAmB,CAACuB,SAAD,CAA5C,EAAyD;QACvD,MAAME,KAAK,GAAGvB,UAAU,CAACM,aAAD,EAAgBgB,UAAhB,CAAxB;;QACA,IAAIC,KAAJ,EAAW;UACTtB,MAAM,CACJ,OAAOoB,SAAS,CAACC,UAAD,CAAhB,KAAiC,UAD7B,EAEJnB,CAAE,YAAWE,CAAC,CAACiB,UAAD,CAAa,mBAFvB,CAAN;UAIA,MAAME,mBAAmB,GAAI,GAAED,KAAK,CAAC,CAAD,CAAI,GAAEA,KAAK,CAAC,CAAD,CAAI,EAAnD;UACA,MAAME,MAAM,GAAGJ,SAAS,CAACG,mBAAD,CAAxB;UACAvB,MAAM,CACJ,OAAOwB,MAAP,KAAkB,UADd,EAEJtB,CAAE,YAAWE,CAAC,CAACmB,mBAAD,CAAsB,YAFhC,CAAN;UAIA3B,cAAc,CAACwB,SAAD,EAAYC,UAAZ,EAAwB;YAAEH,KAAK,EAAEM;UAAT,CAAxB,CAAd;QACD;MACF;IACF;EACF,CAhC0E,CAkC3E;EACA;;;EACA5B,cAAc,CAACH,MAAM,CAACwB,SAAR,EAAmB,gBAAnB,EAAqC;IACjDC,KAAK,EAAEL;EAD0C,CAArC,CAAd;AAGD"},"metadata":{},"sourceType":"module"}