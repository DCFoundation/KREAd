{"ast":null,"code":"// @ts-check\n/// <reference types=\"ses\"/>\nimport { assertChecker } from './passStyle-helpers.js';\n/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */\n\nconst {\n  details: X\n} = assert;\nconst {\n  getPrototypeOf,\n  getOwnPropertyDescriptors\n} = Object;\nconst {\n  ownKeys\n} = Reflect; // TODO: Maintenance hazard: Coordinate with the list of errors in the SES\n// whilelist. Currently, both omit AggregateError, which is now standard. Both\n// must eventually include it.\n\nconst errorConstructors = new Map([['Error', Error], ['EvalError', EvalError], ['RangeError', RangeError], ['ReferenceError', ReferenceError], ['SyntaxError', SyntaxError], ['TypeError', TypeError], ['URIError', URIError]]);\nexport const getErrorConstructor = name => errorConstructors.get(name);\nharden(getErrorConstructor);\n/**\n * Validating error objects are passable raises a tension between security\n * vs preserving diagnostic information. For errors, we need to remember\n * the error itself exists to help us diagnose a bug that's likely more\n * pressing than a validity bug in the error itself. Thus, whenever it is safe\n * to do so, we prefer to let the error test succeed and to couch these\n * complaints as notes on the error.\n *\n * To resolve this, such a malformed error object will still pass\n * `canBeValid(err)` with no check, so marshal can use this for top\n * level error to report from, even if it would not actually validate.\n * Instead, the diagnostics that `assertError` would have reported are\n * attached as notes to the malformed error. Thus, a malformed\n * error is passable by itself, but not as part of a passable structure.\n *\n * @type {PassStyleHelper}\n */\n\nexport const ErrorHelper = harden({\n  styleName: 'error',\n  canBeValid: function (candidate) {\n    let check = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x => x;\n\n    // TODO: Need a better test than instanceof\n    if (!(candidate instanceof Error)) {\n      return check(false, X`Error expected: ${candidate}`);\n    }\n\n    const proto = getPrototypeOf(candidate);\n    const {\n      name\n    } = proto;\n    const EC = getErrorConstructor(name);\n\n    if (!EC || EC.prototype !== proto) {\n      const note = X`Errors must inherit from an error class .prototype ${candidate}`; // Only terminate if check throws\n\n      check(false, note);\n      assert.note(candidate, note);\n    }\n\n    const {\n      // Must allow `cause`, `errors`\n      message: mDesc,\n      // Allow but ignore only extraneous own `stack` property.\n      stack: _optStackDesc,\n      ...restDescs\n    } = getOwnPropertyDescriptors(candidate);\n\n    if (ownKeys(restDescs).length >= 1) {\n      const note = X`Passed Error has extra unpassed properties ${restDescs}`; // Only terminate if check throws\n\n      check(false, note);\n      assert.note(candidate, note);\n    }\n\n    if (mDesc) {\n      if (typeof mDesc.value !== 'string') {\n        const note = X`Passed Error \"message\" ${mDesc} must be a string-valued data property.`; // Only terminate if check throws\n\n        check(false, note);\n        assert.note(candidate, note);\n      }\n\n      if (mDesc.enumerable) {\n        const note = X`Passed Error \"message\" ${mDesc} must not be enumerable`; // Only terminate if check throws\n\n        check(false, note);\n        assert.note(candidate, note);\n      }\n    }\n\n    return true;\n  },\n  assertValid: candidate => {\n    ErrorHelper.canBeValid(candidate, assertChecker);\n  }\n});\n/**\n * Return a new passable error that propagates the diagnostic info of the\n * original, and is linked to the original as a note.\n *\n * @param {Error} err\n * @returns {Error}\n */\n\nexport const toPassableError = err => {\n  const {\n    name,\n    message\n  } = err;\n  const EC = getErrorConstructor(`${name}`) || Error;\n  const newError = harden(new EC(`${message}`)); // Even the cleaned up error copy, if sent to the console, should\n  // cause hidden diagnostic information of the original error\n  // to be logged.\n\n  assert.note(newError, X`copied from error ${err}`);\n  return newError;\n};\nharden(toPassableError);","map":{"version":3,"names":["assertChecker","details","X","assert","getPrototypeOf","getOwnPropertyDescriptors","Object","ownKeys","Reflect","errorConstructors","Map","Error","EvalError","RangeError","ReferenceError","SyntaxError","TypeError","URIError","getErrorConstructor","name","get","harden","ErrorHelper","styleName","canBeValid","candidate","check","x","proto","EC","prototype","note","message","mDesc","stack","_optStackDesc","restDescs","length","value","enumerable","assertValid","toPassableError","err","newError"],"sources":["/Users/carlostrigoseguin/Documents/KRYHA/agoric/character-builder-repo/ui/node_modules/@endo/marshal/src/helpers/error.js"],"sourcesContent":["// @ts-check\n\n/// <reference types=\"ses\"/>\n\nimport { assertChecker } from './passStyle-helpers.js';\n\n/** @typedef {import('./internal-types.js').PassStyleHelper} PassStyleHelper */\n\nconst { details: X } = assert;\nconst { getPrototypeOf, getOwnPropertyDescriptors } = Object;\nconst { ownKeys } = Reflect;\n\n// TODO: Maintenance hazard: Coordinate with the list of errors in the SES\n// whilelist. Currently, both omit AggregateError, which is now standard. Both\n// must eventually include it.\nconst errorConstructors = new Map([\n  ['Error', Error],\n  ['EvalError', EvalError],\n  ['RangeError', RangeError],\n  ['ReferenceError', ReferenceError],\n  ['SyntaxError', SyntaxError],\n  ['TypeError', TypeError],\n  ['URIError', URIError],\n]);\n\nexport const getErrorConstructor = name => errorConstructors.get(name);\nharden(getErrorConstructor);\n\n/**\n * Validating error objects are passable raises a tension between security\n * vs preserving diagnostic information. For errors, we need to remember\n * the error itself exists to help us diagnose a bug that's likely more\n * pressing than a validity bug in the error itself. Thus, whenever it is safe\n * to do so, we prefer to let the error test succeed and to couch these\n * complaints as notes on the error.\n *\n * To resolve this, such a malformed error object will still pass\n * `canBeValid(err)` with no check, so marshal can use this for top\n * level error to report from, even if it would not actually validate.\n * Instead, the diagnostics that `assertError` would have reported are\n * attached as notes to the malformed error. Thus, a malformed\n * error is passable by itself, but not as part of a passable structure.\n *\n * @type {PassStyleHelper}\n */\nexport const ErrorHelper = harden({\n  styleName: 'error',\n\n  canBeValid: (candidate, check = x => x) => {\n    // TODO: Need a better test than instanceof\n    if (!(candidate instanceof Error)) {\n      return check(false, X`Error expected: ${candidate}`);\n    }\n    const proto = getPrototypeOf(candidate);\n    const { name } = proto;\n    const EC = getErrorConstructor(name);\n    if (!EC || EC.prototype !== proto) {\n      const note = X`Errors must inherit from an error class .prototype ${candidate}`;\n      // Only terminate if check throws\n      check(false, note);\n      assert.note(candidate, note);\n    }\n\n    const {\n      // Must allow `cause`, `errors`\n      message: mDesc,\n      // Allow but ignore only extraneous own `stack` property.\n      stack: _optStackDesc,\n      ...restDescs\n    } = getOwnPropertyDescriptors(candidate);\n    if (ownKeys(restDescs).length >= 1) {\n      const note = X`Passed Error has extra unpassed properties ${restDescs}`;\n      // Only terminate if check throws\n      check(false, note);\n      assert.note(candidate, note);\n    }\n    if (mDesc) {\n      if (typeof mDesc.value !== 'string') {\n        const note = X`Passed Error \"message\" ${mDesc} must be a string-valued data property.`;\n        // Only terminate if check throws\n        check(false, note);\n        assert.note(candidate, note);\n      }\n      if (mDesc.enumerable) {\n        const note = X`Passed Error \"message\" ${mDesc} must not be enumerable`;\n        // Only terminate if check throws\n        check(false, note);\n        assert.note(candidate, note);\n      }\n    }\n    return true;\n  },\n\n  assertValid: candidate => {\n    ErrorHelper.canBeValid(candidate, assertChecker);\n  },\n});\n\n/**\n * Return a new passable error that propagates the diagnostic info of the\n * original, and is linked to the original as a note.\n *\n * @param {Error} err\n * @returns {Error}\n */\nexport const toPassableError = err => {\n  const { name, message } = err;\n\n  const EC = getErrorConstructor(`${name}`) || Error;\n  const newError = harden(new EC(`${message}`));\n  // Even the cleaned up error copy, if sent to the console, should\n  // cause hidden diagnostic information of the original error\n  // to be logged.\n  assert.note(newError, X`copied from error ${err}`);\n  return newError;\n};\nharden(toPassableError);\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}